<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_Evaluator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API
   &#160;<span id="projectnumber">7.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_o_n___evaluator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_Evaluator Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_math.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ade46238934de49cb6a91870f707381a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#ade46238934de49cb6a91870f707381a9">ON_Evaluator</a> (int parameter_count, int value_count, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *domain, const bool *periodic)</td></tr>
<tr class="separator:ade46238934de49cb6a91870f707381a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27f0a638112728273fde6156133d463"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#ae27f0a638112728273fde6156133d463">~ON_Evaluator</a> ()</td></tr>
<tr class="separator:ae27f0a638112728273fde6156133d463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b98b96b74c0d751357612989490ebb0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___interval.html">ON_Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#a8b98b96b74c0d751357612989490ebb0">Domain</a> (int parameter_index) const</td></tr>
<tr class="separator:a8b98b96b74c0d751357612989490ebb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49026c63f638b1da01536622c6afc1bf"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#a49026c63f638b1da01536622c6afc1bf">Evaluate</a> (const double *parameters, double *values, double **jacobian)=0</td></tr>
<tr class="separator:a49026c63f638b1da01536622c6afc1bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a430ebc027c6d2e7c313844092de819c7"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#a430ebc027c6d2e7c313844092de819c7">EvaluateHessian</a> (const double *parameters, double *value, double *gradient, double **hessian)</td></tr>
<tr class="separator:a430ebc027c6d2e7c313844092de819c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a3f628b395c6c4d88d521e8751cc55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#ae9a3f628b395c6c4d88d521e8751cc55">FiniteDomain</a> () const</td></tr>
<tr class="separator:ae9a3f628b395c6c4d88d521e8751cc55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27be468ed93adb95e90e12a051b25cd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#a27be468ed93adb95e90e12a051b25cd4">Periodic</a> (int parameter_index) const</td></tr>
<tr class="separator:a27be468ed93adb95e90e12a051b25cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a39ab8c1ebc601902f5a2ff8a0d21c6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#a39ab8c1ebc601902f5a2ff8a0d21c6e4">m_bPeriodicParameter</a></td></tr>
<tr class="separator:a39ab8c1ebc601902f5a2ff8a0d21c6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7e3d681c06c498b26529affd1d22f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___interval.html">ON_Interval</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#a8e7e3d681c06c498b26529affd1d22f7">m_domain</a></td></tr>
<tr class="separator:a8e7e3d681c06c498b26529affd1d22f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8118ded2762c9e5f38be107e2a5d2d"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#a9d8118ded2762c9e5f38be107e2a5d2d">m_parameter_count</a></td></tr>
<tr class="separator:a9d8118ded2762c9e5f38be107e2a5d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61abf86c2c652d0ab38548f6eba4d482"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___evaluator.html#a61abf86c2c652d0ab38548f6eba4d482">m_value_count</a></td></tr>
<tr class="separator:a61abf86c2c652d0ab38548f6eba4d482"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Description: Abstract function with an arbitrary number of parameters and values. <a class="el" href="class_o_n___evaluator.html">ON_Evaluator</a> is used to pass functions to local solvers. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ade46238934de49cb6a91870f707381a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade46238934de49cb6a91870f707381a9">&#9670;&nbsp;</a></span>ON_Evaluator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_Evaluator::ON_Evaluator </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parameter_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>domain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>periodic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Construction of the class for a function that takes parameter_count input functions and returns value_count values. If the domain is infinite, pass a nullptr for the domain[] and periodic[] arrays. If the domain is finite, pass a domain[] array with parameter_count increasing intervals. If one or more of the parameters is periodic, pass the fundamental domain in the domain[] array and a true in the periodic[] array. Parameters: parameter_count - [in] &gt;= 1. Number of input parameters value_count - [in] &gt;= 1. Number of output values. domain - [in] If not nullptr, then this is an array of parameter_count increasing intervals that defines the domain of the function. periodic - [in] if not nullptr, then this is an array of parameter_count bools where b[i] is true if the i-th parameter is periodic. Valid increasing finite domains must be specificed when this parameter is not nullptr. </p>

</div>
</div>
<a id="ae27f0a638112728273fde6156133d463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27f0a638112728273fde6156133d463">&#9670;&nbsp;</a></span>~ON_Evaluator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ON_Evaluator::~ON_Evaluator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8b98b96b74c0d751357612989490ebb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b98b96b74c0d751357612989490ebb0">&#9670;&nbsp;</a></span>Domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___interval.html">ON_Interval</a> ON_Evaluator::Domain </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parameter_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: The domain of the parameter. If the domain is infinite, the (-1.0e300, +1.0e300) is returned. </p>

</div>
</div>
<a id="a49026c63f638b1da01536622c6afc1bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49026c63f638b1da01536622c6afc1bf">&#9670;&nbsp;</a></span>Evaluate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ON_Evaluator::Evaluate </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>jacobian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Evaluate the function that takes m_parameter_count parameters and returns a m_value_count dimensional point. Parameters: parameters - [in] array of m_parameter_count evaluation parameters values - [out] array of m_value_count function values jacobian - [out] If nullptr, simply evaluate the value of the function. If not nullptr, this is the jacobian of the function. jacobian[i][j] = j-th partial of the i-th value 0 &lt;= i &lt; m_value_count, 0 &lt;= j &lt; m_parameter_count If not nullptr, then all the memory for the jacobian is allocated, you just need to fill in the answers. Example: If f(u,v) = square of the distance from a fixed point P to a surface evaluated at (u,v), then </p><pre class="fragment">  values[0] = (S-P)o(S-P)
  jacobian[0] = ( 2*(Du o (S-P)), 2*(Dv o (S-P)) )
</pre><p>where S, Du, Dv = surface point and first partials evaluated at u=parameters[0], v = parameters[1].</p>
<p>If the function takes 3 parameters, say (x,y,z), and returns two values, say f(x,y,z) and g(z,y,z), then </p><pre class="fragment">  values[0] = f(x,y,z)
  values[1] = g(x,y,z)

  jacobian[0] = (DfDx, DfDy, DfDz)
  jacobian[1] = (DgDx, DgDy, DgDz)
</pre><p>where dfx denotes the first partial of f with respect to x.</p>
<p>Returns: 0 = unable to evaluate 1 = successful evaluation 2 = found answer, terminate search </p>

</div>
</div>
<a id="a430ebc027c6d2e7c313844092de819c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a430ebc027c6d2e7c313844092de819c7">&#9670;&nbsp;</a></span>EvaluateHessian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ON_Evaluator::EvaluateHessian </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>gradient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>hessian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: OPTIONAL ability to evaluate the hessian in the case when m_value_count is one. If your function has more that one value or it is not feasable to evaluate the hessian, then do not override this function. The default implementation returns -1. Parameters: parameters - [in] array of m_parameter_count evaluation parameters value - [out] value of the function (one double) gradient - [out] The gradient of the function. This is a vector of length m_parameter_count; gradient[i] is the first partial of the function with respect to the i-th parameter. hessian - [out] The hessian of the function. This is an m_parameter_count x m_parameter_count symmetric matrix: hessian[i][j] is the second partial of the function with respect to the i-th and j-th parameters. The evaluator is responsible for filling in both the upper and lower triangles. Since the matrix is symmetrix, you should do something like evaluate the upper triangle and copy the values to the lower tiangle. Returns: -1 = Hessian evaluation not available. 0 = unable to evaluate 1 = successful evaluation 2 = found answer, terminate search </p>

</div>
</div>
<a id="ae9a3f628b395c6c4d88d521e8751cc55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a3f628b395c6c4d88d521e8751cc55">&#9670;&nbsp;</a></span>FiniteDomain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Evaluator::FiniteDomain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Functions can have finite or infinite domains. Finite domains are specified by passing the domain[] array to the constructor or filling in the m_domain[] member variable. If m_domain.Count() == m_parameter_count &gt; 0, then the function has finite domains. Returns: True if the domain of the function is finite. </p>

</div>
</div>
<a id="a27be468ed93adb95e90e12a051b25cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27be468ed93adb95e90e12a051b25cd4">&#9670;&nbsp;</a></span>Periodic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Evaluator::Periodic </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parameter_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If a function has a periodic parameter, then the m_domain interval for that parameter is the fundamental domain and the m_bPeriodicParameter bool for that parameter is true. A parameter is periodic if, and only if, m_domain.Count() == m_parameter_count, and m_bPeriodicParameter.Count() == m_parameter_count, and m_bPeriodicParameter[parameter_index] is true. Returns: True if the function parameter is periodic. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a39ab8c1ebc601902f5a2ff8a0d21c6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ab8c1ebc601902f5a2ff8a0d21c6e4">&#9670;&nbsp;</a></span>m_bPeriodicParameter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;bool&gt; ON_Evaluator::m_bPeriodicParameter</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the function has periodic parameters, then m_bPeriodicParameter[] is an array of m_parameter_count bools. If m_bPeriodicParameter[i] is true, then the i-th parameter is periodic and m_domain[i] is the fundamental domain for that parameter. </p>

</div>
</div>
<a id="a8e7e3d681c06c498b26529affd1d22f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7e3d681c06c498b26529affd1d22f7">&#9670;&nbsp;</a></span>m_domain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;<a class="el" href="class_o_n___interval.html">ON_Interval</a>&gt; ON_Evaluator::m_domain</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the function has a finite domain or periodic parameters, then m_domain[] is an array of m_parameter_count finite increasing intervals. </p>

</div>
</div>
<a id="a9d8118ded2762c9e5f38be107e2a5d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8118ded2762c9e5f38be107e2a5d2d">&#9670;&nbsp;</a></span>m_parameter_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ON_Evaluator::m_parameter_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of the function's input parameters. This number is &gt;= 1 and is specified in the constructor. </p>

</div>
</div>
<a id="a61abf86c2c652d0ab38548f6eba4d482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61abf86c2c652d0ab38548f6eba4d482">&#9670;&nbsp;</a></span>m_value_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ON_Evaluator::m_value_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of the function's output values. This number is &gt;= 1 and is specified in the constructor. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 10 2022 21:11:17 for Rhino C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
