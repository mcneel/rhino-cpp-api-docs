<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_FixedSizePool Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API
   &#160;<span id="projectnumber">7.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_o_n___fixed_size_pool-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_FixedSizePool Class Reference<div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_fsp.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ON_FixedSizePool:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_n___fixed_size_pool.png" usemap="#ON_5FFixedSizePool_map" alt=""/>
  <map id="ON_5FFixedSizePool_map" name="ON_5FFixedSizePool_map">
<area href="class_o_n___internal___font_glyph_pool.html" alt="ON_Internal_FontGlyphPool" shape="rect" coords="0,56,186,80"/>
<area href="class_o_n___mesh_x_point_pool.html" alt="ON_MeshXPointPool" shape="rect" coords="196,56,382,80"/>
<area href="class_o_n___simple_fixed_size_pool.html" alt="ON_SimpleFixedSizePool&lt; T &gt;" shape="rect" coords="392,56,578,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad17cc7144c361db18aef3f55f0e19635"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#ad17cc7144c361db18aef3f55f0e19635">ON_FixedSizePool</a> ()</td></tr>
<tr class="separator:ad17cc7144c361db18aef3f55f0e19635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c014d7b1389567913271d943fbd0b40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a8c014d7b1389567913271d943fbd0b40">~ON_FixedSizePool</a> ()</td></tr>
<tr class="separator:a8c014d7b1389567913271d943fbd0b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72118f85b7cf24b221263e1ad3fd8b8b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a72118f85b7cf24b221263e1ad3fd8b8b">ActiveElementCount</a> () const</td></tr>
<tr class="separator:a72118f85b7cf24b221263e1ad3fd8b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57e19b6da55db8fe63a3e526c901bba9"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a57e19b6da55db8fe63a3e526c901bba9">AllocateDirtyElement</a> ()</td></tr>
<tr class="separator:a57e19b6da55db8fe63a3e526c901bba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a500f50edb2b7efff4655f4ea9c264fa2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement</a> ()</td></tr>
<tr class="separator:a500f50edb2b7efff4655f4ea9c264fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0904463b277ba449081d8b2929c8ef26"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a0904463b277ba449081d8b2929c8ef26">Create</a> (size_t sizeof_element, size_t element_count_estimate, size_t block_element_capacity)</td></tr>
<tr class="separator:a0904463b277ba449081d8b2929c8ef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373f8bb4eda7fe5abfb08875a87ac00a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a373f8bb4eda7fe5abfb08875a87ac00a">Destroy</a> ()</td></tr>
<tr class="separator:a373f8bb4eda7fe5abfb08875a87ac00a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23bc8f7379187a60621be143ba59c61"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#ab23bc8f7379187a60621be143ba59c61">Element</a> (size_t element_index) const</td></tr>
<tr class="separator:ab23bc8f7379187a60621be143ba59c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9deb1bdc66640e2a95b19f51af9bed49"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a9deb1bdc66640e2a95b19f51af9bed49">ElementFromId</a> (size_t id_offset, unsigned int id) const</td></tr>
<tr class="separator:a9deb1bdc66640e2a95b19f51af9bed49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0b24aa36896b81b056c8432884933a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a6f0b24aa36896b81b056c8432884933a">ElementIdIsIncreasing</a> (size_t id_offset) const</td></tr>
<tr class="separator:a6f0b24aa36896b81b056c8432884933a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d7012aaeddd359d200ae9fcee404c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a37d7012aaeddd359d200ae9fcee404c8">ElementIndex</a> (const void *element_pointer) const</td></tr>
<tr class="separator:a37d7012aaeddd359d200ae9fcee404c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84143b885fb1b9afe66b8012d6746b66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a84143b885fb1b9afe66b8012d6746b66">IsValid</a> () const</td></tr>
<tr class="memdesc:a84143b885fb1b9afe66b8012d6746b66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Primarily used for debugging.  <a href="class_o_n___fixed_size_pool.html#a84143b885fb1b9afe66b8012d6746b66">More...</a><br /></td></tr>
<tr class="separator:a84143b885fb1b9afe66b8012d6746b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f4e7a07701cbc1409fedf4fb7639b5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#ac8f4e7a07701cbc1409fedf4fb7639b5">MaximumElementId</a> (size_t id_offset) const</td></tr>
<tr class="separator:ac8f4e7a07701cbc1409fedf4fb7639b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24685447c190fc08efe7222ab9df918"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#ab24685447c190fc08efe7222ab9df918">ResetElementId</a> (size_t id_offset, unsigned int initial_id)</td></tr>
<tr class="separator:ab24685447c190fc08efe7222ab9df918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b965fdd3105a9c6d05cce330634c84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a96b965fdd3105a9c6d05cce330634c84">ReturnAll</a> ()</td></tr>
<tr class="separator:a96b965fdd3105a9c6d05cce330634c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5cb208942ebb038e9cce4bfdadbbc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement</a> (void *p)</td></tr>
<tr class="separator:a3b5cb208942ebb038e9cce4bfdadbbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a3eca1cfbd2272826d1a69610fdd77"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement</a> () const</td></tr>
<tr class="separator:a08a3eca1cfbd2272826d1a69610fdd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ee65c3cbce4750d08b6a9d4f1aea62e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a3ee65c3cbce4750d08b6a9d4f1aea62e">ThreadSafeAllocateDirtyElement</a> ()</td></tr>
<tr class="separator:a3ee65c3cbce4750d08b6a9d4f1aea62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0190b0638d3671d07a8d2c095cba19"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#abb0190b0638d3671d07a8d2c095cba19">ThreadSafeAllocateElement</a> ()</td></tr>
<tr class="separator:abb0190b0638d3671d07a8d2c095cba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e575c66db37a657aea0b21de38c1797"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a6e575c66db37a657aea0b21de38c1797">ThreadSafeReturnElement</a> (void *p)</td></tr>
<tr class="separator:a6e575c66db37a657aea0b21de38c1797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a9799631f05f0ec3b239ba44934335"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#aa9a9799631f05f0ec3b239ba44934335">TotalElementCount</a> () const</td></tr>
<tr class="separator:aa9a9799631f05f0ec3b239ba44934335"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6b3a440f8ac861a8d7731be18603eb84"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a6b3a440f8ac861a8d7731be18603eb84">ON_FixedSizePoolIterator</a></td></tr>
<tr class="separator:a6b3a440f8ac861a8d7731be18603eb84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d68ad8584ea472af56286e7450911b1"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool.html#a3d68ad8584ea472af56286e7450911b1">ON_SleepLockGuard</a></td></tr>
<tr class="separator:a3d68ad8584ea472af56286e7450911b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad17cc7144c361db18aef3f55f0e19635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17cc7144c361db18aef3f55f0e19635">&#9670;&nbsp;</a></span>ON_FixedSizePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_FixedSizePool::ON_FixedSizePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c014d7b1389567913271d943fbd0b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c014d7b1389567913271d943fbd0b40">&#9670;&nbsp;</a></span>~ON_FixedSizePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_FixedSizePool::~ON_FixedSizePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a72118f85b7cf24b221263e1ad3fd8b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72118f85b7cf24b221263e1ad3fd8b8b">&#9670;&nbsp;</a></span>ActiveElementCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_FixedSizePool::ActiveElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Number of active elements. (Elements that have been returned are not active.) </p>

</div>
</div>
<a id="a57e19b6da55db8fe63a3e526c901bba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57e19b6da55db8fe63a3e526c901bba9">&#9670;&nbsp;</a></span>AllocateDirtyElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::AllocateDirtyElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: A pointer to sizeof_element bytes. The values in the returned block are undefined. Remarks: If multiple threads are using this pool, then use <a class="el" href="class_o_n___fixed_size_pool.html#a3ee65c3cbce4750d08b6a9d4f1aea62e">ThreadSafeAllocateDirtyElement()</a>. </p>

</div>
</div>
<a id="a500f50edb2b7efff4655f4ea9c264fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a500f50edb2b7efff4655f4ea9c264fa2">&#9670;&nbsp;</a></span>AllocateElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::AllocateElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: A pointer to sizeof_element bytes. The memory is zeroed. Remarks: If multiple threads are using this pool, then use <a class="el" href="class_o_n___fixed_size_pool.html#abb0190b0638d3671d07a8d2c095cba19">ThreadSafeAllocateElement()</a>. </p>

</div>
</div>
<a id="a0904463b277ba449081d8b2929c8ef26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0904463b277ba449081d8b2929c8ef26">&#9670;&nbsp;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_FixedSizePool::Create </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sizeof_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_count_estimate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>block_element_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Create a fixed size memory pool. Parameters: sizeof_element - [in] number of bytes in each element. This parameter must be greater than zero. In general, use sizeof(element type). If you pass a "raw" number as sizeof_element, then be certain that it is the right size to insure the fields in your elements will be properly aligned. element_count_estimate - [in] (0 = good default) If you know how many elements you will need, pass that number here. It is better to slightly overestimate than to slightly underestimate. If you do not have a good estimate, then use zero. block_element_capacity - [in] (0 = good default) If block_element_capacity is zero, <a class="el" href="class_o_n___fixed_size_pool.html#a0904463b277ba449081d8b2929c8ef26">Create()</a> will calculate a block size that is efficent for most applications. If you are an expert user and want to specify the number of elements per block, then pass the number of elements per block here. When block_element_capacity &gt; 0 and element_count_estimate &gt; 0, the first block will have a capacity of at least element_count_estimate; in this case do not ask for extraordinarly large amounts of contiguous heap. Remarks: You must call <a class="el" href="class_o_n___fixed_size_pool.html#a0904463b277ba449081d8b2929c8ef26">Create()</a> on an unused <a class="el" href="class_o_n___fixed_size_pool.html">ON_FixedSizePool</a> or call <a class="el" href="class_o_n___fixed_size_pool.html#a373f8bb4eda7fe5abfb08875a87ac00a">Destroy()</a> before calling create. Returns: True if successful and the pool can be used. </p>

</div>
</div>
<a id="a373f8bb4eda7fe5abfb08875a87ac00a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373f8bb4eda7fe5abfb08875a87ac00a">&#9670;&nbsp;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_FixedSizePool::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Destroy the pool and free all the heap. The pool cannot be used again until <a class="el" href="class_o_n___fixed_size_pool.html#a0904463b277ba449081d8b2929c8ef26">Create()</a> is called. </p>

</div>
</div>
<a id="ab23bc8f7379187a60621be143ba59c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab23bc8f7379187a60621be143ba59c61">&#9670;&nbsp;</a></span>Element()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::Element </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the i-th elment in the fixed size pool. Parameters: element_index - [in] Returns: A pointer to the element with the specified index. <br  />
 The first element has element_index = 0 and is the element returned by the first call to <a class="el" href="class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a>. The last element has element_index = ElementCount()-1. If element_index is out of range, nullptr is returned. Remarks: It is faster to use <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a0d52d7d6fc5290d8a9266bab85d3b88c">ON_FixedSizePoolIterator.FirstElement()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a502e802f6f5dd70c8f868dffd3111fcc">ON_FixedSizePoolIterator.NextElement()</a> to iterate through the entire list of elements. This function is relatively efficient when there are a few large blocks in the pool or element_index is small compared to the number of elements in the first few blocks.</p>
<p>If <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a> is not used or no <a class="el" href="class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a> calls are made after any use of <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a>, then the i-th element is the one returned by the (i+1)-th call to <a class="el" href="class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a> </p>

</div>
</div>
<a id="a9deb1bdc66640e2a95b19f51af9bed49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9deb1bdc66640e2a95b19f51af9bed49">&#9670;&nbsp;</a></span>ElementFromId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::ElementFromId </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If you are certain that all elements in the pool (active and returned) have an unsigned 32-bit id that is unique and increasing, then you may use this function to find them. Parameters: id_offset - [in] offset into the element where the id is stored. id - [in] id to search for </p>

</div>
</div>
<a id="a6f0b24aa36896b81b056c8432884933a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f0b24aa36896b81b056c8432884933a">&#9670;&nbsp;</a></span>ElementIdIsIncreasing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_FixedSizePool::ElementIdIsIncreasing </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id_offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37d7012aaeddd359d200ae9fcee404c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d7012aaeddd359d200ae9fcee404c8">&#9670;&nbsp;</a></span>ElementIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_FixedSizePool::ElementIndex </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>element_pointer</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the fixed size pool index of an element. Parameters: element_pointer - [in] Returns: An index &gt;= 0 and &lt; ON_MAX_SIZE_T if the element_pointer points to an element managed by the this fixed size pool. ON_MAX_SIZE_T otherwise. Remarks: It is faster to use <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a0d52d7d6fc5290d8a9266bab85d3b88c">ON_FixedSizePoolIterator.FirstElement()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a502e802f6f5dd70c8f868dffd3111fcc">ON_FixedSizePoolIterator.NextElement()</a> to iterate through the entire list of elements. This function is relatively efficient when there are a few large blocks in the pool or element_pointer is an element in the first few blocks.</p>
<p>If <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a> is not used or no <a class="el" href="class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a> calls are made after any use of <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a>, then the i-th element is the one returned by the (i+1)-th call to <a class="el" href="class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a>. </p>

</div>
</div>
<a id="a84143b885fb1b9afe66b8012d6746b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84143b885fb1b9afe66b8012d6746b66">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_FixedSizePool::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Primarily used for debugging. </p>

</div>
</div>
<a id="ac8f4e7a07701cbc1409fedf4fb7639b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f4e7a07701cbc1409fedf4fb7639b5">&#9670;&nbsp;</a></span>MaximumElementId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_FixedSizePool::MaximumElementId </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id_offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If you are certain that all elements in the pool (active and returned) have an unsigned 32-bit id that is unique and increasing, then you may use this function to find the maximum assigned id. Parameters: id_offset - [in] offset into the element where the id is stored. Returns: maximum id in all elements (active and returned). </p>

</div>
</div>
<a id="ab24685447c190fc08efe7222ab9df918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24685447c190fc08efe7222ab9df918">&#9670;&nbsp;</a></span>ResetElementId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_FixedSizePool::ResetElementId </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>id_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>initial_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: If successful, (1 + maximum assigned id value) is returned. Otherwise 0 is returned. </p>

</div>
</div>
<a id="a96b965fdd3105a9c6d05cce330634c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b965fdd3105a9c6d05cce330634c84">&#9670;&nbsp;</a></span>ReturnAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_FixedSizePool::ReturnAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Return all allocated elements to the pool. No heap is freed and the pool remains initialized and ready for <a class="el" href="class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a> to be called. </p>

</div>
</div>
<a id="a3b5cb208942ebb038e9cce4bfdadbbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5cb208942ebb038e9cce4bfdadbbc3">&#9670;&nbsp;</a></span>ReturnElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_FixedSizePool::ReturnElement </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Return an element to the pool. Parameters: p - [in] A pointer returned by <a class="el" href="class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a>. It is critical that p be from this pool and that you return a pointer no more than one time. Remarks: If multiple threads are using this pool, then use <a class="el" href="class_o_n___fixed_size_pool.html#a6e575c66db37a657aea0b21de38c1797">ThreadSafeReturnElement()</a>.</p>
<p>If you find the following remarks confusing, but you really want to use <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a>, then here are some simple guidelines. 1) <a class="el" href="class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement()</a> must be &gt;= 16 2) <a class="el" href="class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement()</a> must be a multiple of 8. 3) Do not use FirstElement() and NextElement() to iterate through the pool.</p>
<p>If 1 to 3 don't work for you, then you need to understand the following information before using <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a>.</p>
<p>ON_FixedMemoryPool uses the first sizeof(void*) bytes of the returned element for bookkeeping purposes. Therefore, if you are going to use <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a>, then <a class="el" href="class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement()</a> must be at least sizeof(void*). If you are using a platform that requires pointers to be aligned on sizeof(void*) boundaries, then <a class="el" href="class_o_n___fixed_size_pool.html#a08a3eca1cfbd2272826d1a69610fdd77">SizeofElement()</a> must be a multiple of sizeof(void*). If you are going to use <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a> and then use FirstElement() and NextElement() to iterate through the list of elements, then you need to set a value in the returned element to indicate that it needs to be skipped during the iteration. This value cannot be located in the fist sizeof(void*) bytes of the element. If the element is a class with a vtable, you cannot call a virtual function on a returned element because the vtable pointer is trashed when <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a> modifies the fist sizeof(void*) bytes. </p>

</div>
</div>
<a id="a08a3eca1cfbd2272826d1a69610fdd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a3eca1cfbd2272826d1a69610fdd77">&#9670;&nbsp;</a></span>SizeofElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_FixedSizePool::SizeofElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Size of the elements in this pool. </p>

</div>
</div>
<a id="a3ee65c3cbce4750d08b6a9d4f1aea62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ee65c3cbce4750d08b6a9d4f1aea62e">&#9670;&nbsp;</a></span>ThreadSafeAllocateDirtyElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::ThreadSafeAllocateDirtyElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Thread safe version of <a class="el" href="class_o_n___fixed_size_pool.html#a57e19b6da55db8fe63a3e526c901bba9">AllocateDirtyElement()</a>. Returns: A pointer to sizeof_element bytes. The values in the returned block are undefined. </p>

</div>
</div>
<a id="abb0190b0638d3671d07a8d2c095cba19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb0190b0638d3671d07a8d2c095cba19">&#9670;&nbsp;</a></span>ThreadSafeAllocateElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* ON_FixedSizePool::ThreadSafeAllocateElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Thread safe version of <a class="el" href="class_o_n___fixed_size_pool.html#a500f50edb2b7efff4655f4ea9c264fa2">AllocateElement()</a>. Returns: A pointer to sizeof_element bytes. The memory is zeroed. </p>

</div>
</div>
<a id="a6e575c66db37a657aea0b21de38c1797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e575c66db37a657aea0b21de38c1797">&#9670;&nbsp;</a></span>ThreadSafeReturnElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_FixedSizePool::ThreadSafeReturnElement </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Thread safe version of <a class="el" href="class_o_n___fixed_size_pool.html#a3b5cb208942ebb038e9cce4bfdadbbc3">ReturnElement()</a>. </p>

</div>
</div>
<a id="aa9a9799631f05f0ec3b239ba44934335"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a9799631f05f0ec3b239ba44934335">&#9670;&nbsp;</a></span>TotalElementCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_FixedSizePool::TotalElementCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Total number of elements = number of active elements + number of returned elements. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a6b3a440f8ac861a8d7731be18603eb84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b3a440f8ac861a8d7731be18603eb84">&#9670;&nbsp;</a></span>ON_FixedSizePoolIterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_o_n___fixed_size_pool_iterator.html">ON_FixedSizePoolIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d68ad8584ea472af56286e7450911b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d68ad8584ea472af56286e7450911b1">&#9670;&nbsp;</a></span>ON_SleepLockGuard</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_o_n___sleep_lock_guard.html">ON_SleepLockGuard</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used by The ThreadSafe...() functions and for expert users to use when managing memory controlled by this pool. Best to ingnore this unless you have a very clear idea of what you are doing, why you are doing it, and when you are doing it. Otherwise, you'll find yourself waiting forever on a nested access request. <br  />
 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Aug 31 2020 17:55:53 for Rhino C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
