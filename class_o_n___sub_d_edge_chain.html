<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_SubDEdgeChain Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API
   &#160;<span id="projectnumber">7.17</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_o_n___sub_d_edge_chain-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_SubDEdgeChain Class Reference<div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_subd.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8e8e07073b219d821658c47b5906fe7d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a8e8e07073b219d821658c47b5906fe7d">ON_SubDEdgeChain</a> ()=default</td></tr>
<tr class="separator:a8e8e07073b219d821658c47b5906fe7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40c88554b00e8d579df361532fbcffd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#af40c88554b00e8d579df361532fbcffd">ON_SubDEdgeChain</a> (const <a class="el" href="class_o_n___sub_d_edge_chain.html">ON_SubDEdgeChain</a> &amp;)=default</td></tr>
<tr class="separator:af40c88554b00e8d579df361532fbcffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca8dcb7652597a177dd78e91466ec3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#afca8dcb7652597a177dd78e91466ec3b">~ON_SubDEdgeChain</a> ()=default</td></tr>
<tr class="separator:afca8dcb7652597a177dd78e91466ec3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0668d14f26f95832327f5ea73744bfd7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a0668d14f26f95832327f5ea73744bfd7">AddAllNeighbors</a> (<a class="el" href="group__open_n_u_r_b_s.html#gae8a05bed50b6494cabcc8115689037ee">ON_ChainDirection</a> direction, <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a> chain_type)</td></tr>
<tr class="separator:a0668d14f26f95832327f5ea73744bfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf08f911e015863870aecb6aab15196a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#aaf08f911e015863870aecb6aab15196a">AddEdge</a> (const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge)</td></tr>
<tr class="separator:aaf08f911e015863870aecb6aab15196a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae177d72c642d3bd42d04688da8d3ce63"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ae177d72c642d3bd42d04688da8d3ce63">AddOneNeighbor</a> (<a class="el" href="group__open_n_u_r_b_s.html#gae8a05bed50b6494cabcc8115689037ee">ON_ChainDirection</a> direction, <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a> chain_type)</td></tr>
<tr class="separator:ae177d72c642d3bd42d04688da8d3ce63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba5930838a1b7b1b44e9793f422bd46"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#afba5930838a1b7b1b44e9793f422bd46">BeginEdgeChain</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> persistent_subd_id, <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a> subd_ref, const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;initial_edge_chain)</td></tr>
<tr class="separator:afba5930838a1b7b1b44e9793f422bd46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac588a5750765a0168e180321c0b44296"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ac588a5750765a0168e180321c0b44296">BeginEdgeChain</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> persistent_subd_id, <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a> subd_ref, const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;initial_edge_chain)</td></tr>
<tr class="separator:ac588a5750765a0168e180321c0b44296"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac693c7865b30dd63742022d8e17ab19a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ac693c7865b30dd63742022d8e17ab19a">BeginEdgeChain</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> persistent_subd_id, <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a> subd_ref, const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *const *initial_edge_chain, size_t edge_count)</td></tr>
<tr class="separator:ac693c7865b30dd63742022d8e17ab19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6285a725ec295112ac893df44abab04"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ac6285a725ec295112ac893df44abab04">BeginEdgeChain</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> persistent_subd_id, <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a> subd_ref, const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *initial_edge)</td></tr>
<tr class="separator:ac6285a725ec295112ac893df44abab04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4733da2815fe5c3e9ebd59c1ac11559"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ac4733da2815fe5c3e9ebd59c1ac11559">BeginEdgeChain</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> persistent_subd_id, <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a> subd_ref, const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *initial_edge_chain, size_t edge_count)</td></tr>
<tr class="separator:ac4733da2815fe5c3e9ebd59c1ac11559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a7c2d6b50224cdfcd0a57aa84a46b5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a05a7c2d6b50224cdfcd0a57aa84a46b5">BeginEdgeChain</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> persistent_subd_id, <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a> subd_ref, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> initial_edge)</td></tr>
<tr class="separator:a05a7c2d6b50224cdfcd0a57aa84a46b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c2de8c3fe9f7ef324f2f6b18eb9300"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ab1c2de8c3fe9f7ef324f2f6b18eb9300">ClearEdgeChain</a> ()</td></tr>
<tr class="separator:ab1c2de8c3fe9f7ef324f2f6b18eb9300"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a8d85305cc2a94e2a0ebc27e49d5455"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a0a8d85305cc2a94e2a0ebc27e49d5455">ControlNetPoint</a> (int vertex_index) const</td></tr>
<tr class="separator:a0a8d85305cc2a94e2a0ebc27e49d5455"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333a9d6f48f25cffa9445001462dbb5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a333a9d6f48f25cffa9445001462dbb5d">Dump</a> (class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;text_log) const</td></tr>
<tr class="separator:a333a9d6f48f25cffa9445001462dbb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab42aac9196f461c322b05d101086d984"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ab42aac9196f461c322b05d101086d984">Edge</a> (int edge_index) const</td></tr>
<tr class="separator:ab42aac9196f461c322b05d101086d984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2406d16d0e9c452092b75e307446546"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#af2406d16d0e9c452092b75e307446546">EdgeChain</a> () const</td></tr>
<tr class="separator:af2406d16d0e9c452092b75e307446546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3ca83fea44cca0cee682383a3166351"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ad3ca83fea44cca0cee682383a3166351">EdgeCount</a> () const</td></tr>
<tr class="separator:ad3ca83fea44cca0cee682383a3166351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb77f2a480a7df4228eeaf7553a79e63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#aeb77f2a480a7df4228eeaf7553a79e63">EdgePtr</a> (int edge_index) const</td></tr>
<tr class="separator:aeb77f2a480a7df4228eeaf7553a79e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af82a40c8607dca4825696d1102335a0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#af82a40c8607dca4825696d1102335a0d">EdgeSurfaceCurve</a> (<a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination) const</td></tr>
<tr class="separator:af82a40c8607dca4825696d1102335a0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d2de8a50488a6afea11ba80910f519"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a88d2de8a50488a6afea11ba80910f519">FirstControlNetPoint</a> () const</td></tr>
<tr class="separator:a88d2de8a50488a6afea11ba80910f519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af649dcc16965ba69f2faf1a0c733602f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#af649dcc16965ba69f2faf1a0c733602f">FirstEdge</a> () const</td></tr>
<tr class="separator:af649dcc16965ba69f2faf1a0c733602f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb91cfec312ee9698bfac66870c95c24"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#abb91cfec312ee9698bfac66870c95c24">FirstEdgePtr</a> () const</td></tr>
<tr class="separator:abb91cfec312ee9698bfac66870c95c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28ee2f8b539599a600e67fd26cf04a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ab28ee2f8b539599a600e67fd26cf04a4">FirstVertex</a> () const</td></tr>
<tr class="separator:ab28ee2f8b539599a600e67fd26cf04a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9d92f49230dd59030757471331e63ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ae9d92f49230dd59030757471331e63ef">GetSideComponents</a> (unsigned relative_side, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;side_components) const</td></tr>
<tr class="separator:ae9d92f49230dd59030757471331e63ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57112c89a72130fd8a733c269c7e9e42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a57112c89a72130fd8a733c269c7e9e42">Hash</a> () const</td></tr>
<tr class="separator:a57112c89a72130fd8a733c269c7e9e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a649bf0dad810dab70e4f20c79b334"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a72a649bf0dad810dab70e4f20c79b334">HasPersistentEdgeIds</a> () const</td></tr>
<tr class="separator:a72a649bf0dad810dab70e4f20c79b334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d92a58421095cf253c46c7bfe7954d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ae7d92a58421095cf253c46c7bfe7954d">HasRuntimeEdgePtrs</a> () const</td></tr>
<tr class="separator:ae7d92a58421095cf253c46c7bfe7954d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3430e3c4c2a39511d6b24abba21424fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a3430e3c4c2a39511d6b24abba21424fe">InChain</a> (const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge) const</td></tr>
<tr class="separator:a3430e3c4c2a39511d6b24abba21424fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70ccc4659161b8af1dfe8d178f8066d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ac70ccc4659161b8af1dfe8d178f8066d">InChain</a> (const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge_ptr) const</td></tr>
<tr class="separator:ac70ccc4659161b8af1dfe8d178f8066d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad342a754c0ef2421acd37a6bb099f896"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ad342a754c0ef2421acd37a6bb099f896">InChain</a> (const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex) const</td></tr>
<tr class="separator:ad342a754c0ef2421acd37a6bb099f896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a69faa259bf3da8b0399b073a9ce69"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a59a69faa259bf3da8b0399b073a9ce69">IsClosedLoop</a> () const</td></tr>
<tr class="separator:a59a69faa259bf3da8b0399b073a9ce69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9162c20b785a4990fdd312aafc37de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#aba9162c20b785a4990fdd312aafc37de">IsConvexLoop</a> (bool bStrictlyConvex) const</td></tr>
<tr class="separator:aba9162c20b785a4990fdd312aafc37de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807eefe593ba3861891ab4900a04a131"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a807eefe593ba3861891ab4900a04a131">LastControlNetPoint</a> () const</td></tr>
<tr class="separator:a807eefe593ba3861891ab4900a04a131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1106e4d59fb916eba6c716ce2c0040"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a5c1106e4d59fb916eba6c716ce2c0040">LastEdge</a> () const</td></tr>
<tr class="separator:a5c1106e4d59fb916eba6c716ce2c0040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8df3180c00de7b84a5a63268aa21fff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#af8df3180c00de7b84a5a63268aa21fff">LastEdgePtr</a> () const</td></tr>
<tr class="separator:af8df3180c00de7b84a5a63268aa21fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e84be4cc8b5ef8db93cf459a1ea775c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a3e84be4cc8b5ef8db93cf459a1ea775c">LastVertex</a> () const</td></tr>
<tr class="separator:a3e84be4cc8b5ef8db93cf459a1ea775c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef63216a46da51e9501c4cc8af99a76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a7ef63216a46da51e9501c4cc8af99a76">LoftCurve</a> (<a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination) const</td></tr>
<tr class="separator:a7ef63216a46da51e9501c4cc8af99a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45811aa1bef01817c4b3d29cd68e8ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_edge_chain.html">ON_SubDEdgeChain</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#af45811aa1bef01817c4b3d29cd68e8ba">operator=</a> (const <a class="el" href="class_o_n___sub_d_edge_chain.html">ON_SubDEdgeChain</a> &amp;)=default</td></tr>
<tr class="separator:af45811aa1bef01817c4b3d29cd68e8ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8cc041297a5d7661da804173126811"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a9f8cc041297a5d7661da804173126811">PersistentSubDId</a> () const</td></tr>
<tr class="separator:a9f8cc041297a5d7661da804173126811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59585b4b92db93b686828f7d9d276b4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a59585b4b92db93b686828f7d9d276b4b">Read</a> (class <a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;archive)</td></tr>
<tr class="separator:a59585b4b92db93b686828f7d9d276b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51505560fcb9a3f88c7cfec3862b1a9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#aa51505560fcb9a3f88c7cfec3862b1a9">RemoveEdges</a> (const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *first_edge, const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *last_edge)</td></tr>
<tr class="separator:aa51505560fcb9a3f88c7cfec3862b1a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8c9ab790cdc00f9e7a9e870a2133c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a29f8c9ab790cdc00f9e7a9e870a2133c">Reverse</a> ()</td></tr>
<tr class="separator:a29f8c9ab790cdc00f9e7a9e870a2133c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaa024a9bbda590e5c5d6e1aea674e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#affaa024a9bbda590e5c5d6e1aea674e0">SetPersistentEdgeIdsFromRuntimeEdgePtrs</a> () const</td></tr>
<tr class="separator:affaa024a9bbda590e5c5d6e1aea674e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b5eae91c7dc825b94c54472b1244bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a83b5eae91c7dc825b94c54472b1244bb">SetRuntimeEdgePtrsFromPersistentSubD</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> persistent_subd_id, <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a> persistent_subd_ref)</td></tr>
<tr class="separator:a83b5eae91c7dc825b94c54472b1244bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19f2da0199e8da69b6373ab3f570dd59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a19f2da0199e8da69b6373ab3f570dd59">SetStatusCheck</a> (bool bEnableStatusCheck, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> status_check_pass, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> status_check_fail)</td></tr>
<tr class="separator:a19f2da0199e8da69b6373ab3f570dd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22f598de20e9e88968f6791e7038d303"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a22f598de20e9e88968f6791e7038d303">StatusCheck</a> (const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge) const</td></tr>
<tr class="separator:a22f598de20e9e88968f6791e7038d303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78da4b8ad527ccb6bce64a3d69a274a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a78da4b8ad527ccb6bce64a3d69a274a7">StatusCheckEnabled</a> () const</td></tr>
<tr class="separator:a78da4b8ad527ccb6bce64a3d69a274a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab36228fb89c9333983a8374213a9602e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ab36228fb89c9333983a8374213a9602e">StatusCheckFail</a> () const</td></tr>
<tr class="separator:ab36228fb89c9333983a8374213a9602e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30bd2c621c580279e782459ca66fd404"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a30bd2c621c580279e782459ca66fd404">StatusCheckPass</a> () const</td></tr>
<tr class="separator:a30bd2c621c580279e782459ca66fd404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35506a147807a9303e95bbf179bf28e2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a35506a147807a9303e95bbf179bf28e2">SubD</a> () const</td></tr>
<tr class="separator:a35506a147807a9303e95bbf179bf28e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02eb20d56020cbe51c4d348eacfdf38d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a02eb20d56020cbe51c4d348eacfdf38d">SubDRef</a> () const</td></tr>
<tr class="separator:a02eb20d56020cbe51c4d348eacfdf38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80ca6ab21eb6a70f51305532935b6b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#aa80ca6ab21eb6a70f51305532935b6b4">Vertex</a> (int vertex_index) const</td></tr>
<tr class="separator:aa80ca6ab21eb6a70f51305532935b6b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02a56e9763d0c9e31322c32b98b337df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a02a56e9763d0c9e31322c32b98b337df">Write</a> (class <a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;archive) const</td></tr>
<tr class="separator:a02a56e9763d0c9e31322c32b98b337df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4e965c0ef25223b829c7ba096543209d"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a4e965c0ef25223b829c7ba096543209d">EdgeChainNeighbor</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> starting_edge, <a class="el" href="group__open_n_u_r_b_s.html#gae8a05bed50b6494cabcc8115689037ee">ON_ChainDirection</a> search_direction, <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a> chain_type)</td></tr>
<tr class="separator:a4e965c0ef25223b829c7ba096543209d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1341c05773f972c78dec9d819942c0bd"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a1341c05773f972c78dec9d819942c0bd">EdgeChainNeighbor</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> starting_edge, <a class="el" href="group__open_n_u_r_b_s.html#gae8a05bed50b6494cabcc8115689037ee">ON_ChainDirection</a> search_direction, <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a> chain_type, bool bEnableStatusCheck, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> status_pass, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> status_fail)</td></tr>
<tr class="separator:a1341c05773f972c78dec9d819942c0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41a41c49324d540108d34418797082fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a41a41c49324d540108d34418797082fe">GetEdgeSurfaceCurve</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chain, unsigned int *converted_count, <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination)</td></tr>
<tr class="separator:a41a41c49324d540108d34418797082fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced98579d226f7be6c83cb6504c41ca0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#aced98579d226f7be6c83cb6504c41ca0">GetEdgeSurfaceCurve</a> (const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edge_chain, size_t edge_count, unsigned int *converted_count, <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination)</td></tr>
<tr class="separator:aced98579d226f7be6c83cb6504c41ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457379a19a0cced55b1e232eee3cbeae"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a457379a19a0cced55b1e232eee3cbeae">GetLoftCurve</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chain, bool bRequireCreases, <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination)</td></tr>
<tr class="separator:a457379a19a0cced55b1e232eee3cbeae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0714b605e1add99becb61ebbd5db5597"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a0714b605e1add99becb61ebbd5db5597">GetLoftCurve</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chain, <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination)</td></tr>
<tr class="separator:a0714b605e1add99becb61ebbd5db5597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a502e0a47ba936234491e0a2b49c4033e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a502e0a47ba936234491e0a2b49c4033e">GetLoftCurve</a> (const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edge_chain, size_t edge_count, bool bReequireCreases, <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination)</td></tr>
<tr class="separator:a502e0a47ba936234491e0a2b49c4033e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9803c4bef92eac52a24dde4f270c6758"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a9803c4bef92eac52a24dde4f270c6758">GetLoftCurve</a> (const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edge_chain, size_t edge_count, <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination)</td></tr>
<tr class="separator:a9803c4bef92eac52a24dde4f270c6758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6b356b050ce4c879fc1d4c9420b8322"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#af6b356b050ce4c879fc1d4c9420b8322">GetSideComponents</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chain, unsigned relative_side, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;side_components)</td></tr>
<tr class="separator:af6b356b050ce4c879fc1d4c9420b8322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044ace3f873dab5fb86cdb4dab28c5ad"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a044ace3f873dab5fb86cdb4dab28c5ad">IsSingleEdgeChain</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edges)</td></tr>
<tr class="separator:a044ace3f873dab5fb86cdb4dab28c5ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cde9533ab45bb0639b4769789d9f490"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a8cde9533ab45bb0639b4769789d9f490">IsSingleEdgeChain</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edges, bool &amp;bIsClosed, bool &amp;bIsSorted)</td></tr>
<tr class="separator:a8cde9533ab45bb0639b4769789d9f490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534958c8ba19c9e5c8723c54780f9f2b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a534958c8ba19c9e5c8723c54780f9f2b">IsValidEdgeChain</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chain, bool bCheckForDuplicateEdges)</td></tr>
<tr class="separator:a534958c8ba19c9e5c8723c54780f9f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708ccfe1427637408f49714c75a60c55"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a708ccfe1427637408f49714c75a60c55">IsValidEdgeChain</a> (const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edge_chain, size_t edge_count, bool bCheckForDuplicateEdges)</td></tr>
<tr class="separator:a708ccfe1427637408f49714c75a60c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70db5c09302a3091bdcbb4088d0148c"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#af70db5c09302a3091bdcbb4088d0148c">OrientEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chains)</td></tr>
<tr class="separator:af70db5c09302a3091bdcbb4088d0148c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68ec1e622618befce0c7b5894356541b"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a68ec1e622618befce0c7b5894356541b">OrientEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chains)</td></tr>
<tr class="separator:a68ec1e622618befce0c7b5894356541b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0e784a958ca12a15c22b54385b98b95"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ad0e784a958ca12a15c22b54385b98b95">OrientEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chains)</td></tr>
<tr class="separator:ad0e784a958ca12a15c22b54385b98b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3979bfde1863cb244db6cecceb4117d0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a3979bfde1863cb244db6cecceb4117d0">ReverseEdgeChain</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chain)</td></tr>
<tr class="separator:a3979bfde1863cb244db6cecceb4117d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd3023b9680b9ff7e5a7d63a4486d5d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a3dd3023b9680b9ff7e5a7d63a4486d5d">ReverseEdgeChain</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edge_chain, size_t edge_count)</td></tr>
<tr class="separator:a3dd3023b9680b9ff7e5a7d63a4486d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67fef84896d9761bd3afb9f1be0d916f"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a67fef84896d9761bd3afb9f1be0d916f">SortEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;unsorted_edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;sorted_edges)</td></tr>
<tr class="separator:a67fef84896d9761bd3afb9f1be0d916f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26204fe0132f11bd952272589af8fb22"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a26204fe0132f11bd952272589af8fb22">SortEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;unsorted_edges, unsigned int minimum_chain_length, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chains)</td></tr>
<tr class="separator:a26204fe0132f11bd952272589af8fb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e79d3f621b9ed90ca960fb65bfa04ac"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a0e79d3f621b9ed90ca960fb65bfa04ac">SortEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;unsorted_edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;sorted_edges)</td></tr>
<tr class="separator:a0e79d3f621b9ed90ca960fb65bfa04ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d78a1e1918f34a67c1af14108556b0f"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a0d78a1e1918f34a67c1af14108556b0f">SortEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;unsorted_edges, unsigned int minimum_chain_length, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;sorted_edges)</td></tr>
<tr class="separator:a0d78a1e1918f34a67c1af14108556b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bca320eb5ff08ac80ac6f0ca5b52c9b"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a7bca320eb5ff08ac80ac6f0ca5b52c9b">SortEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;unsorted_edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;sorted_edges)</td></tr>
<tr class="separator:a7bca320eb5ff08ac80ac6f0ca5b52c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a148a1b1a56c70e4f206cda4b452507"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a5a148a1b1a56c70e4f206cda4b452507">SortEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;unsorted_edges, unsigned int minimum_chain_length, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chains)</td></tr>
<tr class="separator:a5a148a1b1a56c70e4f206cda4b452507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9301ea4808ceb2bf5c2823bbef44968"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#ae9301ea4808ceb2bf5c2823bbef44968">SortEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;unsorted_edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;sorted_edges)</td></tr>
<tr class="separator:ae9301ea4808ceb2bf5c2823bbef44968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e190f8228109b63c42a39bc413457a2"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a9e190f8228109b63c42a39bc413457a2">SortEdgesIntoEdgeChains</a> (const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;unsorted_edges, unsigned int minimum_chain_length, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chains)</td></tr>
<tr class="separator:a9e190f8228109b63c42a39bc413457a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a032c9a736243d16ecef20d0e2dfd0ae2"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_edge_chain.html">ON_SubDEdgeChain</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge_chain.html#a032c9a736243d16ecef20d0e2dfd0ae2">Empty</a></td></tr>
<tr class="separator:a032c9a736243d16ecef20d0e2dfd0ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8e8e07073b219d821658c47b5906fe7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8e07073b219d821658c47b5906fe7d">&#9670;&nbsp;</a></span>ON_SubDEdgeChain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubDEdgeChain::ON_SubDEdgeChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afca8dcb7652597a177dd78e91466ec3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca8dcb7652597a177dd78e91466ec3b">&#9670;&nbsp;</a></span>~ON_SubDEdgeChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubDEdgeChain::~ON_SubDEdgeChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af40c88554b00e8d579df361532fbcffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40c88554b00e8d579df361532fbcffd">&#9670;&nbsp;</a></span>ON_SubDEdgeChain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubDEdgeChain::ON_SubDEdgeChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge_chain.html">ON_SubDEdgeChain</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0668d14f26f95832327f5ea73744bfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0668d14f26f95832327f5ea73744bfd7">&#9670;&nbsp;</a></span>AddAllNeighbors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::AddAllNeighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gae8a05bed50b6494cabcc8115689037ee">ON_ChainDirection</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a>&#160;</td>
          <td class="paramname"><em>chain_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf08f911e015863870aecb6aab15196a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf08f911e015863870aecb6aab15196a">&#9670;&nbsp;</a></span>AddEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::AddEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae177d72c642d3bd42d04688da8d3ce63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae177d72c642d3bd42d04688da8d3ce63">&#9670;&nbsp;</a></span>AddOneNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::AddOneNeighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gae8a05bed50b6494cabcc8115689037ee">ON_ChainDirection</a>&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a>&#160;</td>
          <td class="paramname"><em>chain_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afba5930838a1b7b1b44e9793f422bd46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba5930838a1b7b1b44e9793f422bd46">&#9670;&nbsp;</a></span>BeginEdgeChain() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::BeginEdgeChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>persistent_subd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a>&#160;</td>
          <td class="paramname"><em>subd_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_edge_chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: persistent_subd_id - [in] If this edge chain needs to persist in a 3dm archive, then persistent_subd_id should identify the subd in its current context. If that context is an <a class="el" href="class_o_n_x___model.html">ONX_Model</a>, then the persistent id is the <a class="el" href="class_o_n___model_component.html#a7e4decb826ac79c583526fbc83a96946">ON_ModelGeometryComponent.Id()</a>. If that context is a <a class="el" href="class_c_rhino_doc.html">CRhinoDoc</a>, then the persistent id is <a class="el" href="class_c_rhino_object.html#ae2aa364054dac99424532db9850d0b5b">CRhinoObject.ModelObjectId()</a>. If the edge chain is being used in a runtime context and will not be saved in a 3dm archive or otherwise serialized, then persistent_subd_id can be ON_nil_uuid. </p>

</div>
</div>
<a id="ac588a5750765a0168e180321c0b44296"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac588a5750765a0168e180321c0b44296">&#9670;&nbsp;</a></span>BeginEdgeChain() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::BeginEdgeChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>persistent_subd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a>&#160;</td>
          <td class="paramname"><em>subd_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_edge_chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: persistent_subd_id - [in] If this edge chain needs to persist in a 3dm archive, then persistent_subd_id should identify the subd in its current context. If that context is an <a class="el" href="class_o_n_x___model.html">ONX_Model</a>, then the persistent id is the <a class="el" href="class_o_n___model_component.html#a7e4decb826ac79c583526fbc83a96946">ON_ModelGeometryComponent.Id()</a>. If that context is a <a class="el" href="class_c_rhino_doc.html">CRhinoDoc</a>, then the persistent id is <a class="el" href="class_c_rhino_object.html#ae2aa364054dac99424532db9850d0b5b">CRhinoObject.ModelObjectId()</a>. If the edge chain is being used in a runtime context and will not be saved in a 3dm archive or otherwise serialized, then persistent_subd_id can be ON_nil_uuid. </p>

</div>
</div>
<a id="ac693c7865b30dd63742022d8e17ab19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac693c7865b30dd63742022d8e17ab19a">&#9670;&nbsp;</a></span>BeginEdgeChain() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::BeginEdgeChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>persistent_subd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a>&#160;</td>
          <td class="paramname"><em>subd_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *const *&#160;</td>
          <td class="paramname"><em>initial_edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: persistent_subd_id - [in] If this edge chain needs to persist in a 3dm archive, then persistent_subd_id should identify the subd in its current context. If that context is an <a class="el" href="class_o_n_x___model.html">ONX_Model</a>, then the persistent id is the <a class="el" href="class_o_n___model_component.html#a7e4decb826ac79c583526fbc83a96946">ON_ModelGeometryComponent.Id()</a>. If that context is a <a class="el" href="class_c_rhino_doc.html">CRhinoDoc</a>, then the persistent id is <a class="el" href="class_c_rhino_object.html#ae2aa364054dac99424532db9850d0b5b">CRhinoObject.ModelObjectId()</a>. If the edge chain is being used in a runtime context and will not be saved in a 3dm archive or otherwise serialized, then persistent_subd_id can be ON_nil_uuid. </p>

</div>
</div>
<a id="ac6285a725ec295112ac893df44abab04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6285a725ec295112ac893df44abab04">&#9670;&nbsp;</a></span>BeginEdgeChain() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::BeginEdgeChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>persistent_subd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a>&#160;</td>
          <td class="paramname"><em>subd_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>initial_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: persistent_subd_id - [in] If this edge chain needs to persist in a 3dm archive, then persistent_subd_id should identify the subd in its current context. If that context is an <a class="el" href="class_o_n_x___model.html">ONX_Model</a>, then the persistent id is the <a class="el" href="class_o_n___model_component.html#a7e4decb826ac79c583526fbc83a96946">ON_ModelGeometryComponent.Id()</a>. If that context is a <a class="el" href="class_c_rhino_doc.html">CRhinoDoc</a>, then the persistent id is <a class="el" href="class_c_rhino_object.html#ae2aa364054dac99424532db9850d0b5b">CRhinoObject.ModelObjectId()</a>. If the edge chain is being used in a runtime context and will not be saved in a 3dm archive or otherwise serialized, then persistent_subd_id can be ON_nil_uuid. </p>

</div>
</div>
<a id="ac4733da2815fe5c3e9ebd59c1ac11559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4733da2815fe5c3e9ebd59c1ac11559">&#9670;&nbsp;</a></span>BeginEdgeChain() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::BeginEdgeChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>persistent_subd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a>&#160;</td>
          <td class="paramname"><em>subd_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>initial_edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: persistent_subd_id - [in] If this edge chain needs to persist in a 3dm archive, then persistent_subd_id should identify the subd in its current context. If that context is an <a class="el" href="class_o_n_x___model.html">ONX_Model</a>, then the persistent id is the <a class="el" href="class_o_n___model_component.html#a7e4decb826ac79c583526fbc83a96946">ON_ModelGeometryComponent.Id()</a>. If that context is a <a class="el" href="class_c_rhino_doc.html">CRhinoDoc</a>, then the persistent id is <a class="el" href="class_c_rhino_object.html#ae2aa364054dac99424532db9850d0b5b">CRhinoObject.ModelObjectId()</a>. If the edge chain is being used in a runtime context and will not be saved in a 3dm archive or otherwise serialized, then persistent_subd_id can be ON_nil_uuid. </p>

</div>
</div>
<a id="a05a7c2d6b50224cdfcd0a57aa84a46b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a7c2d6b50224cdfcd0a57aa84a46b5">&#9670;&nbsp;</a></span>BeginEdgeChain() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::BeginEdgeChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>persistent_subd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a>&#160;</td>
          <td class="paramname"><em>subd_ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>initial_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: persistent_subd_id - [in] If this edge chain needs to persist in a 3dm archive, then persistent_subd_id should identify the subd in its current context. If that context is an <a class="el" href="class_o_n_x___model.html">ONX_Model</a>, then the persistent id is the <a class="el" href="class_o_n___model_component.html#a7e4decb826ac79c583526fbc83a96946">ON_ModelGeometryComponent.Id()</a>. If that context is a <a class="el" href="class_c_rhino_doc.html">CRhinoDoc</a>, then the persistent id is <a class="el" href="class_c_rhino_object.html#ae2aa364054dac99424532db9850d0b5b">CRhinoObject.ModelObjectId()</a>. If the edge chain is being used in a runtime context and will not be saved in a 3dm archive or otherwise serialized, then persistent_subd_id can be ON_nil_uuid. </p>

</div>
</div>
<a id="ab1c2de8c3fe9f7ef324f2f6b18eb9300"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c2de8c3fe9f7ef324f2f6b18eb9300">&#9670;&nbsp;</a></span>ClearEdgeChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubDEdgeChain::ClearEdgeChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a8d85305cc2a94e2a0ebc27e49d5455"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a8d85305cc2a94e2a0ebc27e49d5455">&#9670;&nbsp;</a></span>ControlNetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_SubDEdgeChain::ControlNetPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a333a9d6f48f25cffa9445001462dbb5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333a9d6f48f25cffa9445001462dbb5d">&#9670;&nbsp;</a></span>Dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubDEdgeChain::Dump </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;&#160;</td>
          <td class="paramname"><em>text_log</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab42aac9196f461c322b05d101086d984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab42aac9196f461c322b05d101086d984">&#9670;&nbsp;</a></span>Edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubDEdgeChain::Edge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2406d16d0e9c452092b75e307446546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2406d16d0e9c452092b75e307446546">&#9670;&nbsp;</a></span>EdgeChain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&gt;&amp; ON_SubDEdgeChain::EdgeChain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Current EdgeChain </p>

</div>
</div>
<a id="a4e965c0ef25223b829c7ba096543209d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e965c0ef25223b829c7ba096543209d">&#9670;&nbsp;</a></span>EdgeChainNeighbor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubDEdgeChain::EdgeChainNeighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>starting_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gae8a05bed50b6494cabcc8115689037ee">ON_ChainDirection</a>&#160;</td>
          <td class="paramname"><em>search_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a>&#160;</td>
          <td class="paramname"><em>chain_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Edge chain tools Description: Get the neighboring link in an edge chain. Parameters: starting_edge - [in] search_direction - [in] <a class="el" href="group__open_n_u_r_b_s.html#ggae8a05bed50b6494cabcc8115689037eeadd1f775e443ff3b9a89270713580a51b">ON_ChainDirection::Previous</a> or <a class="el" href="group__open_n_u_r_b_s.html#ggae8a05bed50b6494cabcc8115689037eea10ac3d04253ef7e1ddc73e6091c0cd55">ON_ChainDirection::Next</a>. The search direction is relative to this-&gt;EdgeDirection(). chain_type - [in] Determines what edge/vertex tag conditions must be satisified by the neighbor. Returns: The next or previous edge in the chain if it exists. Otherwise, nullptr is returned. Remarks: When multiple edges are candidates, there is a bias to preserve smooth/crease and a bias to preserve face count. If the biases don't reduce the list of candidates to one or bStopAtBreak is true and a creaase/smooth break is encountered, then <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> is returned. </p>

</div>
</div>
<a id="a1341c05773f972c78dec9d819942c0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1341c05773f972c78dec9d819942c0bd">&#9670;&nbsp;</a></span>EdgeChainNeighbor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubDEdgeChain::EdgeChainNeighbor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>starting_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gae8a05bed50b6494cabcc8115689037ee">ON_ChainDirection</a>&#160;</td>
          <td class="paramname"><em>search_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a>&#160;</td>
          <td class="paramname"><em>chain_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableStatusCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>status_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>status_fail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Get the neighboring link in an edge chain. Parameters: starting_edge - [in] search_direction - [in] <a class="el" href="group__open_n_u_r_b_s.html#ggae8a05bed50b6494cabcc8115689037eeadd1f775e443ff3b9a89270713580a51b">ON_ChainDirection::Previous</a> or <a class="el" href="group__open_n_u_r_b_s.html#ggae8a05bed50b6494cabcc8115689037eea10ac3d04253ef7e1ddc73e6091c0cd55">ON_ChainDirection::Next</a>. The search direction is relative to this-&gt;EdgeDirection(). chain_type - [in] Determines what edge/vertex tag conditions must be satisified by the neighbor. bEnableStatusCheck - [in] status_pass - [in] status_fail - [in] If bEnableStatusFilter is false, then no status checks are performed. If bEnableStatusFilter is true, <a class="el" href="class_o_n___component_status.html#acbcda927a40ec78476179874b8626f23">ON_ComponentStatus::StatusCheck</a>(candidate_edge-&gt;m_status,status_pass,status_fail) must be true for candidate_edge to be returned. Returns: The next or previous edge in the chain if it exists. Otherwise, nullptr is returned. Remarks: When multiple edges are candidates, there is a bias to preserve smooth/crease and a bias to preserve face count. If the biases don't reduce the list of candidates to one or bStopAtBreak is true and a creaase/smooth break is encountered, then <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> is returned. </p>

</div>
</div>
<a id="ad3ca83fea44cca0cee682383a3166351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3ca83fea44cca0cee682383a3166351">&#9670;&nbsp;</a></span>EdgeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::EdgeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb77f2a480a7df4228eeaf7553a79e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb77f2a480a7df4228eeaf7553a79e63">&#9670;&nbsp;</a></span>EdgePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubDEdgeChain::EdgePtr </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af82a40c8607dca4825696d1102335a0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af82a40c8607dca4825696d1102335a0d">&#9670;&nbsp;</a></span>EdgeSurfaceCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubDEdgeChain::EdgeSurfaceCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88d2de8a50488a6afea11ba80910f519"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d2de8a50488a6afea11ba80910f519">&#9670;&nbsp;</a></span>FirstControlNetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_SubDEdgeChain::FirstControlNetPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af649dcc16965ba69f2faf1a0c733602f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af649dcc16965ba69f2faf1a0c733602f">&#9670;&nbsp;</a></span>FirstEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubDEdgeChain::FirstEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb91cfec312ee9698bfac66870c95c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb91cfec312ee9698bfac66870c95c24">&#9670;&nbsp;</a></span>FirstEdgePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubDEdgeChain::FirstEdgePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab28ee2f8b539599a600e67fd26cf04a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28ee2f8b539599a600e67fd26cf04a4">&#9670;&nbsp;</a></span>FirstVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubDEdgeChain::FirstVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41a41c49324d540108d34418797082fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41a41c49324d540108d34418797082fe">&#9670;&nbsp;</a></span>GetEdgeSurfaceCurve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubDEdgeChain::GetEdgeSurfaceCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>converted_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: edge_count - [in] edge_chain[] - [in] A chain of contiguous edges. The conversion into a NURBS curve will stop if a link is not contiguous with the previous link. converted_count = [in] If not nullptr, the number of edges converted into the returned curve is returned. ON_NurbsCurve* destination - [in] If not nullptr, the limit curve is created in this instance. Returns: A NURBS curve that lies on the limit surface edges. The domain is (0,edge_count+1) and the subdomain for the i-th edge is (i,i+1). </p>

</div>
</div>
<a id="aced98579d226f7be6c83cb6504c41ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced98579d226f7be6c83cb6504c41ca0">&#9670;&nbsp;</a></span>GetEdgeSurfaceCurve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubDEdgeChain::GetEdgeSurfaceCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>converted_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a457379a19a0cced55b1e232eee3cbeae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457379a19a0cced55b1e232eee3cbeae">&#9670;&nbsp;</a></span>GetLoftCurve() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubDEdgeChain::GetLoftCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRequireCreases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0714b605e1add99becb61ebbd5db5597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0714b605e1add99becb61ebbd5db5597">&#9670;&nbsp;</a></span>GetLoftCurve() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubDEdgeChain::GetLoftCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a502e0a47ba936234491e0a2b49c4033e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a502e0a47ba936234491e0a2b49c4033e">&#9670;&nbsp;</a></span>GetLoftCurve() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubDEdgeChain::GetLoftCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReequireCreases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9803c4bef92eac52a24dde4f270c6758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9803c4bef92eac52a24dde4f270c6758">&#9670;&nbsp;</a></span>GetLoftCurve() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubDEdgeChain::GetLoftCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af6b356b050ce4c879fc1d4c9420b8322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6b356b050ce4c879fc1d4c9420b8322">&#9670;&nbsp;</a></span>GetSideComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubDEdgeChain::GetSideComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>relative_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>side_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See above. </p>

</div>
</div>
<a id="ae9d92f49230dd59030757471331e63ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9d92f49230dd59030757471331e63ef">&#9670;&nbsp;</a></span>GetSideComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::GetSideComponents </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>relative_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>side_components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the edges and faces on a specified side of the edge chain. Parameters: relative_side - [in] 0: Get edges and faces on the ON_SubDEdgePtr::RelativeFace(0) side (left). 1: Get edges and faces on the ON_SubDEdgePtr::RelativeFace(1) side (right).</p>
<p>side_components - [out] side_components[] is a sequence of made of vertices, edges, and faces that record the edges and faces that are on the specified side of the edge chain.</p>
<p>When a vertex is in side_components[], <a class="el" href="class_o_n___sub_d_component_ptr.html#ab835a753572b9cd136a93e165e30e9c1">ON_SubDComponentPtr.Vertex()</a> is not nullptr and the vertex is between two conscutive edges in the edge chain.</p>
<p>When an edge is in side_components[], <a class="el" href="class_o_n___sub_d_component_ptr.html#a92612d0b3ed69fc1b591f264d67c92e4">ON_SubDComponentPtr.EdgePtr()</a> is not nullptr, the edge is on the specified side of the edge chain (not in the edge chain), and <a class="el" href="class_o_n___sub_d_component_ptr.html#a92612d0b3ed69fc1b591f264d67c92e4">ON_SubDComponentPtr.EdgePtr()</a>.RelativeVertex(0) is a vertex on the edge chain.</p>
<p>When a face is in side_components[], <a class="el" href="class_o_n___sub_d_component_ptr.html#a2fe02d7ff7da92746f366aa0392db95d">ON_SubDComponentPtr.Face()</a> is not nullptr, then at least one vertex of f is part of the edge chain and f is on the specified side of the edge chain.</p>
<p>If a vertex v is side_components[], then it is preceded and followed by the same face (...f,v,f,...), there are consecutive edges in the edge chain (...e0,e1,...), and e0 and e1 are consecutive edges in f's boundary.</p>
<p>If ...eptr0,f,eptr1,... is in side_components[], v0 = eptr0.RelativeVertex(0), v1 = eptr0.RelativeVertex(0), and v0 == v1, then eptr0 and eptr1 are conecutive edges in the boundary of f and v0==v1 is a vertex in the edge chain.</p>
<p>If ...eptr0,f,eptr1,... is in side_components[], v0 = eptr0.RelativeVertex(0), v1 = eptr0.RelativeVertex(0), and v0 != v1, then there is an edge c from v0 to v1 that is in the edge chain and eptr0,c,eptr1 are conecutive edges in the boundary of f.</p>
<p>If ...eptr0,f,v,... is in side_components[] and v0 = eptr0.RelativeVertex(0), and then v0 != v, then there is an edge c from v0 to v that is in the edge chain, and eptr0,c are conecutive edges in the boundary of f.</p>
<p>If ...v,f,eptr1,... is in side_components[] and v1 = eptr1.RelativeVertex(0), and then v != v1, then there is an edge c from v to v1 that is in the edge chain, and c,eptr1 conecutive edges in the boundary of f.</p>
<p>Remarks: If the SubD is not an oriented manifold along the entire side of the chain, then there may be gaps in chain_side[]. When there are face fans at a chain vertex, there will be faces that do not have an edge on the chain. </p>

</div>
</div>
<a id="a57112c89a72130fd8a733c269c7e9e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57112c89a72130fd8a733c269c7e9e42">&#9670;&nbsp;</a></span>Hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubDEdgeChain::Hash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: A SHA1 hash of the edge and vertex ids. Useful for determining when two edge chains from different subds (one generally a modified copy) involve the same edges and vertices. </p>

</div>
</div>
<a id="a72a649bf0dad810dab70e4f20c79b334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a649bf0dad810dab70e4f20c79b334">&#9670;&nbsp;</a></span>HasPersistentEdgeIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::HasPersistentEdgeIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7d92a58421095cf253c46c7bfe7954d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d92a58421095cf253c46c7bfe7954d">&#9670;&nbsp;</a></span>HasRuntimeEdgePtrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::HasRuntimeEdgePtrs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3430e3c4c2a39511d6b24abba21424fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3430e3c4c2a39511d6b24abba21424fe">&#9670;&nbsp;</a></span>InChain() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::InChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac70ccc4659161b8af1dfe8d178f8066d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70ccc4659161b8af1dfe8d178f8066d">&#9670;&nbsp;</a></span>InChain() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::InChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge_ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad342a754c0ef2421acd37a6bb099f896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad342a754c0ef2421acd37a6bb099f896">&#9670;&nbsp;</a></span>InChain() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::InChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59a69faa259bf3da8b0399b073a9ce69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a69faa259bf3da8b0399b073a9ce69">&#9670;&nbsp;</a></span>IsClosedLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::IsClosedLoop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if the edge chain has 3 or more edges that form a closed loop. </p>

</div>
</div>
<a id="aba9162c20b785a4990fdd312aafc37de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9162c20b785a4990fdd312aafc37de">&#9670;&nbsp;</a></span>IsConvexLoop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::IsConvexLoop </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStrictlyConvex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: bStrictlyConvex - [in] If true, then a colinear pair of edges is not considered convex. Returns: True if the edge chain has 3 or more edges that forma a convex loop. </p>

</div>
</div>
<a id="a044ace3f873dab5fb86cdb4dab28c5ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044ace3f873dab5fb86cdb4dab28c5ad">&#9670;&nbsp;</a></span>IsSingleEdgeChain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubDEdgeChain::IsSingleEdgeChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Determin if the array of ON_SubDEdgePtrs in edges[] can be sorted into a single edge chain. Parameters: edges - [in] Set of edges to test. Returns: If the array of edges[] can be sorted into a single edge chain with no self intersections, then true is returned. Otherwise false is returned. Remarks: This test usesthe MarkBits() values on the edges and vertices and restores the values to the input state. Multiple threads may not simultaneously use any SubD tools on that rely on markbits on the same <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. </p>

</div>
</div>
<a id="a8cde9533ab45bb0639b4769789d9f490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cde9533ab45bb0639b4769789d9f490">&#9670;&nbsp;</a></span>IsSingleEdgeChain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubDEdgeChain::IsSingleEdgeChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>bIsClosed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>bIsSorted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Determin if the array of ON_SubDEdgePtrs in edges[] can be sorted into a single edge chain. Parameters: edges - [in] Set of edges to test. bIsClosed - [out] If true is returned and edges[] sorts into a closed edge chain, then bIsClosed is true. Otherwise bIsClosed is false. bIsSorted - [out] If true is returned and edges[] is currently sorted into an edge chain, then bIsSorted is true. Otherwise bIsSorted is false. Returns: If the array of edges[] can be sorted into a single edge chain with no self intersections, then true is returned. Otherwise false is returned. Remarks: This test usesthe MarkBits() values on the edges and vertices and restores the values to the input state. Multiple threads may not simultaneously use any SubD tools on that rely on markbits on the same <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. </p>

</div>
</div>
<a id="a534958c8ba19c9e5c8723c54780f9f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534958c8ba19c9e5c8723c54780f9f2b">&#9670;&nbsp;</a></span>IsValidEdgeChain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubDEdgeChain::IsValidEdgeChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCheckForDuplicateEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Checks that all edge and vertex pointers are not nullptr and that adjacent edges in the list share the same vertex. Parameters: edge_chain - [in] Edge chain to test bCheckForDuplicateEdges - [in] If bCheckForDuplicateEdges true, then false is returned if there are duplicate edges or duplicate interior vertices. Returns: True if edge_chain[] is valid. </p>

</div>
</div>
<a id="a708ccfe1427637408f49714c75a60c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708ccfe1427637408f49714c75a60c55">&#9670;&nbsp;</a></span>IsValidEdgeChain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubDEdgeChain::IsValidEdgeChain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCheckForDuplicateEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Checks that all edge and vertex pointers are not nullptr and that adjacent edges in the list share the same vertex. Parameters: edge_count - [in] Number of elements in edge_chain[] to test. edge_chain - [in] Edge chain to test bCheckForDuplicateEdges - [in] If bCheckForDuplicateEdges true, then false is returned if there are duplicate edges or duplicate interior vertices. Returns: True if edge_chain[] is valid. </p>

</div>
</div>
<a id="a807eefe593ba3861891ab4900a04a131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807eefe593ba3861891ab4900a04a131">&#9670;&nbsp;</a></span>LastControlNetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_SubDEdgeChain::LastControlNetPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c1106e4d59fb916eba6c716ce2c0040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1106e4d59fb916eba6c716ce2c0040">&#9670;&nbsp;</a></span>LastEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubDEdgeChain::LastEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8df3180c00de7b84a5a63268aa21fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8df3180c00de7b84a5a63268aa21fff">&#9670;&nbsp;</a></span>LastEdgePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubDEdgeChain::LastEdgePtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e84be4cc8b5ef8db93cf459a1ea775c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e84be4cc8b5ef8db93cf459a1ea775c">&#9670;&nbsp;</a></span>LastVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubDEdgeChain::LastVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ef63216a46da51e9501c4cc8af99a76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef63216a46da51e9501c4cc8af99a76">&#9670;&nbsp;</a></span>LoftCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubDEdgeChain::LoftCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a NURBS curve that is appropriate for lofting SubDs. Parameters: destination - [in] If not nullptr, then the curve is created in this instance. Returns: A pointer to the curve or nullptr if the edge is not valid. </p>

</div>
</div>
<a id="af45811aa1bef01817c4b3d29cd68e8ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45811aa1bef01817c4b3d29cd68e8ba">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d_edge_chain.html">ON_SubDEdgeChain</a>&amp; ON_SubDEdgeChain::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge_chain.html">ON_SubDEdgeChain</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af70db5c09302a3091bdcbb4088d0148c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70db5c09302a3091bdcbb4088d0148c">&#9670;&nbsp;</a></span>OrientEdgesIntoEdgeChains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::OrientEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Orient edges[] into edge chains preserving the order of edges[]. Returns: Number of chains in edge_chains[]. </p>

</div>
</div>
<a id="a68ec1e622618befce0c7b5894356541b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ec1e622618befce0c7b5894356541b">&#9670;&nbsp;</a></span>OrientEdgesIntoEdgeChains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::OrientEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Orient edges[] into edge chains preserving the order of edges[]. Returns: Number of chains in edge_chains[]. </p>

</div>
</div>
<a id="ad0e784a958ca12a15c22b54385b98b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0e784a958ca12a15c22b54385b98b95">&#9670;&nbsp;</a></span>OrientEdgesIntoEdgeChains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::OrientEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Orient edges[] into edge chains preserving the order of edges[]. Returns: Number of chains in edge_chains[]. </p>

</div>
</div>
<a id="a9f8cc041297a5d7661da804173126811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8cc041297a5d7661da804173126811">&#9670;&nbsp;</a></span>PersistentSubDId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> ON_SubDEdgeChain::PersistentSubDId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: The persistent id of the parent subd object. If the context is an <a class="el" href="class_o_n_x___model.html">ONX_Model</a>, then the persistent id is the <a class="el" href="class_o_n___model_component.html#a7e4decb826ac79c583526fbc83a96946">ON_ModelGeometryComponent.Id()</a>. If the context is a <a class="el" href="class_c_rhino_doc.html">CRhinoDoc</a>, then the persistent id is <a class="el" href="class_c_rhino_object.html#ae2aa364054dac99424532db9850d0b5b">CRhinoObject.ModelObjectId()</a>. </p>

</div>
</div>
<a id="a59585b4b92db93b686828f7d9d276b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59585b4b92db93b686828f7d9d276b4b">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::Read </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa51505560fcb9a3f88c7cfec3862b1a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51505560fcb9a3f88c7cfec3862b1a9">&#9670;&nbsp;</a></span>RemoveEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdgeChain::RemoveEdges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>first_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>last_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a29f8c9ab790cdc00f9e7a9e870a2133c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f8c9ab790cdc00f9e7a9e870a2133c">&#9670;&nbsp;</a></span>Reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubDEdgeChain::Reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3979bfde1863cb244db6cecceb4117d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3979bfde1863cb244db6cecceb4117d0">&#9670;&nbsp;</a></span>ReverseEdgeChain() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ON_SubDEdgeChain::ReverseEdgeChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Reverse the orientation of the elements and the order of the elements in the edge_chain[] array. Parameters: edge_chain - [in/out] </p>

</div>
</div>
<a id="a3dd3023b9680b9ff7e5a7d63a4486d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd3023b9680b9ff7e5a7d63a4486d5d">&#9670;&nbsp;</a></span>ReverseEdgeChain() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ON_SubDEdgeChain::ReverseEdgeChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Reverse the orientation of the elements and the order of the elements in the edge_chain[] array. Parameters: edge_count - [in] Number of elements in edge_chain[] edge_chain - [in/out] <br  />
 </p>

</div>
</div>
<a id="affaa024a9bbda590e5c5d6e1aea674e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affaa024a9bbda590e5c5d6e1aea674e0">&#9670;&nbsp;</a></span>SetPersistentEdgeIdsFromRuntimeEdgePtrs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::SetPersistentEdgeIdsFromRuntimeEdgePtrs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83b5eae91c7dc825b94c54472b1244bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83b5eae91c7dc825b94c54472b1244bb">&#9670;&nbsp;</a></span>SetRuntimeEdgePtrsFromPersistentSubD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::SetRuntimeEdgePtrsFromPersistentSubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>persistent_subd_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a>&#160;</td>
          <td class="paramname"><em>persistent_subd_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: In situations where this edge chain is being read from a 3dm archive, or a similar serialization context, this function uses the saved edge id information to initialize the runtime <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> information. Parameters: persistent_subd_id - [in] This id is passed to insure it matches the saved persistent_subd_id. The source of the id depends on the context of the model managing the subd. If that context is an <a class="el" href="class_o_n_x___model.html">ONX_Model</a>, then the persistent id is the <a class="el" href="class_o_n___model_component.html#a7e4decb826ac79c583526fbc83a96946">ON_ModelGeometryComponent.Id()</a>. If that context is a <a class="el" href="class_c_rhino_doc.html">CRhinoDoc</a>, then the persistent id is <a class="el" href="class_c_rhino_object.html#ae2aa364054dac99424532db9850d0b5b">CRhinoObject.ModelObjectId()</a>. Returns: True if successful. False if not successful. </p>

</div>
</div>
<a id="a19f2da0199e8da69b6373ab3f570dd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19f2da0199e8da69b6373ab3f570dd59">&#9670;&nbsp;</a></span>SetStatusCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubDEdgeChain::SetStatusCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEnableStatusCheck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>status_check_pass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>status_check_fail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67fef84896d9761bd3afb9f1be0d916f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67fef84896d9761bd3afb9f1be0d916f">&#9670;&nbsp;</a></span>SortEdgesIntoEdgeChains() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::SortEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Unconditionally sort edges into chains.</p>
<p>Parameters: unsorted_edges - [in] If unsorted_edges[] contains three or more edges that share a common vertex, no edge chain will pass through that vertex.</p>
<p>sorted_edges - [out] The sorted_edges[] has the edges grouped into edge chains. A value of <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> is at the end of every chain including the last chain.</p>
<p>In an edge chain subsequent edges share a common vertex; i.e. sorted_edges[i].RelativeVertex(1) == sorted_edges[i+1].RelativeVertex(0). Returns: Number of chains in edge_chains[]. Remarks: This version of <a class="el" href="class_o_n___sub_d_edge_chain.html#a7bca320eb5ff08ac80ac6f0ca5b52c9b">SortEdgesIntoEdgeChains()</a> uses MarkBits() on the edges and vertices in unsorted_edges[]. The output values of MarkBits() on these components are zero. Multiple threads may not simultaneously use any SubD tools on that rely on markbits on the same <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. </p>

</div>
</div>
<a id="a26204fe0132f11bd952272589af8fb22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26204fe0132f11bd952272589af8fb22">&#9670;&nbsp;</a></span>SortEdgesIntoEdgeChains() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::SortEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_chain_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Sort edges into a chains</p>
<p>Parameters: unsorted_edges - [in] To sort an array in place, pass the same array as both parameters. If unsorted_edges[] contains three or more edges that share a common vertex, then all of the edges that share that vertex are ignored. The edges can be from one or more SubDs.</p>
<p>unsigned int minimum_chain_length - [in] minimum number of edges to consider for a chain.</p>
<p>edge_chains - [out] The edge_chains[] has the edges grouped into edge chains.</p>
<p>In an edge chain subsequent edges share a common vertex; i.e. edge_chains[i].RelativeVertex(1) == edge_chains[i+1].RelativeVertex(0).</p>
<p>When edge_chains[i].RelativeVertex(1) != edge_chains[i+1].RelativeVertex(0), a chain ends at edge_chains[i] and another begins at edge_chains[i+1].</p>
<p>The first edge in every chain has the same orientation as the input edge from edge_chains[].</p>
<p>Returns: Number of chains in edge_chains[].</p>
<p>Remarks: When the orientation of the input edges is not intentionally set, the versions of <a class="el" href="class_o_n___sub_d_edge_chain.html#a7bca320eb5ff08ac80ac6f0ca5b52c9b">SortEdgesIntoEdgeChains()</a> above without a minimum_chain_length variable are a better choice. </p>

</div>
</div>
<a id="a0e79d3f621b9ed90ca960fb65bfa04ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e79d3f621b9ed90ca960fb65bfa04ac">&#9670;&nbsp;</a></span>SortEdgesIntoEdgeChains() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::SortEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Unconditionally sort edges into chains.</p>
<p>Parameters: unsorted_edges - [in] If unsorted_edges[] contains three or more edges that share a common vertex, no edge chain will pass through that vertex.</p>
<p>sorted_edges - [out] The sorted_edges[] has the edges grouped into edge chains. A value of <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> is at the end of every chain including the last chain.</p>
<p>In an edge chain subsequent edges share a common vertex; i.e. sorted_edges[i].RelativeVertex(1) == sorted_edges[i+1].RelativeVertex(0). Returns: Number of chains in edge_chains[]. Remarks: This version of <a class="el" href="class_o_n___sub_d_edge_chain.html#a7bca320eb5ff08ac80ac6f0ca5b52c9b">SortEdgesIntoEdgeChains()</a> uses MarkBits() on the edges and vertices in unsorted_edges[]. The output value of MarkBits() on these components is zero. Multiple threads may not simultaneously use any SubD tools on that rely on markbits on the same <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. </p>

</div>
</div>
<a id="a0d78a1e1918f34a67c1af14108556b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d78a1e1918f34a67c1af14108556b0f">&#9670;&nbsp;</a></span>SortEdgesIntoEdgeChains() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::SortEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_chain_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Sort edges into a chains</p>
<p>Parameters: unsorted_edges - [in] To sort an array in place, pass the same array as both parameters. If unsorted_edges[] contains three or more edges that share a common vertex, then all of the edges that share that vertex are ignored. The edges can be from one or more SubDs.</p>
<p>unsigned int minimum_chain_length - [in] minimum number of edges to consider for a chain.</p>
<p>edge_chains - [out] The edge_chains[] has the edges grouped into edge chains.</p>
<p>In an edge chain subsequent edges share a common vertex; i.e. edge_chains[i].RelativeVertex(1) == edge_chains[i+1].RelativeVertex(0).</p>
<p>When edge_chains[i].RelativeVertex(1) != edge_chains[i+1].RelativeVertex(0), a chain ends at edge_chains[i] and another begins at edge_chains[i+1].</p>
<p>The first edge in every chain has the same orientation as the input edge from edge_chains[].</p>
<p>Returns: Number of chains in edge_chains[].</p>
<p>Remarks: When the orientation of the input edges is not intentionally set, the versions of <a class="el" href="class_o_n___sub_d_edge_chain.html#a7bca320eb5ff08ac80ac6f0ca5b52c9b">SortEdgesIntoEdgeChains()</a> above without a minimum_chain_length variable are a better choice. </p>

</div>
</div>
<a id="a7bca320eb5ff08ac80ac6f0ca5b52c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bca320eb5ff08ac80ac6f0ca5b52c9b">&#9670;&nbsp;</a></span>SortEdgesIntoEdgeChains() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::SortEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Edge chain tools Description: Unconditionally sort edges into chains.</p>
<p>Parameters: unsorted_edges - [in] If unsorted_edges[] contains three or more edges that share a common vertex, no edge chain will pass through that vertex. To sort an array in place, pass the same array as both parameters.</p>
<p>sorted_edges - [out] The sorted_edges[] has the edges grouped into edge chains. A value of <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> is at the end of every chain including the last chain.</p>
<p>In an edge chain subsequent edges share a common vertex; i.e. sorted_edges[i].RelativeVertex(1) == sorted_edges[i+1].RelativeVertex(0). Returns: Number of chains in edge_chains[]. Remarks: This version of <a class="el" href="class_o_n___sub_d_edge_chain.html#a7bca320eb5ff08ac80ac6f0ca5b52c9b">SortEdgesIntoEdgeChains()</a> uses MarkBits() on the edges and vertices in unsorted_edges[]. The output values of MarkBits() on these components are zero. Multiple threads may not simultaneously use any SubD tools on that rely on markbits on the same <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. </p>

</div>
</div>
<a id="a5a148a1b1a56c70e4f206cda4b452507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a148a1b1a56c70e4f206cda4b452507">&#9670;&nbsp;</a></span>SortEdgesIntoEdgeChains() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::SortEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_chain_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Sort edges into a chains</p>
<p>Parameters: unsorted_edges - [in] To sort an array in place, pass the same array as both parameters. If unsorted_edges[] contains three or more edges that share a common vertex, then all of the edges that share that vertex are ignored. The edges can be from one or more SubDs.</p>
<p>unsigned int minimum_chain_length - [in] minimum number of edges to consider for a chain.</p>
<p>edge_chains - [out] The edge_chains[] has the edges grouped into edge chains.</p>
<p>In an edge chain subsequent edges share a common vertex; i.e. edge_chains[i].RelativeVertex(1) == edge_chains[i+1].RelativeVertex(0).</p>
<p>When edge_chains[i].RelativeVertex(1) != edge_chains[i+1].RelativeVertex(0), a chain ends at edge_chains[i] and another begins at edge_chains[i+1].</p>
<p>Reasonnable effort is made to keep the first edge in every chain with the same orientation as the input edge from edge_chains[]. However, this is not possible in every case, for example if the input is two edges sharing the same starting vertex.</p>
<p>NB: Reasonnable effort is made to keep the corner vertices on the exterior of the chains, however some chains will have corners in their interior, especially closed chains.</p>
<p>Returns: Number of chains in edge_chains[].</p>
<p>Remarks: When the orientation of the input edges is not intentionally set, the versions of <a class="el" href="class_o_n___sub_d_edge_chain.html#a7bca320eb5ff08ac80ac6f0ca5b52c9b">SortEdgesIntoEdgeChains()</a> above without a minimum_chain_length variable are a better choice. </p>

</div>
</div>
<a id="ae9301ea4808ceb2bf5c2823bbef44968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9301ea4808ceb2bf5c2823bbef44968">&#9670;&nbsp;</a></span>SortEdgesIntoEdgeChains() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::SortEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Unconditionally sort edges into chains.</p>
<p>Parameters: unsorted_edges - [in] If unsorted_edges[] contains three or more edges that share a common vertex, no edge chain will pass through that vertex.</p>
<p>sorted_edges - [out] The sorted_edges[] has the edges grouped into edge chains. A value of <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> is at the end of every chain including the last chain.</p>
<p>In an edge chain subsequent edges share a common vertex; i.e. sorted_edges[i].RelativeVertex(1) == sorted_edges[i+1].RelativeVertex(0). Returns: Number of chains in edge_chains[]. Remarks: This version of <a class="el" href="class_o_n___sub_d_edge_chain.html#a7bca320eb5ff08ac80ac6f0ca5b52c9b">SortEdgesIntoEdgeChains()</a> uses MarkBits() on the edges and vertices in unsorted_edges[]. The output value of MarkBits() on these components is zero. Multiple threads may not simultaneously use any SubD tools on that rely on markbits on the same <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. </p>

</div>
</div>
<a id="a9e190f8228109b63c42a39bc413457a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e190f8228109b63c42a39bc413457a2">&#9670;&nbsp;</a></span>SortEdgesIntoEdgeChains() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDEdgeChain::SortEdgesIntoEdgeChains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_chain_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Sort edges into a chains</p>
<p>Parameters: unsorted_edges - [in] To sort an array in place, pass the same array as both parameters. If unsorted_edges[] contains three or more edges that share a common vertex, then all of the edges that share that vertex are ignored. The edges can be from one or more SubDs.</p>
<p>unsigned int minimum_chain_length - [in] minimum number of edges to consider for a chain.</p>
<p>edge_chains - [out] The edge_chains[] has the edges grouped into edge chains.</p>
<p>In an edge chain subsequent edges share a common vertex; i.e. edge_chains[i].RelativeVertex(1) == edge_chains[i+1].RelativeVertex(0).</p>
<p>When edge_chains[i].RelativeVertex(1) != edge_chains[i+1].RelativeVertex(0), a chain ends at edge_chains[i] and another begins at edge_chains[i+1].</p>
<p>The first edge in every chain has the same orientation as the input edge from edge_chains[].</p>
<p>Returns: Number of chains in edge_chains[].</p>
<p>Remarks: When the orientation of the input edges is not intentionally set, the versions of <a class="el" href="class_o_n___sub_d_edge_chain.html#a7bca320eb5ff08ac80ac6f0ca5b52c9b">SortEdgesIntoEdgeChains()</a> above without a minimum_chain_length variable are a better choice. </p>

</div>
</div>
<a id="a22f598de20e9e88968f6791e7038d303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22f598de20e9e88968f6791e7038d303">&#9670;&nbsp;</a></span>StatusCheck()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::StatusCheck </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78da4b8ad527ccb6bce64a3d69a274a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78da4b8ad527ccb6bce64a3d69a274a7">&#9670;&nbsp;</a></span>StatusCheckEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::StatusCheckEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab36228fb89c9333983a8374213a9602e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab36228fb89c9333983a8374213a9602e">&#9670;&nbsp;</a></span>StatusCheckFail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> ON_SubDEdgeChain::StatusCheckFail </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30bd2c621c580279e782459ca66fd404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30bd2c621c580279e782459ca66fd404">&#9670;&nbsp;</a></span>StatusCheckPass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> ON_SubDEdgeChain::StatusCheckPass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a35506a147807a9303e95bbf179bf28e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35506a147807a9303e95bbf179bf28e2">&#9670;&nbsp;</a></span>SubD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>&amp; ON_SubDEdgeChain::SubD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02eb20d56020cbe51c4d348eacfdf38d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02eb20d56020cbe51c4d348eacfdf38d">&#9670;&nbsp;</a></span>SubDRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a> ON_SubDEdgeChain::SubDRef </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa80ca6ab21eb6a70f51305532935b6b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80ca6ab21eb6a70f51305532935b6b4">&#9670;&nbsp;</a></span>Vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubDEdgeChain::Vertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02a56e9763d0c9e31322c32b98b337df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02a56e9763d0c9e31322c32b98b337df">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdgeChain::Write </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a032c9a736243d16ecef20d0e2dfd0ae2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a032c9a736243d16ecef20d0e2dfd0ae2">&#9670;&nbsp;</a></span>Empty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge_chain.html">ON_SubDEdgeChain</a> ON_SubDEdgeChain::Empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 21 2022 05:50:05 for Rhino C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
