<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_SubDMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API
   &#160;<span id="projectnumber">7.17</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_o_n___sub_d_matrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_SubDMatrix Class Reference<div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_subd.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aafdb36491a23fdd1e6cd8ca442c06f17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#aafdb36491a23fdd1e6cd8ca442c06f17">ON_SubDMatrix</a> ()=default</td></tr>
<tr class="separator:aafdb36491a23fdd1e6cd8ca442c06f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2148e0eb1556e757b0e0e002ab8bac1c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a2148e0eb1556e757b0e0e002ab8bac1c">EvaluateSubdivisionPoint</a> (unsigned int component_index, const double *point_ring, size_t point_ring_count, size_t point_ring_stride, double subd_point[3]) const</td></tr>
<tr class="separator:a2148e0eb1556e757b0e0e002ab8bac1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf9ce74e5224aa43462c5ec4b6f3c75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a1bf9ce74e5224aa43462c5ec4b6f3c75">EvaluateSurfacePoint</a> (const double *point_ring, size_t point_ring_count, size_t point_ring_stride, bool bUndefinedNormalIsPossible, class <a class="el" href="class_o_n___sub_d_sector_surface_point.html">ON_SubDSectorSurfacePoint</a> &amp;limit_point) const</td></tr>
<tr class="separator:a1bf9ce74e5224aa43462c5ec4b6f3c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0e523254bd8cc8307aa5444eefebf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a2a0e523254bd8cc8307aa5444eefebf2">EvaluateSurfacePoint</a> (const double *point_ring, size_t point_ring_count, size_t point_ring_stride, bool bUndefinedNormalIsPossible, double limit_point[3], double limit_tangent1[3], double limit_tangent2[3], double limit_normal[3]) const</td></tr>
<tr class="separator:a2a0e523254bd8cc8307aa5444eefebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a511629cdf7f2c32d6bd6e967d5160b51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a511629cdf7f2c32d6bd6e967d5160b51">IsValid</a> () const</td></tr>
<tr class="separator:a511629cdf7f2c32d6bd6e967d5160b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9f4eabcfba0645c5638d92c2e0a67c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#ada9f4eabcfba0645c5638d92c2e0a67c">IsValidPointRing</a> (const double *point_ring, size_t point_ring_count, size_t point_ring_stride) const</td></tr>
<tr class="separator:ada9f4eabcfba0645c5638d92c2e0a67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2065a651dc870b6b8b986042a8b8c66c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a2065a651dc870b6b8b986042a8b8c66c">SetFromSectorType</a> (<a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> sector_type)</td></tr>
<tr class="separator:a2065a651dc870b6b8b986042a8b8c66c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffcafd8b0d0a00c45819a35b7c98526"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#aeffcafd8b0d0a00c45819a35b7c98526">TestComponentRing</a> (const <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_ring, size_t component_ring_count) const</td></tr>
<tr class="separator:aeffcafd8b0d0a00c45819a35b7c98526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca3fa20c16acebc45834f390a3a2194"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a7ca3fa20c16acebc45834f390a3a2194">TestEvaluation</a> () const</td></tr>
<tr class="separator:a7ca3fa20c16acebc45834f390a3a2194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9a03d3482c132dfe5c591f1b9c6f45"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a2d9a03d3482c132dfe5c591f1b9c6f45">TestMatrix</a> () const</td></tr>
<tr class="separator:a2d9a03d3482c132dfe5c591f1b9c6f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a97a62bcdb4aec9a4ac33e7064ef9676c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a97a62bcdb4aec9a4ac33e7064ef9676c">EvaluateCosAndSin</a> (unsigned int j, unsigned int n, double *cos_theta, double *sin_theta)</td></tr>
<tr class="separator:a97a62bcdb4aec9a4ac33e7064ef9676c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ae566d41846b42787441ac9b35dcb5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_matrix.html">ON_SubDMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a00ae566d41846b42787441ac9b35dcb5">FromCache</a> (<a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> sector_type)</td></tr>
<tr class="separator:a00ae566d41846b42787441ac9b35dcb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cb8b316ab3e06ca0688ec359e3b553"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a22cb8b316ab3e06ca0688ec359e3b553">TestEvaluation</a> (const unsigned int subd_recursion_count, <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> sit, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;component_ring, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;subd_points, class <a class="el" href="class_o_n___sub_d_sector_surface_point.html">ON_SubDSectorSurfacePoint</a> &amp;limit_point)</td></tr>
<tr class="separator:a22cb8b316ab3e06ca0688ec359e3b553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f272136308295d6c761a8e7255e6d3"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a31f272136308295d6c761a8e7255e6d3">TestEvaluation</a> (<a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> sector_type, unsigned int minimum_sector_face_count, unsigned int maximum_sector_face_count, <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *text_log)</td></tr>
<tr class="separator:a31f272136308295d6c761a8e7255e6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ade5b500d3f2dd03ff7ccf93272758698"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#ade5b500d3f2dd03ff7ccf93272758698">m_L1</a> = nullptr</td></tr>
<tr class="separator:ade5b500d3f2dd03ff7ccf93272758698"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85afe42e67f98105b8125d6fa3f9c1c7"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a85afe42e67f98105b8125d6fa3f9c1c7">m_L2</a> = nullptr</td></tr>
<tr class="separator:a85afe42e67f98105b8125d6fa3f9c1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cb1f3a89db97b1fd244dbf15f75f9c"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#af2cb1f3a89db97b1fd244dbf15f75f9c">m_LP</a> = nullptr</td></tr>
<tr class="separator:af2cb1f3a89db97b1fd244dbf15f75f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e2874770358caa5b1b430ee49831c02"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a3e2874770358caa5b1b430ee49831c02">m_R</a> = 0</td></tr>
<tr class="memdesc:a3e2874770358caa5b1b430ee49831c02"><td class="mdescLeft">&#160;</td><td class="mdescRight">the matrix m_S is m_R x m_R (m_R = m_sector_type.PointRingCount())  <a href="class_o_n___sub_d_matrix.html#a3e2874770358caa5b1b430ee49831c02">More...</a><br /></td></tr>
<tr class="separator:a3e2874770358caa5b1b430ee49831c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051cb66d71a6d1e00a67f4e003eb0d5a"><td class="memItemLeft" align="right" valign="top">const double *const  *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a051cb66d71a6d1e00a67f4e003eb0d5a">m_S</a> = nullptr</td></tr>
<tr class="separator:a051cb66d71a6d1e00a67f4e003eb0d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f4b85c65831caef5f2cbe3a16e6451d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a2f4b85c65831caef5f2cbe3a16e6451d">m_sector_type</a></td></tr>
<tr class="separator:a2f4b85c65831caef5f2cbe3a16e6451d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a3e4f995e163acb0256252b3dd674a845"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_matrix.html">ON_SubDMatrix</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_matrix.html#a3e4f995e163acb0256252b3dd674a845">Empty</a></td></tr>
<tr class="separator:a3e4f995e163acb0256252b3dd674a845"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_o_n___sub_d_matrix.html">ON_SubDMatrix</a> </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aafdb36491a23fdd1e6cd8ca442c06f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafdb36491a23fdd1e6cd8ca442c06f17">&#9670;&nbsp;</a></span>ON_SubDMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubDMatrix::ON_SubDMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a97a62bcdb4aec9a4ac33e7064ef9676c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a62bcdb4aec9a4ac33e7064ef9676c">&#9670;&nbsp;</a></span>EvaluateCosAndSin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubDMatrix::EvaluateCosAndSin </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cos_theta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>sin_theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Precise evaluation of cos(a) and cos(a) where a = i/n pi. These values are required for high qualitiy limit surface evaluation. Parameters: j - [in] n - [in] cos_theta - [out] cos(j/n pi) sin_theta - [out] sin(j/n pi) </p>

</div>
</div>
<a id="a2148e0eb1556e757b0e0e002ab8bac1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2148e0eb1556e757b0e0e002ab8bac1c">&#9670;&nbsp;</a></span>EvaluateSubdivisionPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDMatrix::EvaluateSubdivisionPoint </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>component_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>point_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>subd_point</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1bf9ce74e5224aa43462c5ec4b6f3c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf9ce74e5224aa43462c5ec4b6f3c75">&#9670;&nbsp;</a></span>EvaluateSurfacePoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDMatrix::EvaluateSurfacePoint </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>point_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUndefinedNormalIsPossible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_sector_surface_point.html">ON_SubDSectorSurfacePoint</a> &amp;&#160;</td>
          <td class="paramname"><em>limit_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a0e523254bd8cc8307aa5444eefebf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0e523254bd8cc8307aa5444eefebf2">&#9670;&nbsp;</a></span>EvaluateSurfacePoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDMatrix::EvaluateSurfacePoint </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>point_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUndefinedNormalIsPossible</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limit_point</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limit_tangent1</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limit_tangent2</em>[3], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>limit_normal</em>[3]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a00ae566d41846b42787441ac9b35dcb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ae566d41846b42787441ac9b35dcb5">&#9670;&nbsp;</a></span>FromCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_o_n___sub_d_matrix.html">ON_SubDMatrix</a>&amp; ON_SubDMatrix::FromCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td>
          <td class="paramname"><em>sector_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Get the subdivision matrix information for the case specified by the input parameters. This information is retrieved from a cache. In some cases, it will be calculated the first time it is needed. <br  />
 Parameters: facet_type - [in] vertex_tag - [in] valence - [in] The input parameters identify the subdivision case. Remarks: Every member function of <a class="el" href="class_o_n___sub_d_matrix.html">ON_SubDMatrix</a>, including this one is thread safe. </p>

</div>
</div>
<a id="a511629cdf7f2c32d6bd6e967d5160b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a511629cdf7f2c32d6bd6e967d5160b51">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDMatrix::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada9f4eabcfba0645c5638d92c2e0a67c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9f4eabcfba0645c5638d92c2e0a67c">&#9670;&nbsp;</a></span>IsValidPointRing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDMatrix::IsValidPointRing </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>point_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2065a651dc870b6b8b986042a8b8c66c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2065a651dc870b6b8b986042a8b8c66c">&#9670;&nbsp;</a></span>SetFromSectorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDMatrix::SetFromSectorType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td>
          <td class="paramname"><em>sector_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set the values in this <a class="el" href="class_o_n___sub_d_matrix.html">ON_SubDMatrix</a> so the information can be used to evaluate the case identified by the input parameters. Parameters: facet_type - [in] vertex_tag - [in] sector_edge_count - [in] The input parameters identify the subdivision case. Returns: R &gt; 0: Success. The matrix is R x R. 0: Failure. </p>

</div>
</div>
<a id="aeffcafd8b0d0a00c45819a35b7c98526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffcafd8b0d0a00c45819a35b7c98526">&#9670;&nbsp;</a></span>TestComponentRing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDMatrix::TestComponentRing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ca3fa20c16acebc45834f390a3a2194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca3fa20c16acebc45834f390a3a2194">&#9670;&nbsp;</a></span>TestEvaluation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDMatrix::TestEvaluation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Run evaluation tests on this subdivision case. Returns: &gt;= 0.0: Test passed. Maximum deviation found in any test is returned. ON_UNSET_VALUE: Test failed. </p>

</div>
</div>
<a id="a22cb8b316ab3e06ca0688ec359e3b553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cb8b316ab3e06ca0688ec359e3b553">&#9670;&nbsp;</a></span>TestEvaluation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDMatrix::TestEvaluation </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>subd_recursion_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a>&#160;</td>
          <td class="paramname"><em>sit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subd_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_sector_surface_point.html">ON_SubDSectorSurfacePoint</a> &amp;&#160;</td>
          <td class="paramname"><em>limit_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Test cached subdivision matrix on sector identified by sit. Parameters: subd_type - [in] subd_recursion_count - [in] number of times to subdivide sit - [in] vertex to subdivide component_ring - [out] subd_points - [out] limit_point - [out] limit_tangent0 - [out] limit_tangent1 - [out] limit_normal - [out] </p>

</div>
</div>
<a id="a31f272136308295d6c761a8e7255e6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f272136308295d6c761a8e7255e6d3">&#9670;&nbsp;</a></span>TestEvaluation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDMatrix::TestEvaluation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td>
          <td class="paramname"><em>sector_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_sector_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maximum_sector_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>text_log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Run evaluation tests on a range of subdivision cases. Parameters: sector_type - [in] If <a class="el" href="class_o_n___sub_d_sector_type.html#ae3b9a4e8d8e5012445781b26770798c5">ON_SubDSectorType::Empty</a>, then all supported sector types types are tested. minimum_sector_face_count - [in] If 0, then testing begins at ON_SubDSectorType::MinimumSectorFaceCount(vertex_tag) when testing vertex_tag types maximum_sector_face_count - [in] If 0, then testing stops at ON_SubD::maximum_evaluation_valence. text_log - [out] If not nullptr, then a brief written report is printed for each test case. Returns: &gt;= 0.0: Test passed. Maximum deviation found in any test is returned. ON_UNSET_VALUE: Test failed. <br  />
 </p>

</div>
</div>
<a id="a2d9a03d3482c132dfe5c591f1b9c6f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9a03d3482c132dfe5c591f1b9c6f45">&#9670;&nbsp;</a></span>TestMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDMatrix::TestMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: ON_UNSET_VALUE - serious error &gt;= 0: Maximum value of numbers that should be zero in and ideal world. <br  />
 When the matrices, eigenvalues and eigenvectors are correctly calculated, this returned value is in the range from 1e-16 to 5e-13 as valence goes from 3 to 100. For valences &lt; 100, if a value larger than 1.0e-12 occurs, there is a bug in the code. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3e4f995e163acb0256252b3dd674a845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e4f995e163acb0256252b3dd674a845">&#9670;&nbsp;</a></span>Empty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_matrix.html">ON_SubDMatrix</a> ON_SubDMatrix::Empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade5b500d3f2dd03ff7ccf93272758698"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5b500d3f2dd03ff7ccf93272758698">&#9670;&nbsp;</a></span>m_L1</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* ON_SubDMatrix::m_L1 = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>m_L1 and m_L2 = tangent space evaluation vectors. The arrays m_L1[] and m_L2[] have m_R elements. If (vertexR[0], ..., vertexR[R-1]) is a list of standard vertex ring points, then the two vectors V1 = m_L1[0]*vertexR[0] + ... + m_L1[R-1]*vertexR[R-1]. V2 = m_L2[0]*vertexR[0] + ... + m_L2[R-1]*vertexR[R-1]. span the tangent plane and N = V1 x V2 is perpindicular to the limit tangent plane. In general and almost always in practice, V1 and V2 are not unit vectors and it is best to noramalize V1 and V2 before taking the cross product. m_L1 and m_L2 are subdominant eigenvectors of Transpose(m_S). When the subdominant eigenvalue has geometric multiplicity 2, m_L1 and m_L2 span the same space as m_E1 and m_E2. The values stored in m_L1 and m_L2 are chosen to provide accurate evaluation. In come common cases m_L1 and m_L2 are equal to m_E1 and m_E2, but not in all cases. </p>

</div>
</div>
<a id="a85afe42e67f98105b8125d6fa3f9c1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85afe42e67f98105b8125d6fa3f9c1c7">&#9670;&nbsp;</a></span>m_L2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* ON_SubDMatrix::m_L2 = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2cb1f3a89db97b1fd244dbf15f75f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cb1f3a89db97b1fd244dbf15f75f9c">&#9670;&nbsp;</a></span>m_LP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* ON_SubDMatrix::m_LP = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>m_LP[] = limit point evaluation vector. The array m_LP[] has m_R elements. If (vertexR[0], ..., vertexR[R-1]) is a list of standard vertex ring points, then Limit point = m_LP[0]*vertexR[0] + ... + m_LP[R-1]*vertexR[R-1]. m_LP is the eigenvector of Transpose(m_S) with eigenvalue = 1. Length(m_LP) = 1. </p>

</div>
</div>
<a id="a3e2874770358caa5b1b430ee49831c02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e2874770358caa5b1b430ee49831c02">&#9670;&nbsp;</a></span>m_R</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDMatrix::m_R = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the matrix m_S is m_R x m_R (m_R = m_sector_type.PointRingCount()) </p>

</div>
</div>
<a id="a051cb66d71a6d1e00a67f4e003eb0d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051cb66d71a6d1e00a67f4e003eb0d5a">&#9670;&nbsp;</a></span>m_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double* const* ON_SubDMatrix::m_S = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The term "standard vertex ring points" is used below.</p>
<p>If "C" is an interior vertex (m_vertex_tag is smooth or dart), (E[0], ...., E[N-1]) is a radially sorted list of its edges, (F[0], ..., F[N-1]) is a radially sorted list of its faces, and (P[0], ..., P[N-1]) is a list of the edge vertices opposite C, E0type = smooth for a smooth vertex and crease for a dart vertex, then C is "standard" if E[0] has type E0type, every other edge E[i] is smooth, every outer vertex/ P[i] is smooth, and every face F[i] has the stadard facet type (tri or quad) for the subdivision algorithm.</p>
<p>If If "C" is a boundary vertex (m_vertex_tag is crease or corner), the conditions listed above are satisified except E[0] and E[N-1] are tagged as crease edges, P[0] and P[N-1] are tagged as crease vertices (NOT corners), and there are N-2 faces, then "C" is a standard boundary vertex.</p>
<p>If the facet type is triangle and C is a standard interior or boundary vertex, then the "standard vertex ring" is the list of N+1 points (C, P[0], ...., P[N-1]).</p>
<p>If the facet type is quad, and C is a standard interior vertex, then the "standard vertex ring" is the list of 2*N+1 points (C, P[0], Q[0], ...., P[N-1], Q[N-1]), where Q[I] is the vertex of quad F[i] diagonally across from C.</p>
<p>If the facet type is quad, and C is a standard boundary vertex, then the "standard vertex ring" is the list of 2*N points (C, P[0], Q[0], ...., P[N-1]). m_S = R x R subdivision matrix If (vertexR[0], ..., vertexR[R-1]) is a list of standard vertex ring points, then then the location of the subdivided ring points (vertexR1[0], ..., vertexR1[R-1]) can be calculated from m_S. vertexR1[i] = m_S[i][0]*vertexR[0] + ... + m_S[i][R-1]*vertexR[R-1] </p>

</div>
</div>
<a id="a2f4b85c65831caef5f2cbe3a16e6451d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f4b85c65831caef5f2cbe3a16e6451d">&#9670;&nbsp;</a></span>m_sector_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDMatrix::m_sector_type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 21 2022 05:50:05 for Rhino C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
