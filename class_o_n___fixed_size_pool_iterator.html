<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_FixedSizePoolIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API<span id="projectnumber">&#160;7.12</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_o_n___fixed_size_pool_iterator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ON_FixedSizePoolIterator Class Reference<div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_fsp.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ON_FixedSizePoolIterator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_n___fixed_size_pool_iterator.png" usemap="#ON_5FFixedSizePoolIterator_map" alt=""/>
  <map id="ON_5FFixedSizePoolIterator_map" name="ON_5FFixedSizePoolIterator_map">
<area href="class_o_n___mesh_x_point_pool_iterator.html" alt="ON_MeshXPointPoolIterator" shape="rect" coords="0,56,226,80"/>
<area href="class_o_n___simple_fixed_size_pool_iterator.html" alt="ON_SimpleFixedSizePoolIterator&lt; T &gt;" shape="rect" coords="236,56,462,80"/>
<area href="class_o_n___sub_d_edge_id_iterator.html" alt="ON_SubDEdgeIdIterator" shape="rect" coords="472,56,698,80"/>
<area href="class_o_n___sub_d_face_id_iterator.html" alt="ON_SubDFaceIdIterator" shape="rect" coords="708,56,934,80"/>
<area href="class_o_n___sub_d_vertex_id_iterator.html" alt="ON_SubDVertexIdIterator" shape="rect" coords="944,56,1170,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aeb0fb467ddc1045cfbec8a5043131f3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#aeb0fb467ddc1045cfbec8a5043131f3b">ON_FixedSizePoolIterator</a> ()</td></tr>
<tr class="separator:aeb0fb467ddc1045cfbec8a5043131f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6eee00ecb9ad6c5788ad38bfdfc4d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#add6eee00ecb9ad6c5788ad38bfdfc4d8">ON_FixedSizePoolIterator</a> (const class <a class="el" href="class_o_n___fixed_size_pool.html">ON_FixedSizePool</a> &amp;fsp)</td></tr>
<tr class="separator:add6eee00ecb9ad6c5788ad38bfdfc4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a272ce1261de15271a967c9348e06f97b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#a272ce1261de15271a967c9348e06f97b">Create</a> (const <a class="el" href="class_o_n___fixed_size_pool.html">ON_FixedSizePool</a> *fsp)</td></tr>
<tr class="separator:a272ce1261de15271a967c9348e06f97b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50d5c753a004ce40852ef742af56cd0"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#ab50d5c753a004ce40852ef742af56cd0">CurrentElement</a> () const</td></tr>
<tr class="separator:ab50d5c753a004ce40852ef742af56cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60638bbcabb74e9244263b280c42e731"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60638bbcabb74e9244263b280c42e731">FirstBlock</a> (size_t *block_element_count)</td></tr>
<tr class="separator:a60638bbcabb74e9244263b280c42e731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc35e15ad4038ea6f508d9872fac7d04"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement</a> ()</td></tr>
<tr class="separator:adc35e15ad4038ea6f508d9872fac7d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5df4d56243afa762603fcfffb043b26"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#aa5df4d56243afa762603fcfffb043b26">FirstElement</a> (size_t element_index)</td></tr>
<tr class="separator:aa5df4d56243afa762603fcfffb043b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af95ab7b5aa65fb4027a3500757359afa"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___fixed_size_pool.html">ON_FixedSizePool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#af95ab7b5aa65fb4027a3500757359afa">FixedSizePool</a> ()</td></tr>
<tr class="separator:af95ab7b5aa65fb4027a3500757359afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2801dbd40d7cdd7f9f27fbda2d7fba88"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#a2801dbd40d7cdd7f9f27fbda2d7fba88">NextBlock</a> (size_t *block_element_count)</td></tr>
<tr class="separator:a2801dbd40d7cdd7f9f27fbda2d7fba88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60e52046ebffff6e01f27eb8974ee379"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement</a> ()</td></tr>
<tr class="separator:a60e52046ebffff6e01f27eb8974ee379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86aa71cb6451e8ecd70a8506dcd0886f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___fixed_size_pool_iterator.html#a86aa71cb6451e8ecd70a8506dcd0886f">Reset</a> ()</td></tr>
<tr class="separator:a86aa71cb6451e8ecd70a8506dcd0886f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aeb0fb467ddc1045cfbec8a5043131f3b" name="aeb0fb467ddc1045cfbec8a5043131f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0fb467ddc1045cfbec8a5043131f3b">&#9670;&nbsp;</a></span>ON_FixedSizePoolIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_FixedSizePoolIterator::ON_FixedSizePoolIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add6eee00ecb9ad6c5788ad38bfdfc4d8" name="add6eee00ecb9ad6c5788ad38bfdfc4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add6eee00ecb9ad6c5788ad38bfdfc4d8">&#9670;&nbsp;</a></span>ON_FixedSizePoolIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_FixedSizePoolIterator::ON_FixedSizePoolIterator </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___fixed_size_pool.html">ON_FixedSizePool</a> &amp;&#160;</td>
          <td class="paramname"><em>fsp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a272ce1261de15271a967c9348e06f97b" name="a272ce1261de15271a967c9348e06f97b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a272ce1261de15271a967c9348e06f97b">&#9670;&nbsp;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_FixedSizePoolIterator::Create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___fixed_size_pool.html">ON_FixedSizePool</a> *&#160;</td>
          <td class="paramname"><em>fsp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab50d5c753a004ce40852ef742af56cd0" name="ab50d5c753a004ce40852ef742af56cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50d5c753a004ce40852ef742af56cd0">&#9670;&nbsp;</a></span>CurrentElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ON_FixedSizePoolIterator::CurrentElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Returns: The most recently returned value from a call to <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> or <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a>. Remarks: Do not make any calls to <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60638bbcabb74e9244263b280c42e731">FirstBlock()</a> or <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a2801dbd40d7cdd7f9f27fbda2d7fba88">NextBlock()</a> when using <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> to iteratate through elements. </p>

</div>
</div>
<a id="a60638bbcabb74e9244263b280c42e731" name="a60638bbcabb74e9244263b280c42e731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60638bbcabb74e9244263b280c42e731">&#9670;&nbsp;</a></span>FirstBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ON_FixedSizePoolIterator::FirstBlock </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>block_element_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Description: Get a pointer to the first element in the first block. Parameters: block_element_count - [out] (can be null) If not null, the number of elements allocated from the first block is returned in block_element_count. Note that if you have used ReturnElement(), some of these elemements may have been returned. Example: The loop will iteratate through all the blocks.</p>
<p >/ iterate through all blocks in the pool size_t block_element_count = 0; for ( void* p = FirstBlock(&amp;block_element_count); 0 != p; p = NextBlock(&amp;block_element_count) ) { ElementType* e = (ElementType*)p; for ( size_t i = 0; i &lt; block_element_count; i++, e = ((const char*)e) + SizeofElement() ) { ... } }</p>
<p >Returns: The first block when iterating the list of blocks. Remarks: The heap for a fixed size memory pool is simply a linked list of blocks. <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60638bbcabb74e9244263b280c42e731">FirstBlock()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a2801dbd40d7cdd7f9f27fbda2d7fba88">NextBlock()</a> can be used to iterate through the list of blocks.</p>
<p >Do not make any calls to <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> or <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> when using <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60638bbcabb74e9244263b280c42e731">FirstBlock()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a2801dbd40d7cdd7f9f27fbda2d7fba88">NextBlock()</a> to iteratate through blocks. </p>

</div>
</div>
<a id="adc35e15ad4038ea6f508d9872fac7d04" name="adc35e15ad4038ea6f508d9872fac7d04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc35e15ad4038ea6f508d9872fac7d04">&#9670;&nbsp;</a></span>FirstElement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ON_FixedSizePoolIterator::FirstElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Description: Get the first element when iterating through the list of elements. Parameters: element_index - [in] If you use the version of <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> that has an element_index parameter, then the iteration begins at that element. Example: The loop will iteratate through all the elements returned from AllocateElement(), including any that have be returned to the pool using ReturnElement().</p>
<p >/ iterate through all elements in the pool / This iteration will go through TotalElements() items. for ( void* p = <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a>; 0 != p; p = <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> ) { / If you are not using ReturnElement(), then you may process / "p" immediately. If you have used ReturnElement(), then you / must check some value in p located after the first sizeof(void*) / bytes to see if p is active. if ( p is not active ) continue;</p>
<p >... process p }</p>
<p >Returns: The first element when iterating through the list of elements. Remarks: <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> will return elements that have been returned to the pool using ReturnElement(). If you use ReturnElement(), then be sure to mark the element so it can be identified and skipped.</p>
<p >Do not make any calls to <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60638bbcabb74e9244263b280c42e731">FirstBlock()</a> or <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a2801dbd40d7cdd7f9f27fbda2d7fba88">NextBlock()</a> when using <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> to iteratate through elements. </p>

</div>
</div>
<a id="aa5df4d56243afa762603fcfffb043b26" name="aa5df4d56243afa762603fcfffb043b26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5df4d56243afa762603fcfffb043b26">&#9670;&nbsp;</a></span>FirstElement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ON_FixedSizePoolIterator::FirstElement </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af95ab7b5aa65fb4027a3500757359afa" name="af95ab7b5aa65fb4027a3500757359afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af95ab7b5aa65fb4027a3500757359afa">&#9670;&nbsp;</a></span>FixedSizePool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___fixed_size_pool.html">ON_FixedSizePool</a> * ON_FixedSizePoolIterator::FixedSizePool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2801dbd40d7cdd7f9f27fbda2d7fba88" name="a2801dbd40d7cdd7f9f27fbda2d7fba88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2801dbd40d7cdd7f9f27fbda2d7fba88">&#9670;&nbsp;</a></span>NextBlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ON_FixedSizePoolIterator::NextBlock </td>
          <td>(</td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>block_element_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Description: Get the next block when iterating through the blocks. Parameters: block_element_count - [out] (can be null) If not null, the number of elements allocated from the block is returned in block_element_count. Note that if you have used ReturnElement(), some of these elemements may have been returned. Example: See the <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60638bbcabb74e9244263b280c42e731">FirstBlock()</a> documentation. Returns: The next block when iterating through the blocks. Remarks: Do not make any calls to <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> or <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> when using <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60638bbcabb74e9244263b280c42e731">FirstBlock()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a2801dbd40d7cdd7f9f27fbda2d7fba88">NextBlock()</a> to iteratate through blocks. </p>

</div>
</div>
<a id="a60e52046ebffff6e01f27eb8974ee379" name="a60e52046ebffff6e01f27eb8974ee379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e52046ebffff6e01f27eb8974ee379">&#9670;&nbsp;</a></span>NextElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * ON_FixedSizePoolIterator::NextElement </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Description: Get the next element when iterating through the list of elements. If <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> is not called, then the first call to <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> returns the first element. Example: See the <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> documentation. Returns: The next element when iterating through the list of elements. Remarks: <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> will return elements that have been returned to the pool using ReturnElement(). If you use ReturnElement(), then be sure to mark the element so it can be identified and skipped.</p>
<p >Do not make any calls to <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60638bbcabb74e9244263b280c42e731">FirstBlock()</a> or <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a2801dbd40d7cdd7f9f27fbda2d7fba88">NextBlock()</a> when using <a class="el" href="class_o_n___fixed_size_pool_iterator.html#adc35e15ad4038ea6f508d9872fac7d04">FirstElement()</a> and <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> to iteratate through elements. </p>

</div>
</div>
<a id="a86aa71cb6451e8ecd70a8506dcd0886f" name="a86aa71cb6451e8ecd70a8506dcd0886f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86aa71cb6451e8ecd70a8506dcd0886f">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_FixedSizePoolIterator::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Description: Sets the state of the iterator to the initial state that exists after construction. This is useful if the iterator has been used the get one or more elements and then the referenced fixed size pool is modified or code wants to begin iteration again a used a call to <a class="el" href="class_o_n___fixed_size_pool_iterator.html#a60e52046ebffff6e01f27eb8974ee379">NextElement()</a> to return the first element. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Nov 9 2021 23:10:34 for Rhino C++ API by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
