<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API
   &#160;<span id="projectnumber">7.17</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_o_n___mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_Mesh Class Reference<div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_mesh.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ON_Mesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_n___mesh.png" usemap="#ON_5FMesh_map" alt=""/>
  <map id="ON_5FMesh_map" name="ON_5FMesh_map">
<area href="class_o_n___geometry.html" alt="ON_Geometry" shape="rect" coords="0,56,92,80"/>
<area href="class_o_n___object.html" alt="ON_Object" shape="rect" coords="0,0,92,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae117c9788c5c8f66ba927af0bc37d13"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aae117c9788c5c8f66ba927af0bc37d13">ON_Mesh</a> ()</td></tr>
<tr class="separator:aae117c9788c5c8f66ba927af0bc37d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332c7a7ffd31f4670a9aceee1d4d959f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a332c7a7ffd31f4670a9aceee1d4d959f">ON_Mesh</a> (const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;)</td></tr>
<tr class="separator:a332c7a7ffd31f4670a9aceee1d4d959f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee37aa93246b181563b9aabed637a0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a9ee37aa93246b181563b9aabed637a0e">ON_Mesh</a> (int initial_face_array_capacity, int initial_vertex_array_capacity, bool has_vertex_normals, bool has_texture_coordinates)</td></tr>
<tr class="separator:a9ee37aa93246b181563b9aabed637a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8da15ad65efff0f1967534245d81383"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af8da15ad65efff0f1967534245d81383">~ON_Mesh</a> ()</td></tr>
<tr class="separator:af8da15ad65efff0f1967534245d81383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34cab5280e39fd919b5e019817ce04dc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a34cab5280e39fd919b5e019817ce04dc">AddNgon</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;ngon_fi)</td></tr>
<tr class="separator:a34cab5280e39fd919b5e019817ce04dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb812b572f4ced402594a186fde4d243"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#adb812b572f4ced402594a186fde4d243">AddNgon</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;ngon_fi, bool bPermitHoles)</td></tr>
<tr class="separator:adb812b572f4ced402594a186fde4d243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3d88b51027b886d9b467eda75036eb"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#abb3d88b51027b886d9b467eda75036eb">AddNgon</a> (<a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *ngon)</td></tr>
<tr class="separator:abb3d88b51027b886d9b467eda75036eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f89a4ba64a5e25a7a20ad3ac6881ab7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a1f89a4ba64a5e25a7a20ad3ac6881ab7">AddNgon</a> (unsigned int Fcount, const unsigned int *ngon_fi)</td></tr>
<tr class="separator:a1f89a4ba64a5e25a7a20ad3ac6881ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb115a0baab6a1b37bbc5c95f61937e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3cb115a0baab6a1b37bbc5c95f61937e">AddNgon</a> (unsigned int Fcount, const unsigned int *ngon_fi, bool bPermitHoles)</td></tr>
<tr class="separator:a3cb115a0baab6a1b37bbc5c95f61937e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a5572ee9d7de8a703aa4a432934655"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a19a5572ee9d7de8a703aa4a432934655">AddNgon</a> (unsigned int Vcount, const unsigned int *ngon_vi, unsigned int Fcount, const unsigned int *ngon_fi)</td></tr>
<tr class="separator:a19a5572ee9d7de8a703aa4a432934655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21cc7b60eb21a8836512136c951929c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a21cc7b60eb21a8836512136c951929c2">AddNgon_Expert</a> (unsigned int Fcount, const unsigned int *ngon_fi, bool bPermitHoles, <a class="el" href="class_o_n___mesh_vertex_face_map.html">ON_MeshVertexFaceMap</a> *vertexFaceMap)</td></tr>
<tr class="separator:a21cc7b60eb21a8836512136c951929c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61cd035aeaea26d6814a8711a657a00c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a61cd035aeaea26d6814a8711a657a00c">AddNgons</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;ci_list)</td></tr>
<tr class="separator:a61cd035aeaea26d6814a8711a657a00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb69972dd0035076ee1a393e7aae1a0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3fb69972dd0035076ee1a393e7aae1a0">AddPlanarNgons</a> (const unsigned int *const *vertex_face_map, double planar_tolerance, unsigned int minimum_ngon_vertex_count, unsigned int minimum_ngon_face_count, bool bAllowHoles)</td></tr>
<tr class="separator:a3fb69972dd0035076ee1a393e7aae1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b7951b3d2892e63d866c4ff8d65dfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ab9b7951b3d2892e63d866c4ff8d65dfd">AllocateNgon</a> (unsigned int Vcount, unsigned int Fcount)</td></tr>
<tr class="separator:ab9b7951b3d2892e63d866c4ff8d65dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0198c652c36b53f12c0d74cd595fb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3c0198c652c36b53f12c0d74cd595fb3">Append</a> (const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;)</td></tr>
<tr class="separator:a3c0198c652c36b53f12c0d74cd595fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae777b88e5fabcbc1c30be351f6fc66ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae777b88e5fabcbc1c30be351f6fc66ef">Append</a> (int count, const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *const *meshes)</td></tr>
<tr class="separator:ae777b88e5fabcbc1c30be351f6fc66ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16aa24cbbaec4719b4d8c769c3c228a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad16aa24cbbaec4719b4d8c769c3c228a">AppendDuplicateVertex</a> (unsigned int vertex_index)</td></tr>
<tr class="separator:ad16aa24cbbaec4719b4d8c769c3c228a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d01c5ae22270259f4b6e9479435dc1b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a6d01c5ae22270259f4b6e9479435dc1b">Area</a> (double *error_estimate=nullptr) const</td></tr>
<tr class="separator:a6d01c5ae22270259f4b6e9479435dc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871cd5388f731d384c4e0b1691466d8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a871cd5388f731d384c4e0b1691466d8e">AreaCentroid</a> (double *area=nullptr) const</td></tr>
<tr class="separator:a871cd5388f731d384c4e0b1691466d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a5c36e20952ce0093357198bea41de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a30a5c36e20952ce0093357198bea41de">AreaMassProperties</a> (class <a class="el" href="class_o_n___mass_properties.html">ON_MassProperties</a> &amp;mp, bool bArea=true, bool bFirstMoments=true, bool bSecondMoments=true, bool bProductMoments=true) const</td></tr>
<tr class="separator:a30a5c36e20952ce0093357198bea41de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957ffd9a3063108424eac2fa074679bf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___texture_coordinates.html">ON_TextureCoordinates</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a957ffd9a3063108424eac2fa074679bf">CachedTextureCoordinates</a> (const <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> &amp;mapping_id) const</td></tr>
<tr class="separator:a957ffd9a3063108424eac2fa074679bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a3818ee6b07ff3eb51041bf73043aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a0a3818ee6b07ff3eb51041bf73043aca">Cleanup</a> (bool bRemoveNgons)</td></tr>
<tr class="separator:a0a3818ee6b07ff3eb51041bf73043aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a7d6a2dacb62aedb47da2078085d8a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a00a7d6a2dacb62aedb47da2078085d8a">Cleanup</a> (bool bRemoveNgons, bool bRemoveDegenerateFaces, bool bCompact)</td></tr>
<tr class="separator:a00a7d6a2dacb62aedb47da2078085d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfbed67618c3ce4d2811331d61b78efa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#abfbed67618c3ce4d2811331d61b78efa">CollapseEdge</a> (int topei)</td></tr>
<tr class="separator:abfbed67618c3ce4d2811331d61b78efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a116aab0639f1fd05524f06f25a0eb533"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a116aab0639f1fd05524f06f25a0eb533">CombineCoincidentVertices</a> (<a class="el" href="class_o_n__3f_vector.html">ON_3fVector</a>, double)</td></tr>
<tr class="memdesc:a116aab0639f1fd05524f06f25a0eb533"><td class="mdescLeft">&#160;</td><td class="mdescRight">finds all coincident vertices and merges them if break angle is small enough  <a href="class_o_n___mesh.html#a116aab0639f1fd05524f06f25a0eb533">More...</a><br /></td></tr>
<tr class="separator:a116aab0639f1fd05524f06f25a0eb533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8698cebf5ea96d81e3c1c9821a26f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a5b8698cebf5ea96d81e3c1c9821a26f2">CombineIdenticalVertices</a> (bool bIgnoreVertexNormals=false, bool bIgnoreTextureCoordinates=false)</td></tr>
<tr class="separator:a5b8698cebf5ea96d81e3c1c9821a26f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1590fcf5ed72349c51fc2da3c5a5e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aef1590fcf5ed72349c51fc2da3c5a5e6">Compact</a> ()</td></tr>
<tr class="separator:aef1590fcf5ed72349c51fc2da3c5a5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f00ddce6c37d48f37bf2b34cf89ead"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a75f00ddce6c37d48f37bf2b34cf89ead">ComputeFaceNormal</a> (int)</td></tr>
<tr class="memdesc:a75f00ddce6c37d48f37bf2b34cf89ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">computes face normal of indexed face  <a href="class_o_n___mesh.html#a75f00ddce6c37d48f37bf2b34cf89ead">More...</a><br /></td></tr>
<tr class="separator:a75f00ddce6c37d48f37bf2b34cf89ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1b2cfc861f0d4eb50c8371948cab1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a1e1b2cfc861f0d4eb50c8371948cab1d">ComputeFaceNormals</a> ()</td></tr>
<tr class="memdesc:a1e1b2cfc861f0d4eb50c8371948cab1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">compute face normals for all faces  <a href="class_o_n___mesh.html#a1e1b2cfc861f0d4eb50c8371948cab1d">More...</a><br /></td></tr>
<tr class="separator:a1e1b2cfc861f0d4eb50c8371948cab1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800e2ba9bc8d9707d412acd265790851"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a800e2ba9bc8d9707d412acd265790851">ComputeVertexNormals</a> ()</td></tr>
<tr class="memdesc:a800e2ba9bc8d9707d412acd265790851"><td class="mdescLeft">&#160;</td><td class="mdescRight">uses face normals to cook up a vertex normal  <a href="class_o_n___mesh.html#a800e2ba9bc8d9707d412acd265790851">More...</a><br /></td></tr>
<tr class="separator:a800e2ba9bc8d9707d412acd265790851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00a4a72333babfcd3ceff79cfc8ffa4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae00a4a72333babfcd3ceff79cfc8ffa4">ConvertNonPlanarQuadsToTriangles</a> (double planar_tolerance, double angle_tolerance_radians, unsigned int split_method)</td></tr>
<tr class="separator:ae00a4a72333babfcd3ceff79cfc8ffa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0529b451509d9f1ce30e57b0e54b1fda"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a0529b451509d9f1ce30e57b0e54b1fda">ConvertNonPlanarQuadsToTriangles</a> (double planar_tolerance, double angle_tolerance_radians, unsigned int split_method, bool bDeleteNgonsContainingSplitQuads)</td></tr>
<tr class="separator:a0529b451509d9f1ce30e57b0e54b1fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accc2de02378ef1ce0b3f4fd71f186b7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#accc2de02378ef1ce0b3f4fd71f186b7a">ConvertQuadsToTriangles</a> ()</td></tr>
<tr class="separator:accc2de02378ef1ce0b3f4fd71f186b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a728e81940561392fbcc5d6def5c53abc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a728e81940561392fbcc5d6def5c53abc">ConvertTrianglesToQuads</a> (double angle_tol_radians, double min_diagonal_length_ratio)</td></tr>
<tr class="separator:a728e81940561392fbcc5d6def5c53abc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0bcbdf815fb79bfe45a077a46a46357"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af0bcbdf815fb79bfe45a077a46a46357">CopyComponents</a> (const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count, class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *destination_mesh) const</td></tr>
<tr class="separator:af0bcbdf815fb79bfe45a077a46a46357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc45502751438b2926f116b222f0a33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a7cc45502751438b2926f116b222f0a33">CopyComponents</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;ci_list, class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *destination_mesh) const</td></tr>
<tr class="separator:a7cc45502751438b2926f116b222f0a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce044b87f7573b019c215063fe85e93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#afce044b87f7573b019c215063fe85e93">CountQuads</a> ()</td></tr>
<tr class="separator:afce044b87f7573b019c215063fe85e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03df67e386dc849f2c3badf9280da0c6"><td class="memItemLeft" align="right" valign="top">const unsigned int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a03df67e386dc849f2c3badf9280da0c6">CreateNgonMap</a> ()</td></tr>
<tr class="separator:a03df67e386dc849f2c3badf9280da0c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43669dda3f5ca8bd9151487fa915c60e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a43669dda3f5ca8bd9151487fa915c60e">CreateNgonMap</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;map) const</td></tr>
<tr class="separator:a43669dda3f5ca8bd9151487fa915c60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6c90461ff94aa261d94fb4f6aaa160"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a9e6c90461ff94aa261d94fb4f6aaa160">CreateNgonMap</a> (unsigned int *ngon_map) const</td></tr>
<tr class="separator:a9e6c90461ff94aa261d94fb4f6aaa160"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4bc3aabd5155e282910738daa1b3c62"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___mesh_partition.html">ON_MeshPartition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac4bc3aabd5155e282910738daa1b3c62">CreatePartition</a> (int, int)</td></tr>
<tr class="separator:ac4bc3aabd5155e282910738daa1b3c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a105368d48f28f2c7def8eafc7d2e7e20"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a105368d48f28f2c7def8eafc7d2e7e20">CullClashingFaces</a> (int what_to_cull)</td></tr>
<tr class="separator:a105368d48f28f2c7def8eafc7d2e7e20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285f54befb68149d3a23ac29fc1042a7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a285f54befb68149d3a23ac29fc1042a7">CullDegenerateFaces</a> ()</td></tr>
<tr class="memdesc:a285f54befb68149d3a23ac29fc1042a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of degenerate faces  <a href="class_o_n___mesh.html#a285f54befb68149d3a23ac29fc1042a7">More...</a><br /></td></tr>
<tr class="separator:a285f54befb68149d3a23ac29fc1042a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95987b3668ca3c6958426adb4d3268ec"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a95987b3668ca3c6958426adb4d3268ec">CullDegenerates</a> ()</td></tr>
<tr class="separator:a95987b3668ca3c6958426adb4d3268ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a28c1db5796622470a0d8cd4c8d4f7c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a2a28c1db5796622470a0d8cd4c8d4f7c">CullUnusedVertices</a> ()</td></tr>
<tr class="memdesc:a2a28c1db5796622470a0d8cd4c8d4f7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of culled vertices  <a href="class_o_n___mesh.html#a2a28c1db5796622470a0d8cd4c8d4f7c">More...</a><br /></td></tr>
<tr class="separator:a2a28c1db5796622470a0d8cd4c8d4f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f71b595855073034c29bd74c15305f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#gaea03c6f4bab106103ada72c766f7fe5c">ON__UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad7f71b595855073034c29bd74c15305f">DataCRC</a> (<a class="el" href="group__open_n_u_r_b_s.html#gaea03c6f4bab106103ada72c766f7fe5c">ON__UINT32</a> current_remainder) const override</td></tr>
<tr class="memdesc:ad7f71b595855073034c29bd74c15305f"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___object.html#af51d5fcec9379ad9b7a56ac4dfc9a8b2">ON_Object::DataCRC</a> override  <a href="class_o_n___mesh.html#ad7f71b595855073034c29bd74c15305f">More...</a><br /></td></tr>
<tr class="separator:ad7f71b595855073034c29bd74c15305f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7c5789e6d14e09a8255134fc5e390d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a9b7c5789e6d14e09a8255134fc5e390d">DeallocateNgon</a> (<a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *ngon)</td></tr>
<tr class="separator:a9b7c5789e6d14e09a8255134fc5e390d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d7dd764beb453d7b613a2bf090a1b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a11d7dd764beb453d7b613a2bf090a1b7">DeleteComponent</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> ci)</td></tr>
<tr class="separator:a11d7dd764beb453d7b613a2bf090a1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ee1525a489f197b6a1a2cb9d0f439e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a57ee1525a489f197b6a1a2cb9d0f439e">DeleteComponents</a> (const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count) override</td></tr>
<tr class="separator:a57ee1525a489f197b6a1a2cb9d0f439e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b28034b4aeb5425af27969919eea63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a24b28034b4aeb5425af27969919eea63">DeleteComponents</a> (const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count, bool bIgnoreInvalidComponents, bool bRemoveDegenerateFaces, bool bRemoveUnusedVertices, bool bRemoveEmptyNgons)</td></tr>
<tr class="separator:a24b28034b4aeb5425af27969919eea63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c08746dc896cf1de9be6087f74e8c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae9c08746dc896cf1de9be6087f74e8c3">DeleteComponents</a> (const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count, bool bIgnoreInvalidComponents, bool bRemoveDegenerateFaces, bool bRemoveUnusedVertices, bool bRemoveEmptyNgons, unsigned int *faceMap)</td></tr>
<tr class="separator:ae9c08746dc896cf1de9be6087f74e8c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae0206ba06af5b6a2895582caad8ca0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a8ae0206ba06af5b6a2895582caad8ca0">DeleteComponents</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;ci_list)</td></tr>
<tr class="separator:a8ae0206ba06af5b6a2895582caad8ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0108f56f056f60f2918924e1152103"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#afc0108f56f056f60f2918924e1152103">DeleteFace</a> (int meshfi)</td></tr>
<tr class="separator:afc0108f56f056f60f2918924e1152103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfff4b2fada773a65109d43fc1c42b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#afcfff4b2fada773a65109d43fc1c42b9">DeleteMeshParameters</a> ()</td></tr>
<tr class="separator:afcfff4b2fada773a65109d43fc1c42b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8ff2bad015852719a2517f10967cc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#add8ff2bad015852719a2517f10967cc0">Destroy</a> ()</td></tr>
<tr class="separator:add8ff2bad015852719a2517f10967cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878de28d1068302a28553258ec2e69f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a878de28d1068302a28553258ec2e69f4">DestroyDoublePrecisionVertices</a> ()</td></tr>
<tr class="separator:a878de28d1068302a28553258ec2e69f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af769ba8c3f555d132cf0714cd26bcd5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af769ba8c3f555d132cf0714cd26bcd5e">DestroyHiddenVertexArray</a> ()</td></tr>
<tr class="separator:af769ba8c3f555d132cf0714cd26bcd5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b1905e2cc313ea6c336a1ecc761e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aa78b1905e2cc313ea6c336a1ecc761e7">DestroyPartition</a> ()</td></tr>
<tr class="separator:aa78b1905e2cc313ea6c336a1ecc761e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7214a8028954b0a820e64e9b8a61854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae7214a8028954b0a820e64e9b8a61854">DestroyRuntimeCache</a> (bool bDelete=true) override</td></tr>
<tr class="memdesc:ae7214a8028954b0a820e64e9b8a61854"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___object.html#af8435c33ab53af41c22dac75e8917569">ON_Object::DestroyRuntimeCache</a> override  <a href="class_o_n___mesh.html#ae7214a8028954b0a820e64e9b8a61854">More...</a><br /></td></tr>
<tr class="separator:ae7214a8028954b0a820e64e9b8a61854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad638bb8cfee148bb00f5224fa2d0beb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad638bb8cfee148bb00f5224fa2d0beb9">DestroyTopology</a> ()</td></tr>
<tr class="separator:ad638bb8cfee148bb00f5224fa2d0beb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b83087a2c0691ef81d44e75ccbe4da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a58b83087a2c0691ef81d44e75ccbe4da">DestroyTree</a> (bool bDeleteTree=true)</td></tr>
<tr class="separator:a58b83087a2c0691ef81d44e75ccbe4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa029aafe4a524b31a986fa46374d6c5b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aa029aafe4a524b31a986fa46374d6c5b">Dimension</a> () const override</td></tr>
<tr class="memdesc:aa029aafe4a524b31a986fa46374d6c5b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___geometry.html">ON_Geometry</a> overrides.  <a href="class_o_n___mesh.html#aa029aafe4a524b31a986fa46374d6c5b">More...</a><br /></td></tr>
<tr class="separator:aa029aafe4a524b31a986fa46374d6c5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e376f80851554edae4fa183347124a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac4e376f80851554edae4fa183347124a">DissolveOrDelete</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;ci_list)</td></tr>
<tr class="separator:ac4e376f80851554edae4fa183347124a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b101813d31f261ef0a6ca950cfcf14a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a1b101813d31f261ef0a6ca950cfcf14a">DoublePrecisionVertices</a> ()</td></tr>
<tr class="memdesc:a1b101813d31f261ef0a6ca950cfcf14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation - mesh geometry.  <a href="class_o_n___mesh.html#a1b101813d31f261ef0a6ca950cfcf14a">More...</a><br /></td></tr>
<tr class="separator:a1b101813d31f261ef0a6ca950cfcf14a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce02d0446f6a17f2c4eddbd15b4d636"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#afce02d0446f6a17f2c4eddbd15b4d636">DoublePrecisionVertices</a> () const</td></tr>
<tr class="separator:afce02d0446f6a17f2c4eddbd15b4d636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9621f32fa9123a6feae820085d14a02d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a9621f32fa9123a6feae820085d14a02d">Dump</a> (<a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;) const override</td></tr>
<tr class="memdesc:a9621f32fa9123a6feae820085d14a02d"><td class="mdescLeft">&#160;</td><td class="mdescRight">for debugging  <a href="class_o_n___mesh.html#a9621f32fa9123a6feae820085d14a02d">More...</a><br /></td></tr>
<tr class="separator:a9621f32fa9123a6feae820085d14a02d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae1553b8fc5e622e1115dee760987f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3ae1553b8fc5e622e1115dee760987f3">DuplicateBorder</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; &amp;polylines, bool joinOverUnweldedVertices) const</td></tr>
<tr class="separator:a3ae1553b8fc5e622e1115dee760987f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f52a5d5c1b13b9b776fe72a0b7d30d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a7f52a5d5c1b13b9b776fe72a0b7d30d7">DuplicateFace</a> (int face_index, <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *mesh) const</td></tr>
<tr class="separator:a7f52a5d5c1b13b9b776fe72a0b7d30d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaee0bc734648a07a275f51005596d69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#abaee0bc734648a07a275f51005596d69">EmergencyDestroy</a> ()</td></tr>
<tr class="separator:abaee0bc734648a07a275f51005596d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1278d2924ed75f4a4fc3839cb95933ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a1278d2924ed75f4a4fc3839cb95933ea">EvaluateMeshGeometry</a> (const <a class="el" href="class_o_n___surface.html">ON_Surface</a> &amp;)</td></tr>
<tr class="separator:a1278d2924ed75f4a4fc3839cb95933ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1679331cf0fc060385912d1aaf471bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad1679331cf0fc060385912d1aaf471bb">EvaluatePoint</a> (const class <a class="el" href="class_o_n___obj_ref.html">ON_ObjRef</a> &amp;objref, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;P) const override</td></tr>
<tr class="memdesc:ad1679331cf0fc060385912d1aaf471bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> override  <a href="class_o_n___mesh.html#ad1679331cf0fc060385912d1aaf471bb">More...</a><br /></td></tr>
<tr class="separator:ad1679331cf0fc060385912d1aaf471bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbee1f8aea211a5c2b78932ce6d540e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#afbee1f8aea211a5c2b78932ce6d540e0">FaceCount</a> () const</td></tr>
<tr class="separator:afbee1f8aea211a5c2b78932ce6d540e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a9a74ac467f28d007b8191bea463fed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a8a9a74ac467f28d007b8191bea463fed">FaceIsHidden</a> (int meshvi) const</td></tr>
<tr class="separator:a8a9a74ac467f28d007b8191bea463fed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850c12c7e0efeb7acd5dbe3256c74b09"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a850c12c7e0efeb7acd5dbe3256c74b09">FaceUnsignedCount</a> () const</td></tr>
<tr class="separator:a850c12c7e0efeb7acd5dbe3256c74b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dba1564679d8fd692ace1bdda0462f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a6dba1564679d8fd692ace1bdda0462f6">Flip</a> ()</td></tr>
<tr class="memdesc:a6dba1564679d8fd692ace1bdda0462f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses face orientations and flips vertex and face normals  <a href="class_o_n___mesh.html#a6dba1564679d8fd692ace1bdda0462f6">More...</a><br /></td></tr>
<tr class="separator:a6dba1564679d8fd692ace1bdda0462f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a422d77aff314fb1f2b8e795e0fa1a206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a422d77aff314fb1f2b8e795e0fa1a206">FlipFaceNormals</a> ()</td></tr>
<tr class="memdesc:a422d77aff314fb1f2b8e795e0fa1a206"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses face normals  <a href="class_o_n___mesh.html#a422d77aff314fb1f2b8e795e0fa1a206">More...</a><br /></td></tr>
<tr class="separator:a422d77aff314fb1f2b8e795e0fa1a206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28800ae891830cc60f1bd86f3f2f5f29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a28800ae891830cc60f1bd86f3f2f5f29">FlipFaceOrientation</a> ()</td></tr>
<tr class="memdesc:a28800ae891830cc60f1bd86f3f2f5f29"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses face orientation (does nothing to normals)  <a href="class_o_n___mesh.html#a28800ae891830cc60f1bd86f3f2f5f29">More...</a><br /></td></tr>
<tr class="separator:a28800ae891830cc60f1bd86f3f2f5f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e578752dcc1c037e3c3c5c9973fc8d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a7e578752dcc1c037e3c3c5c9973fc8d8">FlipNgonOrientation</a> ()</td></tr>
<tr class="memdesc:a7e578752dcc1c037e3c3c5c9973fc8d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses ngon boundary direction  <a href="class_o_n___mesh.html#a7e578752dcc1c037e3c3c5c9973fc8d8">More...</a><br /></td></tr>
<tr class="separator:a7e578752dcc1c037e3c3c5c9973fc8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1981fd37dbe338ada348915342b1d99d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a1981fd37dbe338ada348915342b1d99d">FlipVertexNormals</a> ()</td></tr>
<tr class="memdesc:a1981fd37dbe338ada348915342b1d99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses vertex normals  <a href="class_o_n___mesh.html#a1981fd37dbe338ada348915342b1d99d">More...</a><br /></td></tr>
<tr class="separator:a1981fd37dbe338ada348915342b1d99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c41bb93f38981333f13fd777fb4e50a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a9c41bb93f38981333f13fd777fb4e50a">GetBBox</a> (double *boxmin, double *boxmax, bool bGrowBox=false) const override</td></tr>
<tr class="memdesc:a9c41bb93f38981333f13fd777fb4e50a"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> GetBBox override <br  />
  <a href="class_o_n___mesh.html#a9c41bb93f38981333f13fd777fb4e50a">More...</a><br /></td></tr>
<tr class="separator:a9c41bb93f38981333f13fd777fb4e50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5405260e85535484e4469b7590d2cdc7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a5405260e85535484e4469b7590d2cdc7">GetClashingFacePairs</a> (int max_pair_count, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;clashing_pairs) const</td></tr>
<tr class="separator:a5405260e85535484e4469b7590d2cdc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8243e8139c5e818bf7a30aa3737e66a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ab8243e8139c5e818bf7a30aa3737e66a">GetClosestPoint</a> (const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;P, class <a class="el" href="class_o_n___m_e_s_h___p_o_i_n_t.html">ON_MESH_POINT</a> *Q, double maximum_distance=0.0) const</td></tr>
<tr class="separator:ab8243e8139c5e818bf7a30aa3737e66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a197536fdd69e119ee89d1f787a9dfcf8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a197536fdd69e119ee89d1f787a9dfcf8">GetConnectedComponents</a> (bool bUseVertexConnections, bool bTopologicalConnections, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;facet_component_labels) const</td></tr>
<tr class="separator:a197536fdd69e119ee89d1f787a9dfcf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b297eb77352e4c82d664ee2ea3cb2a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a46b297eb77352e4c82d664ee2ea3cb2a">GetConnectedComponents</a> (bool bUseVertexConnections, bool bTopologicalConnections, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; *components) const</td></tr>
<tr class="separator:a46b297eb77352e4c82d664ee2ea3cb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a692b6ca07ffdcd0ed8b32e4b270d0ce1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a692b6ca07ffdcd0ed8b32e4b270d0ce1">GetCurvatureStats</a> (<a class="el" href="class_o_n.html#a86bff53cc45eaeb4b4dcd0268b9e1e8f">ON::curvature_style</a>, <a class="el" href="class_o_n___mesh_curvature_stats.html">ON_MeshCurvatureStats</a> &amp;) const</td></tr>
<tr class="separator:a692b6ca07ffdcd0ed8b32e4b270d0ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2bef19d6d37f651c611b75a80b4a8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a4f2bef19d6d37f651c611b75a80b4a8b">GetIntersections</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;withTheseOtherMeshes, double tolerance, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *perforatingResults, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *overlapResults, <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *overlapMeshResult, <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *log, <a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *cancel, <a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *reporter) const</td></tr>
<tr class="separator:a4f2bef19d6d37f651c611b75a80b4a8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c90cb307e886840900b63e91cb74a79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a4c90cb307e886840900b63e91cb74a79">GetIntersections</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;withTheseOtherMeshes, <a class="el" href="class_o_n___mesh_intersection_cache.html">ON_MeshIntersectionCache</a> *cacheForOtherMeshes, double tolerance, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *perforatingResults, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *overlapResults, <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *overlapMeshResult, <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *log, <a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *cancel, <a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *reporter) const</td></tr>
<tr class="separator:a4c90cb307e886840900b63e91cb74a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973789f53a04031d403389b952cb6154"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a973789f53a04031d403389b952cb6154">GetMeshEdgeList</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;edge_list, bool bLookForNgonInteriorEdges, bool bOmitHiddenEdges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;ci_meshtop_edge_map, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;ci_meshtop_vertex_map, unsigned int edge_type_partition[6]) const</td></tr>
<tr class="separator:a973789f53a04031d403389b952cb6154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662c3c3cbbd3a669ac3651413fb2b303"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a662c3c3cbbd3a669ac3651413fb2b303">GetMeshEdgeList</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;edge_list, bool bLookForNgonInteriorEdges, bool bOmitHiddenEdges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;ci_meshtop_edge_map, unsigned int edge_type_partition[6]) const</td></tr>
<tr class="separator:a662c3c3cbbd3a669ac3651413fb2b303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c5293cbd867654e2219ecef6c1076e6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a1c5293cbd867654e2219ecef6c1076e6">GetMeshEdgeList</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;edge_list, bool bLookForNgonInteriorEdges, bool bOmitHiddenEdges, unsigned int edge_type_partition[6]) const</td></tr>
<tr class="separator:a1c5293cbd867654e2219ecef6c1076e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a9cc4d7caba3bce428620870c97eab"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae3a9cc4d7caba3bce428620870c97eab">GetMeshEdgeList</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;edge_list, bool bLookForNgonInteriorEdges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;ci_meshtop_edge_map, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;ci_meshtop_vertex_map, unsigned int edge_type_partition[6]) const</td></tr>
<tr class="separator:ae3a9cc4d7caba3bce428620870c97eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02d62461c66d3315b5da5a4b18716cf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af02d62461c66d3315b5da5a4b18716cf">GetMeshEdgeList</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;edge_list, bool bLookForNgonInteriorEdges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;ci_meshtop_edge_map, unsigned int edge_type_partition[6]) const</td></tr>
<tr class="separator:af02d62461c66d3315b5da5a4b18716cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded8849a0a64d357855af23a2bd6155d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aded8849a0a64d357855af23a2bd6155d">GetMeshEdgeList</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;edge_list, bool bLookForNgonInteriorEdges, unsigned int edge_type_partition[6]) const</td></tr>
<tr class="separator:aded8849a0a64d357855af23a2bd6155d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2631a57074d47d73a086470574dd1f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a4a2631a57074d47d73a086470574dd1f">GetMeshEdges</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;edges) const</td></tr>
<tr class="separator:a4a2631a57074d47d73a086470574dd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba7721378a6841ae06af7614f71511f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a4ba7721378a6841ae06af7614f71511f">GetMeshFaceSideList</a> (const unsigned int *Vid, class <a class="el" href="class_o_n___mesh_face_side.html">ON_MeshFaceSide</a> *&amp;sides) const</td></tr>
<tr class="separator:a4ba7721378a6841ae06af7614f71511f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805b093e3860a05c0b8c74b07f2ae60b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a805b093e3860a05c0b8c74b07f2ae60b">GetMeshNakedEdgeList</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;naked_edge_list, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; *ci_meshtop_vertex_map=nullptr, bool bLookForNgonInteriorEdges=false) const</td></tr>
<tr class="separator:a805b093e3860a05c0b8c74b07f2ae60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b1b8f8504f4842c9ada4a49e715033a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3b1b8f8504f4842c9ada4a49e715033a">GetNgonBoundaryPoints</a> (const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *ngon, bool bAppendStartPoint, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *ngon_boundary_points) const</td></tr>
<tr class="separator:a3b1b8f8504f4842c9ada4a49e715033a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac770d4e7641dafddb357881012b49c53"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac770d4e7641dafddb357881012b49c53">GetNgonBoundaryPoints</a> (const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *ngon, bool bAppendStartPoint, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;ngon_boundary_points) const</td></tr>
<tr class="separator:ac770d4e7641dafddb357881012b49c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6edacf07064f4635d781dd5252702639"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a6edacf07064f4635d781dd5252702639">GetNgonOuterBoundary</a> (unsigned int ngon_fi_count, const unsigned int *ngon_fi, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;ngon_vi) const</td></tr>
<tr class="separator:a6edacf07064f4635d781dd5252702639"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22229d8f7d94c1e74a846c7c63ab6059"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a22229d8f7d94c1e74a846c7c63ab6059">GetSelfIntersections</a> (double tolerance, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *perforatingResults, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *overlapResults, <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *overlapMeshResult, <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *log, <a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *cancel, <a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *reporter) const</td></tr>
<tr class="separator:a22229d8f7d94c1e74a846c7c63ab6059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0542ef954af83954f70d55b37455d03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac0542ef954af83954f70d55b37455d03">GetSilhouette</a> (const <a class="el" href="class_o_n___silhouette_parameters.html">ON_SilhouetteParameters</a> parameters, const <a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a> *clipping_planes, size_t clipping_plane_count, <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___s_i_l___e_v_e_n_t.html">ON_SIL_EVENT</a> &gt; &amp;silhouettes, <a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *progress, <a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *terminator) const</td></tr>
<tr class="separator:ac0542ef954af83954f70d55b37455d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63e6ec48221680b4eea2344efb07013"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af63e6ec48221680b4eea2344efb07013">GetTightBoundingBox</a> (class <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;tight_bbox, bool bGrowBox=false, const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *xform=nullptr) const override</td></tr>
<tr class="memdesc:af63e6ec48221680b4eea2344efb07013"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> GetTightBoundingBox override <br  />
  <a href="class_o_n___mesh.html#af63e6ec48221680b4eea2344efb07013">More...</a><br /></td></tr>
<tr class="separator:af63e6ec48221680b4eea2344efb07013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc969ccace58c665344d45db4515286"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#adcc969ccace58c665344d45db4515286">GetTightBoundingBox</a> (<a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;tight_bbox, bool bGrowBox, const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a> &gt; &amp;clipping_planes, const <a class="el" href="class_o_n___xform.html">ON_Xform</a> *xform=nullptr) const</td></tr>
<tr class="separator:adcc969ccace58c665344d45db4515286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7696c1cc1632aeaee8966d392814e9d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a7696c1cc1632aeaee8966d392814e9d7">GetVertexEdges</a> (int vcount, const int *vertex_index, bool bNoDuplicates, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;edges) const</td></tr>
<tr class="separator:a7696c1cc1632aeaee8966d392814e9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5859f1a15ccad8f68ccdee830b43ab03"><td class="memItemLeft" align="right" valign="top">unsigned int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a5859f1a15ccad8f68ccdee830b43ab03">GetVertexLocationIds</a> (unsigned int first_vid, unsigned int *Vid, unsigned int *Vindex) const</td></tr>
<tr class="separator:a5859f1a15ccad8f68ccdee830b43ab03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae985f186709c0e824170506627469412"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae985f186709c0e824170506627469412">HasCachedTextureCoordinates</a> () const</td></tr>
<tr class="separator:ae985f186709c0e824170506627469412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fddeadd7c48d8c0c2060fffaf9f8c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a01fddeadd7c48d8c0c2060fffaf9f8c5">HasDoublePrecisionVertices</a> () const</td></tr>
<tr class="separator:a01fddeadd7c48d8c0c2060fffaf9f8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f0c02892c0584a53f665b22b1967e6a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a4f0c02892c0584a53f665b22b1967e6a">HasFaceNormals</a> () const</td></tr>
<tr class="separator:a4f0c02892c0584a53f665b22b1967e6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e263be3e64bcf04bcf6151d1f93f75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad4e263be3e64bcf04bcf6151d1f93f75">HasMeshTopology</a> () const</td></tr>
<tr class="separator:ad4e263be3e64bcf04bcf6151d1f93f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669b054bd1a6ec07a73ed983c226176c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a669b054bd1a6ec07a73ed983c226176c">HasNgons</a> () const</td></tr>
<tr class="separator:a669b054bd1a6ec07a73ed983c226176c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036aa49ec05cb293126bf27445f245f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a036aa49ec05cb293126bf27445f245f5">HasPackedTextureRegion</a> () const</td></tr>
<tr class="separator:a036aa49ec05cb293126bf27445f245f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66dc2d1bd14a4cb90d18916aae1aed65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a66dc2d1bd14a4cb90d18916aae1aed65">HasPrincipalCurvatures</a> () const</td></tr>
<tr class="separator:a66dc2d1bd14a4cb90d18916aae1aed65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761a8bb237b6b5b8d4a4b3433f44b365"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a761a8bb237b6b5b8d4a4b3433f44b365">HasSinglePrecisionVertices</a> () const</td></tr>
<tr class="separator:a761a8bb237b6b5b8d4a4b3433f44b365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930cd9676f76c8a4502472590529eb5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a930cd9676f76c8a4502472590529eb5a">HasSurfaceParameters</a> () const</td></tr>
<tr class="separator:a930cd9676f76c8a4502472590529eb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caf4d03d31476b0b09763023d44e8a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a6caf4d03d31476b0b09763023d44e8a9">HasSynchronizedDoubleAndSinglePrecisionVertices</a> () const</td></tr>
<tr class="separator:a6caf4d03d31476b0b09763023d44e8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba88cd8af101d94fecdf3790a9b23e5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aba88cd8af101d94fecdf3790a9b23e5e">HasTextureCoordinates</a> () const</td></tr>
<tr class="separator:aba88cd8af101d94fecdf3790a9b23e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd2df640918669255c222cac7d360332"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#acd2df640918669255c222cac7d360332">HasVertexColors</a> () const</td></tr>
<tr class="separator:acd2df640918669255c222cac7d360332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7f35cdc59fd53401d137492161fcd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a8f7f35cdc59fd53401d137492161fcd2">HasVertexNormals</a> () const</td></tr>
<tr class="memdesc:a8f7f35cdc59fd53401d137492161fcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">normals at vertices  <a href="class_o_n___mesh.html#a8f7f35cdc59fd53401d137492161fcd2">More...</a><br /></td></tr>
<tr class="separator:a8f7f35cdc59fd53401d137492161fcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56a4e9072e14c1e8cd21acb6ba6bac4"><td class="memItemLeft" align="right" valign="top">const bool *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ab56a4e9072e14c1e8cd21acb6ba6bac4">HiddenVertexArray</a> () const</td></tr>
<tr class="separator:ab56a4e9072e14c1e8cd21acb6ba6bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8e01a4cff0e47dccb959e14a2c9aa4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#abb8e01a4cff0e47dccb959e14a2c9aa4">HiddenVertexCount</a> () const</td></tr>
<tr class="separator:abb8e01a4cff0e47dccb959e14a2c9aa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64719ca819bfb9e1beb541176445bc96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a64719ca819bfb9e1beb541176445bc96">InsertNgon</a> (unsigned int ngon_index, const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *ngon)</td></tr>
<tr class="separator:a64719ca819bfb9e1beb541176445bc96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edfe4badff618e7fdbf16f0e20d538a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a8edfe4badff618e7fdbf16f0e20d538a">IntersectMesh</a> (const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;meshB, <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___m_m_x___p_o_i_n_t.html">ON_MMX_POINT</a> &gt; &gt; &amp;x, double intersection_tolerance=0.0, double overlap_tolerance=0.0) const</td></tr>
<tr class="separator:a8edfe4badff618e7fdbf16f0e20d538a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fe11e9cdbc9e47c986011d408e9ebb1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a5fe11e9cdbc9e47c986011d408e9ebb1">IntersectMesh</a> (const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;meshB, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___line.html">ON_Line</a> &gt; &amp;lines) const</td></tr>
<tr class="separator:a5fe11e9cdbc9e47c986011d408e9ebb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1870824b2eb5da0889fc382488252af"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aa1870824b2eb5da0889fc382488252af">IntersectPlane</a> (<a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a> plane_equation, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___line.html">ON_Line</a> &gt; &amp;lines) const</td></tr>
<tr class="separator:aa1870824b2eb5da0889fc382488252af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba8065a1d1dd17ac978676c2bc19113d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aba8065a1d1dd17ac978676c2bc19113d">InvalidateBoundingBoxes</a> ()</td></tr>
<tr class="memdesc:aba8065a1d1dd17ac978676c2bc19113d"><td class="mdescLeft">&#160;</td><td class="mdescRight">directly manipulating the m_T[] array.  <a href="class_o_n___mesh.html#aba8065a1d1dd17ac978676c2bc19113d">More...</a><br /></td></tr>
<tr class="separator:aba8065a1d1dd17ac978676c2bc19113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715399127e4605246faecd616731a5c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a715399127e4605246faecd616731a5c8">InvalidateCurvatureStats</a> ()</td></tr>
<tr class="memdesc:a715399127e4605246faecd616731a5c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">directly manipulating the m_T[] array.  <a href="class_o_n___mesh.html#a715399127e4605246faecd616731a5c8">More...</a><br /></td></tr>
<tr class="separator:a715399127e4605246faecd616731a5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76a7b8674f110f83757069a119ff29c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a76a7b8674f110f83757069a119ff29c0">InvalidateTextureCoordinateBoundingBox</a> ()</td></tr>
<tr class="memdesc:a76a7b8674f110f83757069a119ff29c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">directly manipulating the m_N[] array.  <a href="class_o_n___mesh.html#a76a7b8674f110f83757069a119ff29c0">More...</a><br /></td></tr>
<tr class="separator:a76a7b8674f110f83757069a119ff29c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52717d2c07df6a6e262c8428f06d3ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a52717d2c07df6a6e262c8428f06d3ac7">InvalidateVertexBoundingBox</a> ()</td></tr>
<tr class="separator:a52717d2c07df6a6e262c8428f06d3ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af086160efaa29517dc83f431c7dc1a5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af086160efaa29517dc83f431c7dc1a5c">InvalidateVertexNormalBoundingBox</a> ()</td></tr>
<tr class="memdesc:af086160efaa29517dc83f431c7dc1a5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">directly manipulating the m_V[] array.  <a href="class_o_n___mesh.html#af086160efaa29517dc83f431c7dc1a5c">More...</a><br /></td></tr>
<tr class="separator:af086160efaa29517dc83f431c7dc1a5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b4f6fc2866a0fdc6d64713d97d4b1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a749b4f6fc2866a0fdc6d64713d97d4b1">InvalidFaceCount</a> () const</td></tr>
<tr class="memdesc:a749b4f6fc2866a0fdc6d64713d97d4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of face that have invalid m_vi[] values.  <a href="class_o_n___mesh.html#a749b4f6fc2866a0fdc6d64713d97d4b1">More...</a><br /></td></tr>
<tr class="separator:a749b4f6fc2866a0fdc6d64713d97d4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028ab06bfe084fb116e101f91f82fa7e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a028ab06bfe084fb116e101f91f82fa7e">IsClosed</a> () const</td></tr>
<tr class="separator:a028ab06bfe084fb116e101f91f82fa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09cf3edf84c5022dc5954e0f087d8930"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a09cf3edf84c5022dc5954e0f087d8930">IsCorrupt</a> (bool bRepair, bool bSilentError, class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *text_log) const</td></tr>
<tr class="separator:a09cf3edf84c5022dc5954e0f087d8930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b29dad1c91ed6b2d2993384dfd2551b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a9b29dad1c91ed6b2d2993384dfd2551b">IsDeformable</a> () const override</td></tr>
<tr class="memdesc:a9b29dad1c91ed6b2d2993384dfd2551b"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___geometry.html#af156cd098b9e68fab5f32e76b1e274e2">ON_Geometry::IsDeformable()</a> override  <a href="class_o_n___mesh.html#a9b29dad1c91ed6b2d2993384dfd2551b">More...</a><br /></td></tr>
<tr class="separator:a9b29dad1c91ed6b2d2993384dfd2551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7cc8b39c510324b756eb2ed20ed88b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a7f7cc8b39c510324b756eb2ed20ed88b">IsEmpty</a> () const</td></tr>
<tr class="separator:a7f7cc8b39c510324b756eb2ed20ed88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac09c9dbc6da5c1124b3ebd60c645a526"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac09c9dbc6da5c1124b3ebd60c645a526">IsManifold</a> () const</td></tr>
<tr class="separator:ac09c9dbc6da5c1124b3ebd60c645a526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af643d18e1e66ed8a2e9542fa768010"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3af643d18e1e66ed8a2e9542fa768010">IsManifold</a> (bool bTopologicalTest, bool *pbIsOriented=nullptr, bool *pbHasBoundary=nullptr) const</td></tr>
<tr class="separator:a3af643d18e1e66ed8a2e9542fa768010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38c8cfd7fc32bddf1aa2ea68204fcbc6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a38c8cfd7fc32bddf1aa2ea68204fcbc6">IsMorphable</a> () const override</td></tr>
<tr class="memdesc:a38c8cfd7fc32bddf1aa2ea68204fcbc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> override  <a href="class_o_n___mesh.html#a38c8cfd7fc32bddf1aa2ea68204fcbc6">More...</a><br /></td></tr>
<tr class="separator:a38c8cfd7fc32bddf1aa2ea68204fcbc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890dbca9b3dd42c2744927091a9cad4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a890dbca9b3dd42c2744927091a9cad4f">IsNotEmpty</a> () const</td></tr>
<tr class="separator:a890dbca9b3dd42c2744927091a9cad4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cad2bd54873b1a24b9a0d030fd3fc65"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a6cad2bd54873b1a24b9a0d030fd3fc65">IsOriented</a> () const</td></tr>
<tr class="separator:a6cad2bd54873b1a24b9a0d030fd3fc65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f89b45f3e01a4ed5b0c3f8378e6567"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a47f89b45f3e01a4ed5b0c3f8378e6567">IsPointInside</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> test_point, double tolerance, bool bStrictlyInside) const</td></tr>
<tr class="separator:a47f89b45f3e01a4ed5b0c3f8378e6567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064f4ce98ffdba6c40d6eec8daf8cf1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a064f4ce98ffdba6c40d6eec8daf8cf1d">IsSolid</a> () const</td></tr>
<tr class="separator:a064f4ce98ffdba6c40d6eec8daf8cf1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45266824480cc73f6ff520c480a86ed4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a45266824480cc73f6ff520c480a86ed4">IsSwappableEdge</a> (int topei)</td></tr>
<tr class="separator:a45266824480cc73f6ff520c480a86ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08acfd86d40eb163156a7329fb3c52cc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a08acfd86d40eb163156a7329fb3c52cc">IsValid</a> (class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *text_log=nullptr) const override</td></tr>
<tr class="separator:a08acfd86d40eb163156a7329fb3c52cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39eafead00993bff9106317ddaae5423"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a39eafead00993bff9106317ddaae5423">IsValidMeshComponentIndex</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> ci) const</td></tr>
<tr class="separator:a39eafead00993bff9106317ddaae5423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87f1bfa6914e2ccee90849f2111bcb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac87f1bfa6914e2ccee90849f2111bcb3">IsValidNewNgonInformation</a> (unsigned int Vcount, const unsigned int *ngon_vi, unsigned int Fcount, const unsigned int *ngon_fi) const</td></tr>
<tr class="separator:ac87f1bfa6914e2ccee90849f2111bcb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d67491f386ad56d11d091d4a2fa548"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a33d67491f386ad56d11d091d4a2fa548">MakeDeformable</a> () override</td></tr>
<tr class="memdesc:a33d67491f386ad56d11d091d4a2fa548"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___geometry.html#ac3d5cb708edca66a4a6c1992299329a3">ON_Geometry::MakeDeformable()</a> override  <a href="class_o_n___mesh.html#a33d67491f386ad56d11d091d4a2fa548">More...</a><br /></td></tr>
<tr class="separator:a33d67491f386ad56d11d091d4a2fa548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946263df140cb0a25931db03ed015759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a946263df140cb0a25931db03ed015759">MemoryRelocate</a> () override</td></tr>
<tr class="memdesc:a946263df140cb0a25931db03ed015759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override of virtual <a class="el" href="class_o_n___object.html#ae0674ccb79b6333e4b3c8e95ee10dd73">ON_Object::MemoryRelocate</a>.  <a href="class_o_n___mesh.html#a946263df140cb0a25931db03ed015759">More...</a><br /></td></tr>
<tr class="separator:a946263df140cb0a25931db03ed015759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3226b27eca51ba7a97ac8fba12b56b39"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3226b27eca51ba7a97ac8fba12b56b39">MergeFaceSets</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;ci_list)</td></tr>
<tr class="separator:a3226b27eca51ba7a97ac8fba12b56b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa634b516a1c1042d78d19a2c4544f0bd"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___mesh_component_ref.html">ON_MeshComponentRef</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aa634b516a1c1042d78d19a2c4544f0bd">MeshComponent</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> ci) const</td></tr>
<tr class="separator:aa634b516a1c1042d78d19a2c4544f0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8497796652e5421a57823809746239e4"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___mesh_component_ref.html">ON_MeshComponentRef</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a8497796652e5421a57823809746239e4">MeshComponentRef</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> ci) const</td></tr>
<tr class="separator:a8497796652e5421a57823809746239e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d8253d3294a7208e2b4cf96c429352"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___r_tree.html">ON_RTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a77d8253d3294a7208e2b4cf96c429352">MeshFaceTree</a> (bool bCreateIfNoneExists) const</td></tr>
<tr class="separator:a77d8253d3294a7208e2b4cf96c429352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df6c0c5eb97d8f1c13c4d516ade988e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___mesh_parameters.html">ON_MeshParameters</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a4df6c0c5eb97d8f1c13c4d516ade988e">MeshParameters</a> () const</td></tr>
<tr class="separator:a4df6c0c5eb97d8f1c13c4d516ade988e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eba9d343e2e84cebf91bf13bda21f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad4eba9d343e2e84cebf91bf13bda21f8">MeshPart</a> (const <a class="el" href="struct_o_n___mesh_part.html">ON_MeshPart</a> &amp;mesh_part, <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *mesh) const</td></tr>
<tr class="separator:ad4eba9d343e2e84cebf91bf13bda21f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa11d2d4e0926c340dd2a3a0eb304b12c"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___mesh_tree.html">ON_MeshTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aa11d2d4e0926c340dd2a3a0eb304b12c">MeshTree</a> () const</td></tr>
<tr class="separator:aa11d2d4e0926c340dd2a3a0eb304b12c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239c5e5a30b14d756bdcf0bc61bdbcfd"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___mesh_tree.html">ON_MeshTree</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a239c5e5a30b14d756bdcf0bc61bdbcfd">MeshTree</a> (bool bCreateIfNoneExists) const</td></tr>
<tr class="separator:a239c5e5a30b14d756bdcf0bc61bdbcfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d4c3495818778426d2448370c03c94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ab3d4c3495818778426d2448370c03c94">ModifyNgon</a> (unsigned int ngon_index, const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *ngon)</td></tr>
<tr class="separator:ab3d4c3495818778426d2448370c03c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1073baee7566788599b3de47f3d8d0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a1073baee7566788599b3de47f3d8d0dc">ModifyNgon</a> (unsigned int ngon_index, unsigned int Vcount, const unsigned int *ngon_vi, unsigned int Fcount, const unsigned int *ngon_fi)</td></tr>
<tr class="separator:a1073baee7566788599b3de47f3d8d0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb6a97fd6853fa9607f6897b3bee4be1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#adb6a97fd6853fa9607f6897b3bee4be1">Morph</a> (const <a class="el" href="class_o_n___space_morph.html">ON_SpaceMorph</a> &amp;morph) override</td></tr>
<tr class="memdesc:adb6a97fd6853fa9607f6897b3bee4be1"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> override  <a href="class_o_n___mesh.html#adb6a97fd6853fa9607f6897b3bee4be1">More...</a><br /></td></tr>
<tr class="separator:adb6a97fd6853fa9607f6897b3bee4be1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb74c2912dfd22e91828b16017958af"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a0bb74c2912dfd22e91828b16017958af">Ngon</a> (unsigned int ngon_index) const</td></tr>
<tr class="separator:a0bb74c2912dfd22e91828b16017958af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b63074e3903db1cf10be7f122b7253c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a0b63074e3903db1cf10be7f122b7253c">NgonBoundaryBoundingBox</a> (const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *ngon) const</td></tr>
<tr class="separator:a0b63074e3903db1cf10be7f122b7253c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e49693fa501a2465579c87754064eb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3e49693fa501a2465579c87754064eb5">NgonBoundaryBoundingBox</a> (unsigned int ngon_index) const</td></tr>
<tr class="separator:a3e49693fa501a2465579c87754064eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97fc52044ad832b7d07411db2521c721"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a97fc52044ad832b7d07411db2521c721">NgonBoundaryEdgeCount</a> (unsigned int ngon_index) const</td></tr>
<tr class="separator:a97fc52044ad832b7d07411db2521c721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10cbdc82dd6d89be8685a82428601964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a10cbdc82dd6d89be8685a82428601964">NgonCenter</a> (const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *ngon) const</td></tr>
<tr class="separator:a10cbdc82dd6d89be8685a82428601964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b2323a4c55597e6ab2d8784fbf0f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a07b2323a4c55597e6ab2d8784fbf0f85">NgonCenter</a> (unsigned int ngon_index) const</td></tr>
<tr class="separator:a07b2323a4c55597e6ab2d8784fbf0f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4351c0a15e835215552431473ab84fb4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a4351c0a15e835215552431473ab84fb4">NgonCount</a> () const</td></tr>
<tr class="separator:a4351c0a15e835215552431473ab84fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7dc938246cff27850bd279cb8b9e307"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aa7dc938246cff27850bd279cb8b9e307">NgonFromComponentIndex</a> (class <a class="el" href="class_o_n___mesh_ngon_buffer.html">ON_MeshNgonBuffer</a> &amp;ngon_buffer, <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> ci) const</td></tr>
<tr class="separator:aa7dc938246cff27850bd279cb8b9e307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0857d55de805ef93bfe994857ef69be"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac0857d55de805ef93bfe994857ef69be">NgonIndexFromFaceIndex</a> (unsigned int face_index) const</td></tr>
<tr class="separator:ac0857d55de805ef93bfe994857ef69be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6c65cf1ecadb5491a096ce442fd9337"><td class="memItemLeft" align="right" valign="top">const unsigned int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae6c65cf1ecadb5491a096ce442fd9337">NgonMap</a> () const</td></tr>
<tr class="separator:ae6c65cf1ecadb5491a096ce442fd9337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f84a9e00b59d6d477fda0a951ed1ce"><td class="memItemLeft" align="right" valign="top">const unsigned int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af3f84a9e00b59d6d477fda0a951ed1ce">NgonMap</a> (bool bCreateIfMissing)</td></tr>
<tr class="separator:af3f84a9e00b59d6d477fda0a951ed1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeebceaf44e9a38160761dc9bd690f53"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#abeebceaf44e9a38160761dc9bd690f53">Ngons</a> () const</td></tr>
<tr class="separator:abeebceaf44e9a38160761dc9bd690f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90c3f81acd22e891e91c68ce4cf9a77b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a90c3f81acd22e891e91c68ce4cf9a77b">NgonUnsignedCount</a> () const</td></tr>
<tr class="separator:a90c3f81acd22e891e91c68ce4cf9a77b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9295f030b83e008c7c07f43ed33dab97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a9295f030b83e008c7c07f43ed33dab97">NormalizeTextureCoordinates</a> ()</td></tr>
<tr class="separator:a9295f030b83e008c7c07f43ed33dab97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a061ab836e5be4150fb6501d0a0545d85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n.html#a328d22b5ad7bf9d4e9ba1123355d3cf9">ON::object_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a061ab836e5be4150fb6501d0a0545d85">ObjectType</a> () const override</td></tr>
<tr class="separator:a061ab836e5be4150fb6501d0a0545d85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892efaa4dad96e991cc6c6c9c03db2e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a892efaa4dad96e991cc6c6c9c03db2e5">OffsetMesh</a> (const double distance, const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;direction) const</td></tr>
<tr class="separator:a892efaa4dad96e991cc6c6c9c03db2e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10397c31699ec61ec3f0191bb4c91209"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a10397c31699ec61ec3f0191bb4c91209">operator=</a> (const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;)</td></tr>
<tr class="separator:a10397c31699ec61ec3f0191bb4c91209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0c2907958feec6fc5a7361855c77cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a0d0c2907958feec6fc5a7361855c77cb">OrientNgons</a> (bool bPermitHoles)</td></tr>
<tr class="separator:a0d0c2907958feec6fc5a7361855c77cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcaabae10215815145532ff33c72ff8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___mesh_partition.html">ON_MeshPartition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aebcaabae10215815145532ff33c72ff8">Partition</a> () const</td></tr>
<tr class="separator:aebcaabae10215815145532ff33c72ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64501613756a89e8bd1c52f1a44c4d63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a64501613756a89e8bd1c52f1a44c4d63">QuadCount</a> () const</td></tr>
<tr class="memdesc:a64501613756a89e8bd1c52f1a44c4d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of faces that are quads  <a href="class_o_n___mesh.html#a64501613756a89e8bd1c52f1a44c4d63">More...</a><br /></td></tr>
<tr class="separator:a64501613756a89e8bd1c52f1a44c4d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfed633bb6c0ef69b6e0dd585dffb6b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#abfed633bb6c0ef69b6e0dd585dffb6b2">Read</a> (<a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;) override</td></tr>
<tr class="separator:abfed633bb6c0ef69b6e0dd585dffb6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182b3f6401bc7617ca97d4269378882e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a182b3f6401bc7617ca97d4269378882e">RemoveAllCreases</a> ()</td></tr>
<tr class="separator:a182b3f6401bc7617ca97d4269378882e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5650aabe73182b671e1a7d60f7993869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a5650aabe73182b671e1a7d60f7993869">RemoveAllNgons</a> ()</td></tr>
<tr class="separator:a5650aabe73182b671e1a7d60f7993869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0c77dc1381c57b45e87008264ca0ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a4b0c77dc1381c57b45e87008264ca0ce">RemoveEmptyNgons</a> ()</td></tr>
<tr class="separator:a4b0c77dc1381c57b45e87008264ca0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1c49c5d8bb7e37cbe30ac895672691"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a0d1c49c5d8bb7e37cbe30ac895672691">RemoveNgon</a> (unsigned int ngon_index)</td></tr>
<tr class="separator:a0d1c49c5d8bb7e37cbe30ac895672691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f8e867fcd417fe95658d3390396ab07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a2f8e867fcd417fe95658d3390396ab07">RemoveNgonInteriorVertices</a> (const unsigned int *const *vertex_face_map, unsigned int ngon_index0, unsigned int ngon_index1)</td></tr>
<tr class="separator:a2f8e867fcd417fe95658d3390396ab07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6373b244204508e3539b71df54ae7b28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a6373b244204508e3539b71df54ae7b28">RemoveNgonMap</a> ()</td></tr>
<tr class="separator:a6373b244204508e3539b71df54ae7b28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cb1db4aa87239e5a288688458c8e3a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ab0cb1db4aa87239e5a288688458c8e3a">RemoveNgons</a> (unsigned int ngon_index_count, const unsigned int *ngon_index_list)</td></tr>
<tr class="separator:ab0cb1db4aa87239e5a288688458c8e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79dfcb5a43667ddda303516881b9c132"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a79dfcb5a43667ddda303516881b9c132">ReserveVertexCapacity</a> (size_t new_vertex_capacity)</td></tr>
<tr class="separator:a79dfcb5a43667ddda303516881b9c132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3472d68ce671f6a65a57c033836b4a07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3472d68ce671f6a65a57c033836b4a07">ReverseSurfaceParameters</a> (int dir)</td></tr>
<tr class="separator:a3472d68ce671f6a65a57c033836b4a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f5d250500fd7eabc434db8950eb973"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a40f5d250500fd7eabc434db8950eb973">ReverseTextureCoordinates</a> (int dir)</td></tr>
<tr class="separator:a40f5d250500fd7eabc434db8950eb973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11133fd5bae412081e6eaf21769c86f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae11133fd5bae412081e6eaf21769c86f">SeparateNgons</a> (unsigned int **vertex_face_map, unsigned int ngon_index0, unsigned int ngon_index1)</td></tr>
<tr class="separator:ae11133fd5bae412081e6eaf21769c86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf36e17605dc94bf12c7eb0de2e82c4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___texture_coordinates.html">ON_TextureCoordinates</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aecf36e17605dc94bf12c7eb0de2e82c4">SetCachedTextureCoordinates</a> (const class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;mapping, const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *mesh_xform=0, bool bLazy=true)</td></tr>
<tr class="separator:aecf36e17605dc94bf12c7eb0de2e82c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82f7f797aea84ffd659211c8eab42f87"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___texture_coordinates.html">ON_TextureCoordinates</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a82f7f797aea84ffd659211c8eab42f87">SetCachedTextureCoordinatesEx</a> (const class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;mapping, const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *mesh_xform=0, bool bLazy=true, bool bSeamCheck=true)</td></tr>
<tr class="separator:a82f7f797aea84ffd659211c8eab42f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5929a47378ca44d6703e59b32afd5e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad5929a47378ca44d6703e59b32afd5e5">SetClosed</a> (int closed)</td></tr>
<tr class="separator:ad5929a47378ca44d6703e59b32afd5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734a124c91c1a3d3b36b0c85e6924e79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a734a124c91c1a3d3b36b0c85e6924e79">SetMeshParameters</a> (const <a class="el" href="class_o_n___mesh_parameters.html">ON_MeshParameters</a> &amp;)</td></tr>
<tr class="separator:a734a124c91c1a3d3b36b0c85e6924e79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0b8319c20e21c5951a756cf0487dcaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae0b8319c20e21c5951a756cf0487dcaf">SetNgonCount</a> (unsigned int ngon_count)</td></tr>
<tr class="separator:ae0b8319c20e21c5951a756cf0487dcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856a3af6a33cda2fc94e9706afc103b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a856a3af6a33cda2fc94e9706afc103b4">SetNgonVertexNormals</a> (unsigned int ngon_index0, unsigned int ngon_index1)</td></tr>
<tr class="separator:a856a3af6a33cda2fc94e9706afc103b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab515fbc0a7c92619da7701024dc4c2b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ab515fbc0a7c92619da7701024dc4c2b7">SetQuad</a> (int, int, int, int, int)</td></tr>
<tr class="separator:ab515fbc0a7c92619da7701024dc4c2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3be0087786c0ecb82965bb30e890a74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af3be0087786c0ecb82965bb30e890a74">SetSolidOrientation</a> (int solid_orientation)</td></tr>
<tr class="separator:af3be0087786c0ecb82965bb30e890a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f3ae98710815f6b9dda28e1649e634"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae8f3ae98710815f6b9dda28e1649e634">SetSurfaceParamtersFromTextureCoodinates</a> ()</td></tr>
<tr class="separator:ae8f3ae98710815f6b9dda28e1649e634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8afa3775940a5bc48600d5f4d205a5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad8afa3775940a5bc48600d5f4d205a5a">SetTextureCoord</a> (int, double, double)</td></tr>
<tr class="separator:ad8afa3775940a5bc48600d5f4d205a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63b1a95fe549071b2500ba9ea2c8319"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac63b1a95fe549071b2500ba9ea2c8319">SetTextureCoordinates</a> (const class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;mapping, const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *mesh_xform=0, bool bLazy=true)</td></tr>
<tr class="separator:ac63b1a95fe549071b2500ba9ea2c8319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3e29046b35bb62806d6b50c3c9da57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a2b3e29046b35bb62806d6b50c3c9da57">SetTextureCoordinatesEx</a> (const class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;mapping, const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *mesh_xform=0, bool bLazy=true, bool bSeamCheck=true)</td></tr>
<tr class="separator:a2b3e29046b35bb62806d6b50c3c9da57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c59eade1b16f97315c819a6cdb050a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a12c59eade1b16f97315c819a6cdb050a">SetTriangle</a> (int, int, int, int)</td></tr>
<tr class="separator:a12c59eade1b16f97315c819a6cdb050a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af734006dba8a02b93a63362f79b33687"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af734006dba8a02b93a63362f79b33687">SetVertex</a> (int, const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;)</td></tr>
<tr class="memdesc:af734006dba8a02b93a63362f79b33687"><td class="mdescLeft">&#160;</td><td class="mdescRight">creation  <a href="class_o_n___mesh.html#af734006dba8a02b93a63362f79b33687">More...</a><br /></td></tr>
<tr class="separator:af734006dba8a02b93a63362f79b33687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fc61ee539ef1f675eb21f1e3280564"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac3fc61ee539ef1f675eb21f1e3280564">SetVertex</a> (int, const <a class="el" href="class_o_n__3f_point.html">ON_3fPoint</a> &amp;)</td></tr>
<tr class="separator:ac3fc61ee539ef1f675eb21f1e3280564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2465f42f9a69bc215f54190781d2e606"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a2465f42f9a69bc215f54190781d2e606">SetVertexHiddenFlag</a> (int meshvi, bool bHidden)</td></tr>
<tr class="separator:a2465f42f9a69bc215f54190781d2e606"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b25135257b2ab8e82576df04c1944f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a23b25135257b2ab8e82576df04c1944f">SetVertexNormal</a> (int, const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;)</td></tr>
<tr class="separator:a23b25135257b2ab8e82576df04c1944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90a3568093e3fa55250a83f5e8a2611"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac90a3568093e3fa55250a83f5e8a2611">SetVertexNormal</a> (int, const <a class="el" href="class_o_n__3f_vector.html">ON_3fVector</a> &amp;)</td></tr>
<tr class="separator:ac90a3568093e3fa55250a83f5e8a2611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a795963e1da89ea2d8aed31fe5f79365c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a795963e1da89ea2d8aed31fe5f79365c">SizeOf</a> () const override</td></tr>
<tr class="memdesc:a795963e1da89ea2d8aed31fe5f79365c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___object.html">ON_Object</a> overrides.  <a href="class_o_n___mesh.html#a795963e1da89ea2d8aed31fe5f79365c">More...</a><br /></td></tr>
<tr class="separator:a795963e1da89ea2d8aed31fe5f79365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e152a0038bf5a96071b5c6ff3a2ef4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a59e152a0038bf5a96071b5c6ff3a2ef4">SolidOrientation</a> () const</td></tr>
<tr class="separator:a59e152a0038bf5a96071b5c6ff3a2ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1b6eec5e11ecc564037ddd342af32e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aac1b6eec5e11ecc564037ddd342af32e">Split</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;meshesThatSplit, double tolerance, bool splitAtCoplanar, bool createNgons, bool *somethingHappened, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;results, <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *log, <a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *cancel, <a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *reporter) const</td></tr>
<tr class="separator:aac1b6eec5e11ecc564037ddd342af32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a137c9bd26335e1ba37d285ca88169"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ab7a137c9bd26335e1ba37d285ca88169">SwapCoordinates</a> (int, int) override</td></tr>
<tr class="separator:ab7a137c9bd26335e1ba37d285ca88169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14ed95524bdd6ce006fc9943e3f6543b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a14ed95524bdd6ce006fc9943e3f6543b">SwapEdge</a> (int topei)</td></tr>
<tr class="separator:a14ed95524bdd6ce006fc9943e3f6543b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af24a886d37eb19d3525530480e1f18e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___mesh_topology.html">ON_MeshTopology</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af24a886d37eb19d3525530480e1f18e7">Topology</a> () const</td></tr>
<tr class="separator:af24a886d37eb19d3525530480e1f18e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0112c37f50a593ea418e7b98a83697e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad0112c37f50a593ea418e7b98a83697e">TopologyExists</a> () const</td></tr>
<tr class="separator:ad0112c37f50a593ea418e7b98a83697e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad115dd0a3ad64cda398bbe90e08c8bf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad115dd0a3ad64cda398bbe90e08c8bf6">Transform</a> (const <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;) override</td></tr>
<tr class="separator:ad115dd0a3ad64cda398bbe90e08c8bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34af8bca8ce0fa49869631284b3550af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a34af8bca8ce0fa49869631284b3550af">TransposeSurfaceParameters</a> ()</td></tr>
<tr class="separator:a34af8bca8ce0fa49869631284b3550af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2961b83326bdb975bda84840e20b6d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ae2961b83326bdb975bda84840e20b6d6">TransposeTextureCoordinates</a> ()</td></tr>
<tr class="separator:ae2961b83326bdb975bda84840e20b6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598a283bddc566a549f1aeb60dc058a9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a598a283bddc566a549f1aeb60dc058a9">TriangleCount</a> () const</td></tr>
<tr class="memdesc:a598a283bddc566a549f1aeb60dc058a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of faces that are triangles  <a href="class_o_n___mesh.html#a598a283bddc566a549f1aeb60dc058a9">More...</a><br /></td></tr>
<tr class="separator:a598a283bddc566a549f1aeb60dc058a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb9371d4e542fe67912f877f6984d44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a1fb9371d4e542fe67912f877f6984d44">UnitizeFaceNormals</a> ()</td></tr>
<tr class="separator:a1fb9371d4e542fe67912f877f6984d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50356fc532f6dcdd258468df333d6e01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a50356fc532f6dcdd258468df333d6e01">UnitizeVertexNormals</a> ()</td></tr>
<tr class="separator:a50356fc532f6dcdd258468df333d6e01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab94df03536804d2573b383699db4c57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aab94df03536804d2573b383699db4c57">UpdateDoublePrecisionVertices</a> ()</td></tr>
<tr class="separator:aab94df03536804d2573b383699db4c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78c5b48affca5a6218278c7037a2776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac78c5b48affca5a6218278c7037a2776">UpdateSinglePrecisionVertices</a> ()</td></tr>
<tr class="separator:ac78c5b48affca5a6218278c7037a2776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b42b3e7a203c6844c3be9d1b434fbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a75b42b3e7a203c6844c3be9d1b434fbf">V4V5_DestroyNgonList</a> ()</td></tr>
<tr class="separator:a75b42b3e7a203c6844c3be9d1b434fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3cc6fbfda985824bc42c5f462cd7b7"><td class="memItemLeft" align="right" valign="top">class ON_V4V5_MeshNgonList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a7c3cc6fbfda985824bc42c5f462cd7b7">V4V5_ModifyNgonList</a> ()</td></tr>
<tr class="separator:a7c3cc6fbfda985824bc42c5f462cd7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62c8242a99bb4f8f173558675f9a1eb7"><td class="memItemLeft" align="right" valign="top">const class ON_V4V5_MeshNgonList *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a62c8242a99bb4f8f173558675f9a1eb7">V4V5_NgonList</a> () const</td></tr>
<tr class="separator:a62c8242a99bb4f8f173558675f9a1eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176b42a1a76666bff52ed72e77007006"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a176b42a1a76666bff52ed72e77007006">Vertex</a> (int vertex_index) const</td></tr>
<tr class="separator:a176b42a1a76666bff52ed72e77007006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f6f2497feca5e9ba8a038f260c07e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a96f6f2497feca5e9ba8a038f260c07e5">VertexCount</a> () const</td></tr>
<tr class="memdesc:a96f6f2497feca5e9ba8a038f260c07e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">query  <a href="class_o_n___mesh.html#a96f6f2497feca5e9ba8a038f260c07e5">More...</a><br /></td></tr>
<tr class="separator:a96f6f2497feca5e9ba8a038f260c07e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d559932d255011e1c3389e4d0dd29e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a30d559932d255011e1c3389e4d0dd29e">VertexIsHidden</a> (int meshvi) const</td></tr>
<tr class="separator:a30d559932d255011e1c3389e4d0dd29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570150a61ae34746d3ef1ef02c8d7612"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a570150a61ae34746d3ef1ef02c8d7612">VertexUnsignedCount</a> () const</td></tr>
<tr class="separator:a570150a61ae34746d3ef1ef02c8d7612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c016b38cda75a98a1648c1001c1d6c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af7c016b38cda75a98a1648c1001c1d6c">Volume</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> base_point=<a class="el" href="class_o_n__3d_point.html#ae5dcca5dde698b25a7ec98b3868285b5">ON_3dPoint::Origin</a>, double *error_estimate=nullptr) const</td></tr>
<tr class="separator:af7c016b38cda75a98a1648c1001c1d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa607ea044e3e95c8404019416e5dfdfe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aa607ea044e3e95c8404019416e5dfdfe">VolumeCentroid</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> base_point=<a class="el" href="class_o_n__3d_point.html#ae5dcca5dde698b25a7ec98b3868285b5">ON_3dPoint::Origin</a>, double *volume=nullptr) const</td></tr>
<tr class="separator:aa607ea044e3e95c8404019416e5dfdfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a1b4435044cb9bd612ca013faed17b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aa6a1b4435044cb9bd612ca013faed17b">VolumeMassProperties</a> (class <a class="el" href="class_o_n___mass_properties.html">ON_MassProperties</a> &amp;mp, bool bVolume=true, bool bFirstMoments=true, bool bSecondMoments=true, bool bProductMoments=true, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> base_point=<a class="el" href="class_o_n__3d_point.html#aa68906e3e7650b01ce88c527f6088d7d">ON_3dPoint::UnsetPoint</a>) const</td></tr>
<tr class="separator:aa6a1b4435044cb9bd612ca013faed17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d8ee57465bcf4458dc5fbb55628423"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad4d8ee57465bcf4458dc5fbb55628423">Write</a> (<a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;) const override</td></tr>
<tr class="separator:ad4d8ee57465bcf4458dc5fbb55628423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_o_n___geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_o_n___geometry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_o_n___geometry.html">ON_Geometry</a></td></tr>
<tr class="memitem:a65226d33b1c8c1e8289e37073566c953 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a65226d33b1c8c1e8289e37073566c953">ON_Geometry</a> ()=default</td></tr>
<tr class="separator:a65226d33b1c8c1e8289e37073566c953 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fbefc2a5f24da5f5fb4061d6849f17 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a71fbefc2a5f24da5f5fb4061d6849f17">ON_Geometry</a> (const <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> &amp;)=default</td></tr>
<tr class="separator:a71fbefc2a5f24da5f5fb4061d6849f17 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2ca447610c622f3530944c764a3a67 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a4f2ca447610c622f3530944c764a3a67">~ON_Geometry</a> ()=default</td></tr>
<tr class="separator:a4f2ca447610c622f3530944c764a3a67 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1acdd7f0c350da696b402a9ac5edce0 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#ab1acdd7f0c350da696b402a9ac5edce0">BoundingBox</a> () const</td></tr>
<tr class="separator:ab1acdd7f0c350da696b402a9ac5edce0 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8d6122b6285e4ab819fa50bd442c23 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">virtual class <a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#aeb8d6122b6285e4ab819fa50bd442c23">BrepForm</a> (class <a class="el" href="class_o_n___brep.html">ON_Brep</a> *brep=nullptr) const</td></tr>
<tr class="separator:aeb8d6122b6285e4ab819fa50bd442c23 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dfbd8534986bbd327a6ad812e374be inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#af8dfbd8534986bbd327a6ad812e374be">ClearBoundingBox</a> ()</td></tr>
<tr class="separator:af8dfbd8534986bbd327a6ad812e374be inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e5d1aeada9545127329a8699c702b9 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a20e5d1aeada9545127329a8699c702b9">ComponentIndex</a> () const</td></tr>
<tr class="separator:a20e5d1aeada9545127329a8699c702b9 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac123c564ea7a43c4406ac78954cf5266 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#ac123c564ea7a43c4406ac78954cf5266">GetBoundingBox</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;bbox_min, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;bbox_max, bool bGrowBox=false) const</td></tr>
<tr class="separator:ac123c564ea7a43c4406ac78954cf5266 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7259b0a7e7c663e55345788411352075 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a7259b0a7e7c663e55345788411352075">GetBoundingBox</a> (<a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;bbox, bool bGrowBox=false) const</td></tr>
<tr class="separator:a7259b0a7e7c663e55345788411352075 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b28eb33d34c71913b9cd16f8ecab50 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a84b28eb33d34c71913b9cd16f8ecab50">HasBrepForm</a> () const</td></tr>
<tr class="separator:a84b28eb33d34c71913b9cd16f8ecab50 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e18c1d187cad2eb1c8f7e30a985c29 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#aa1e18c1d187cad2eb1c8f7e30a985c29">Morph</a> (const class <a class="el" href="class_o_n___space_morph.html">ON_SpaceMorph</a> &amp;morph)</td></tr>
<tr class="separator:aa1e18c1d187cad2eb1c8f7e30a985c29 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071e7617820ea38c40f4b3966e7daee0 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___geometry.html">ON_Geometry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a071e7617820ea38c40f4b3966e7daee0">operator=</a> (const <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> &amp;)=default</td></tr>
<tr class="separator:a071e7617820ea38c40f4b3966e7daee0 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49629d8d427ee579d9b28c1e25818e0 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#af49629d8d427ee579d9b28c1e25818e0">Rotate</a> (double rotation_angle, const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;rotation_axis, const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;rotation_center)</td></tr>
<tr class="separator:af49629d8d427ee579d9b28c1e25818e0 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8306ab6d43886453a056160429bc0a inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a3c8306ab6d43886453a056160429bc0a">Rotate</a> (double sin_angle, double cos_angle, const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;rotation_axis, const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;rotation_center)</td></tr>
<tr class="separator:a3c8306ab6d43886453a056160429bc0a inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b847d6dcda412468ab59f06328b2619 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a1b847d6dcda412468ab59f06328b2619">Scale</a> (double scale_factor)</td></tr>
<tr class="separator:a1b847d6dcda412468ab59f06328b2619 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b47e669fde50b5223a8017863598e89 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a3b47e669fde50b5223a8017863598e89">Translate</a> (const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;translation_vector)</td></tr>
<tr class="separator:a3b47e669fde50b5223a8017863598e89 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_o_n___object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_o_n___object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_o_n___object.html">ON_Object</a></td></tr>
<tr class="memitem:af580c6199f4469c49a4e09a117626c10 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#af580c6199f4469c49a4e09a117626c10">ON_Object</a> () <a class="el" href="group__open_n_u_r_b_s.html#ga1b9bbb0fba1d3a5fae3accc23a26e990">ON_NOEXCEPT</a></td></tr>
<tr class="separator:af580c6199f4469c49a4e09a117626c10 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274166b34d06fc07a85997fd01b2dab1 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a274166b34d06fc07a85997fd01b2dab1">ON_Object</a> (const <a class="el" href="class_o_n___object.html">ON_Object</a> &amp;)</td></tr>
<tr class="separator:a274166b34d06fc07a85997fd01b2dab1 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad940aab7d51005c8732d76d1b188e332 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ad940aab7d51005c8732d76d1b188e332">~ON_Object</a> ()</td></tr>
<tr class="separator:ad940aab7d51005c8732d76d1b188e332 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a1cfab63437a2d03cc50fdc6734f2a5 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_o_n___aggregate_component_status.html">ON_AggregateComponentStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a8a1cfab63437a2d03cc50fdc6734f2a5">AggregateComponentStatus</a> () const</td></tr>
<tr class="separator:a8a1cfab63437a2d03cc50fdc6734f2a5 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5432b341051664c185b10712a6e5b79 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ad5432b341051664c185b10712a6e5b79">AttachUserData</a> (class <a class="el" href="class_o_n___user_data.html">ON_UserData</a> *pUserData)</td></tr>
<tr class="separator:ad5432b341051664c185b10712a6e5b79 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27893ff72ca7abbe985f8b5f4ccd900e inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a27893ff72ca7abbe985f8b5f4ccd900e">ClearAllComponentStates</a> () const</td></tr>
<tr class="separator:a27893ff72ca7abbe985f8b5f4ccd900e inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadf76a46f3f1a661bbf41e1b754fe89 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#aeadf76a46f3f1a661bbf41e1b754fe89">ClearComponentStates</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_to_clear) const</td></tr>
<tr class="separator:aeadf76a46f3f1a661bbf41e1b754fe89 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af75ebe418edff4a11985f8fca7d83b inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a1af75ebe418edff4a11985f8fca7d83b">ClearComponentStates</a> (<a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_to_clear) const</td></tr>
<tr class="separator:a1af75ebe418edff4a11985f8fca7d83b inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58958333257eba5575a6a1b09c366c1b inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a58958333257eba5575a6a1b09c366c1b">CopyUserData</a> (const <a class="el" href="class_o_n___object.html">ON_Object</a> &amp;source_object)</td></tr>
<tr class="separator:a58958333257eba5575a6a1b09c366c1b inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad044157e5c1efde9fce1c6ccf6e81ff3 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ad044157e5c1efde9fce1c6ccf6e81ff3">CopyUserData</a> (const <a class="el" href="class_o_n___object.html">ON_Object</a> &amp;source_object, <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> source_userdata_item_id, <a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956c">ON_Object::UserDataConflictResolution</a> userdata_conflict_resolution)</td></tr>
<tr class="separator:ad044157e5c1efde9fce1c6ccf6e81ff3 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbb0eff3b2287152b40991b3afca9ee inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a1dbb0eff3b2287152b40991b3afca9ee">DetachUserData</a> (class <a class="el" href="class_o_n___user_data.html">ON_UserData</a> *pUserData)</td></tr>
<tr class="separator:a1dbb0eff3b2287152b40991b3afca9ee inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad265ca0da2d751edaa9d2b5ab2540c6a inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ad265ca0da2d751edaa9d2b5ab2540c6a">EmergencyDestroy</a> ()</td></tr>
<tr class="separator:ad265ca0da2d751edaa9d2b5ab2540c6a inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb43bb324c44740c4bc2932e2f95c835 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___user_data.html">ON_UserData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#adb43bb324c44740c4bc2932e2f95c835">FirstUserData</a> () const</td></tr>
<tr class="separator:adb43bb324c44740c4bc2932e2f95c835 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691de6470e814973858aa5c51eaffa77 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a691de6470e814973858aa5c51eaffa77">GetComponentsWithSetStates</a> (<a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_filter, bool bAllEqualStates, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;components) const</td></tr>
<tr class="separator:a691de6470e814973858aa5c51eaffa77 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8d609e22008680581c6ca72ac47df inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___user_data.html">ON_UserData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a29f8d609e22008680581c6ca72ac47df">GetUserData</a> (const <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> &amp;userdata_uuid) const</td></tr>
<tr class="separator:a29f8d609e22008680581c6ca72ac47df inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40b5e89b4766299e415593b31a3849c inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ab40b5e89b4766299e415593b31a3849c">GetUserString</a> (const wchar_t *key, <a class="el" href="class_o_n__w_string.html">ON_wString</a> &amp;string_value) const</td></tr>
<tr class="separator:ab40b5e89b4766299e415593b31a3849c inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac285fba1506b2b9b821e3655582939c4 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ac285fba1506b2b9b821e3655582939c4">GetUserStringKeys</a> (<a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n__w_string.html">ON_wString</a> &gt; &amp;user_string_keys) const</td></tr>
<tr class="separator:ac285fba1506b2b9b821e3655582939c4 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004ab49490f69fcdc7681919c3837a33 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a004ab49490f69fcdc7681919c3837a33">GetUserStrings</a> (<a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___user_string.html">ON_UserString</a> &gt; &amp;user_strings) const</td></tr>
<tr class="separator:a004ab49490f69fcdc7681919c3837a33 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266957f93639a598b0e1b6a89e0bb40d inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a266957f93639a598b0e1b6a89e0bb40d">IsCorrupt</a> (bool bRepair, bool bSilentError, class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *text_log) const</td></tr>
<tr class="separator:a266957f93639a598b0e1b6a89e0bb40d inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5367058a90545e81cd79b78103175d inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#afe5367058a90545e81cd79b78103175d">IsKindOf</a> (const <a class="el" href="class_o_n___class_id.html">ON_ClassId</a> *pClassId) const</td></tr>
<tr class="separator:afe5367058a90545e81cd79b78103175d inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a609192fbafecbe4be3136d8cb4dce882 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a609192fbafecbe4be3136d8cb4dce882">MarkAggregateComponentStatusAsNotCurrent</a> () const</td></tr>
<tr class="separator:a609192fbafecbe4be3136d8cb4dce882 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c508d3b53458e252adbcd29e62ed09 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a21c508d3b53458e252adbcd29e62ed09">ModelObjectId</a> () const</td></tr>
<tr class="separator:a21c508d3b53458e252adbcd29e62ed09 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a891ae2cb2a25008a7a39cb19dfcea inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a54a891ae2cb2a25008a7a39cb19dfcea">MoveUserData</a> (<a class="el" href="class_o_n___object.html">ON_Object</a> &amp;source_object)</td></tr>
<tr class="separator:a54a891ae2cb2a25008a7a39cb19dfcea inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b4ecb2eb36641e1ee6b4fc6129606e inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a78b4ecb2eb36641e1ee6b4fc6129606e">MoveUserData</a> (<a class="el" href="class_o_n___object.html">ON_Object</a> &amp;source_object, <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> source_userdata_item_id, <a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956c">ON_Object::UserDataConflictResolution</a> userdata_conflict_resolution, bool bDeleteAllSourceItems)</td></tr>
<tr class="separator:a78b4ecb2eb36641e1ee6b4fc6129606e inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6166c9aecef42639e684a2a3fda223 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___object.html">ON_Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#aba6166c9aecef42639e684a2a3fda223">operator=</a> (const <a class="el" href="class_o_n___object.html">ON_Object</a> &amp;)</td></tr>
<tr class="separator:aba6166c9aecef42639e684a2a3fda223 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b61cafc0024ecb7a4bd22da2718680 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a88b61cafc0024ecb7a4bd22da2718680">PurgeUserData</a> ()</td></tr>
<tr class="separator:a88b61cafc0024ecb7a4bd22da2718680 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab728c0576fd5913bc1575b74997bddb5 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ab728c0576fd5913bc1575b74997bddb5">SetComponentStates</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_to_set) const</td></tr>
<tr class="separator:ab728c0576fd5913bc1575b74997bddb5 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589f1fdc28f6259d1bd22bdedc9c4c76 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a589f1fdc28f6259d1bd22bdedc9c4c76">SetComponentStatus</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> status_to_copy) const</td></tr>
<tr class="separator:a589f1fdc28f6259d1bd22bdedc9c4c76 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074dc9e9b919853919564793c37f5143 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a074dc9e9b919853919564793c37f5143">SetUserString</a> (const wchar_t *key, const wchar_t *string_value)</td></tr>
<tr class="separator:a074dc9e9b919853919564793c37f5143 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7234af898c307a2c2f7931db7e627592 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a7234af898c307a2c2f7931db7e627592">SetUserStrings</a> (int count, const <a class="el" href="class_o_n___user_string.html">ON_UserString</a> *user_strings, bool bReplace)</td></tr>
<tr class="separator:a7234af898c307a2c2f7931db7e627592 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c747a7a2fe9a7481b55f0b631942ce inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a41c747a7a2fe9a7481b55f0b631942ce">ThisIsNullptr</a> (bool bSilentError) const</td></tr>
<tr class="separator:a41c747a7a2fe9a7481b55f0b631942ce inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881bd2f0d8515adba1c42c578bcb7052 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a881bd2f0d8515adba1c42c578bcb7052">TransformUserData</a> (const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform)</td></tr>
<tr class="separator:a881bd2f0d8515adba1c42c578bcb7052 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82188bbf97bbd149ac6fcb7cd8e989d1 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a82188bbf97bbd149ac6fcb7cd8e989d1">UpdateReferencedComponents</a> (const class <a class="el" href="class_o_n___component_manifest.html">ON_ComponentManifest</a> &amp;source_manifest, const class <a class="el" href="class_o_n___component_manifest.html">ON_ComponentManifest</a> &amp;destination_manifest, const class <a class="el" href="class_o_n___manifest_map.html">ON_ManifestMap</a> &amp;manifest_map)</td></tr>
<tr class="separator:a82188bbf97bbd149ac6fcb7cd8e989d1 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab648403ebf4592831809710f378e9ac2 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ab648403ebf4592831809710f378e9ac2">UserStringCount</a> () const</td></tr>
<tr class="separator:ab648403ebf4592831809710f378e9ac2 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ad55fc7bbc2c7082c2a5b13da37516579"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ad55fc7bbc2c7082c2a5b13da37516579">From3dPolygon</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;polygon_points, double planar_tolerance, <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *destintation_mesh)</td></tr>
<tr class="separator:ad55fc7bbc2c7082c2a5b13da37516579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0120c2518091a21db432e686f39cd5"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a0f0120c2518091a21db432e686f39cd5">From3dPolygon</a> (size_t polygon_points_count, const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *polygon_points, double planar_tolerance, <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *destintation_mesh)</td></tr>
<tr class="separator:a0f0120c2518091a21db432e686f39cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09213661dab9943eab473e8f369f2196"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a09213661dab9943eab473e8f369f2196">FromFilteredFaceList</a> (const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;original, bool *pattern, unsigned patternLength)</td></tr>
<tr class="separator:a09213661dab9943eab473e8f369f2196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f2ba77f7480c01babab680a1c089df0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a2f2ba77f7480c01babab680a1c089df0">IntersectArray</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;meshes, double tolerance, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *perforatingResults, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *overlapResults, <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *overlapMeshResult, <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *log, <a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *cancel, <a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *reporter)</td></tr>
<tr class="separator:a2f2ba77f7480c01babab680a1c089df0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9154c4736f20d4f2fa0bc214032b7e6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ac9154c4736f20d4f2fa0bc214032b7e6">IterativeCleanup</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;meshes, double tolerance, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;results)</td></tr>
<tr class="separator:ac9154c4736f20d4f2fa0bc214032b7e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a384ec8eed2f6a7316750618c393c42"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a2a384ec8eed2f6a7316750618c393c42">RequireIterativeCleanup</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;meshes, double tolerance)</td></tr>
<tr class="separator:a2a384ec8eed2f6a7316750618c393c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787131c36a85439f7a15cbff46a81b73"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a787131c36a85439f7a15cbff46a81b73">SplitArray</a> (const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;meshesToSplit, const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;meshesThatSplit, double tolerance, bool splitAtCoplanar, bool createNgons, bool *somethingHappened, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;results, <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *log, <a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *cancel, <a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *reporter)</td></tr>
<tr class="separator:a787131c36a85439f7a15cbff46a81b73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3eaa9b3a794729ab14d9c610e485d01e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___color.html">ON_Color</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a3eaa9b3a794729ab14d9c610e485d01e">m_C</a></td></tr>
<tr class="separator:a3eaa9b3a794729ab14d9c610e485d01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9caa1b55e23568cd492840c0290f56f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a9caa1b55e23568cd492840c0290f56f3">m_Ctag</a></td></tr>
<tr class="memdesc:a9caa1b55e23568cd492840c0290f56f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation - false color.  <a href="class_o_n___mesh.html#a9caa1b55e23568cd492840c0290f56f3">More...</a><br /></td></tr>
<tr class="separator:a9caa1b55e23568cd492840c0290f56f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7496a0e3ba5f171adb216a482ce057ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a7496a0e3ba5f171adb216a482ce057ae">m_dV</a></td></tr>
<tr class="separator:a7496a0e3ba5f171adb216a482ce057ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005e7e4b0f04014c289264e06e496450"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh_face.html">ON_MeshFace</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450">m_F</a></td></tr>
<tr class="memdesc:a005e7e4b0f04014c289264e06e496450"><td class="mdescLeft">&#160;</td><td class="mdescRight">m_F[] facets (triangles or quads)  <a href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450">More...</a><br /></td></tr>
<tr class="separator:a005e7e4b0f04014c289264e06e496450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b4408beb9cd28c90ddb4ec8492f499"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3f_vector_array.html">ON_3fVectorArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a61b4408beb9cd28c90ddb4ec8492f499">m_FN</a></td></tr>
<tr class="separator:a61b4408beb9cd28c90ddb4ec8492f499"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a166eabbd9f7f0e141e30325f6783f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a2a166eabbd9f7f0e141e30325f6783f8">m_H</a></td></tr>
<tr class="memdesc:a2a166eabbd9f7f0e141e30325f6783f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation - runtime vertex visibility - not saved in 3dm files.  <a href="class_o_n___mesh.html#a2a166eabbd9f7f0e141e30325f6783f8">More...</a><br /></td></tr>
<tr class="separator:a2a166eabbd9f7f0e141e30325f6783f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532418e6af843813ecc81246a8da7eef"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a532418e6af843813ecc81246a8da7eef">m_hidden_count</a></td></tr>
<tr class="separator:a532418e6af843813ecc81246a8da7eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f353770ff5fcc259d21e8a162d3e9d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___surface_curvature.html">ON_SurfaceCurvature</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a8f353770ff5fcc259d21e8a162d3e9d8">m_K</a></td></tr>
<tr class="memdesc:a8f353770ff5fcc259d21e8a162d3e9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation - curvature.  <a href="class_o_n___mesh.html#a8f353770ff5fcc259d21e8a162d3e9d8">More...</a><br /></td></tr>
<tr class="separator:a8f353770ff5fcc259d21e8a162d3e9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c95b35080197efd6f43ab5830efe9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3f_vector_array.html">ON_3fVectorArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af5c95b35080197efd6f43ab5830efe9f">m_N</a></td></tr>
<tr class="separator:af5c95b35080197efd6f43ab5830efe9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91153bed501502cd587b18884c48d22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ab91153bed501502cd587b18884c48d22">m_Ngon</a></td></tr>
<tr class="separator:ab91153bed501502cd587b18884c48d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f60e99fe72ecdd5edea702c7ec73363"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh_ngon_allocator.html">ON_MeshNgonAllocator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a9f60e99fe72ecdd5edea702c7ec73363">m_NgonAllocator</a></td></tr>
<tr class="memdesc:a9f60e99fe72ecdd5edea702c7ec73363"><td class="mdescLeft">&#160;</td><td class="mdescRight">use this to allocate elements added to m_Ngon;  <a href="class_o_n___mesh.html#a9f60e99fe72ecdd5edea702c7ec73363">More...</a><br /></td></tr>
<tr class="separator:a9f60e99fe72ecdd5edea702c7ec73363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab992dbdbd1b3202ce27b6aed0eb15827"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#ab992dbdbd1b3202ce27b6aed0eb15827">m_NgonMap</a></td></tr>
<tr class="memdesc:ab992dbdbd1b3202ce27b6aed0eb15827"><td class="mdescLeft">&#160;</td><td class="mdescRight">invalid if m_NgonMap.Count() != m_F.Count()  <a href="class_o_n___mesh.html#ab992dbdbd1b3202ce27b6aed0eb15827">More...</a><br /></td></tr>
<tr class="separator:ab992dbdbd1b3202ce27b6aed0eb15827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe46dd344baf3956432762bb2f69d90b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___interval.html">ON_Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#abe46dd344baf3956432762bb2f69d90b">m_packed_tex_domain</a> [2]</td></tr>
<tr class="separator:abe46dd344baf3956432762bb2f69d90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859cbfcfa130e9a7433d012064554938"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a859cbfcfa130e9a7433d012064554938">m_packed_tex_rotate</a></td></tr>
<tr class="separator:a859cbfcfa130e9a7433d012064554938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c5f065e1c3ae6a160e6931601ccdc8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___object.html">ON_Object</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a77c5f065e1c3ae6a160e6931601ccdc8">m_parent</a></td></tr>
<tr class="memdesc:a77c5f065e1c3ae6a160e6931601ccdc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation - runtime UI information.  <a href="class_o_n___mesh.html#a77c5f065e1c3ae6a160e6931601ccdc8">More...</a><br /></td></tr>
<tr class="separator:a77c5f065e1c3ae6a160e6931601ccdc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf195fbe55da435006a2ba9c66e71e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__2d_point_array.html">ON_2dPointArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#acbf195fbe55da435006a2ba9c66e71e4">m_S</a></td></tr>
<tr class="separator:acbf195fbe55da435006a2ba9c66e71e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d982115e07a7a0209d7b35b83a96bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___interval.html">ON_Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a48d982115e07a7a0209d7b35b83a96bb">m_srf_domain</a> [2]</td></tr>
<tr class="memdesc:a48d982115e07a7a0209d7b35b83a96bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">surface evaluation domain.  <a href="class_o_n___mesh.html#a48d982115e07a7a0209d7b35b83a96bb">More...</a><br /></td></tr>
<tr class="separator:a48d982115e07a7a0209d7b35b83a96bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfec38c9115fc2045b8d2105dd634ff2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#abfec38c9115fc2045b8d2105dd634ff2">m_srf_scale</a> [2]</td></tr>
<tr class="separator:abfec38c9115fc2045b8d2105dd634ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8813d0559c1834e30af2b86da7d64c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__2f_point_array.html">ON_2fPointArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#af8813d0559c1834e30af2b86da7d64c9">m_T</a></td></tr>
<tr class="memdesc:af8813d0559c1834e30af2b86da7d64c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTIONAL texture coordinates for each vertex.  <a href="class_o_n___mesh.html#af8813d0559c1834e30af2b86da7d64c9">More...</a><br /></td></tr>
<tr class="separator:af8813d0559c1834e30af2b86da7d64c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e3c1473d1817f3606ebc30c7b05bf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___texture_coordinates.html">ON_TextureCoordinates</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a28e3c1473d1817f3606ebc30c7b05bf0">m_TC</a></td></tr>
<tr class="separator:a28e3c1473d1817f3606ebc30c7b05bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5f8175918c06ea9b632113e29786b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a5a5f8175918c06ea9b632113e29786b9">m_Ttag</a></td></tr>
<tr class="memdesc:a5a5f8175918c06ea9b632113e29786b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">OPTIONAL tag for values in m_T[].  <a href="class_o_n___mesh.html#a5a5f8175918c06ea9b632113e29786b9">More...</a><br /></td></tr>
<tr class="separator:a5a5f8175918c06ea9b632113e29786b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc720e646b5fb26e5285b1838f71c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3f_point_array.html">ON_3fPointArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a6cc720e646b5fb26e5285b1838f71c7d">m_V</a></td></tr>
<tr class="separator:a6cc720e646b5fb26e5285b1838f71c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a210bd7d627ff486ac874ab4c226ab6c8"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a210bd7d627ff486ac874ab4c226ab6c8">Empty</a></td></tr>
<tr class="separator:a210bd7d627ff486ac874ab4c226ab6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_o_n___geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_o_n___geometry')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_o_n___geometry.html">ON_Geometry</a></td></tr>
<tr class="memitem:a03dcd2409adc639499e0ca07944dfd0c inherit pub_static_attribs_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">const static <a class="el" href="class_o_n___geometry.html">ON_Geometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a03dcd2409adc639499e0ca07944dfd0c">Unset</a></td></tr>
<tr class="separator:a03dcd2409adc639499e0ca07944dfd0c inherit pub_static_attribs_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a283e17b42b01749486e447a56acd5f60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a283e17b42b01749486e447a56acd5f60">m_invalid_count</a></td></tr>
<tr class="separator:a283e17b42b01749486e447a56acd5f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d1b43c587734c9c34ee58324fd88b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh_curvature_stats.html">ON_MeshCurvatureStats</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a14d1b43c587734c9c34ee58324fd88b4">m_kstat</a> [4]</td></tr>
<tr class="memdesc:a14d1b43c587734c9c34ee58324fd88b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">gaussian,mean,min,max,sectionx,sectiony,sectionz  <a href="class_o_n___mesh.html#a14d1b43c587734c9c34ee58324fd88b4">More...</a><br /></td></tr>
<tr class="separator:a14d1b43c587734c9c34ee58324fd88b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf44985cbb5e3d74e80d342226cc259e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh_parameters.html">ON_MeshParameters</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aaf44985cbb5e3d74e80d342226cc259e">m_mesh_parameters</a></td></tr>
<tr class="separator:aaf44985cbb5e3d74e80d342226cc259e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60c942b6427718bf0ea8e0b398a61fa"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#aa60c942b6427718bf0ea8e0b398a61fa">m_nbox</a> [2][3]</td></tr>
<tr class="separator:aa60c942b6427718bf0ea8e0b398a61fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64decd77fe7b70c0fab3a910844667e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh_partition.html">ON_MeshPartition</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a64decd77fe7b70c0fab3a910844667e4">m_partition</a></td></tr>
<tr class="memdesc:a64decd77fe7b70c0fab3a910844667e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">sub-mesh information rendering large meshes  <a href="class_o_n___mesh.html#a64decd77fe7b70c0fab3a910844667e4">More...</a><br /></td></tr>
<tr class="separator:a64decd77fe7b70c0fab3a910844667e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e88e56788c06e475b27d239f78c7656"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a0e88e56788c06e475b27d239f78c7656">m_quad_count</a></td></tr>
<tr class="separator:a0e88e56788c06e475b27d239f78c7656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c5690c95d3f26fc86438061f131759"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a26c5690c95d3f26fc86438061f131759">m_tbox</a> [2][2]</td></tr>
<tr class="memdesc:a26c5690c95d3f26fc86438061f131759"><td class="mdescLeft">&#160;</td><td class="mdescRight">2d bounding box of all referenced texture coordinates  <a href="class_o_n___mesh.html#a26c5690c95d3f26fc86438061f131759">More...</a><br /></td></tr>
<tr class="separator:a26c5690c95d3f26fc86438061f131759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72a9c0b4169a22209bc923d7450d3fae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___mesh_topology.html">ON_MeshTopology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a72a9c0b4169a22209bc923d7450d3fae">m_top</a></td></tr>
<tr class="memdesc:a72a9c0b4169a22209bc923d7450d3fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation - mesh topology.  <a href="class_o_n___mesh.html#a72a9c0b4169a22209bc923d7450d3fae">More...</a><br /></td></tr>
<tr class="separator:a72a9c0b4169a22209bc923d7450d3fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093d11d8fa0cc22dee2f284cbc3790e0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___mesh.html#a093d11d8fa0cc22dee2f284cbc3790e0">m_triangle_count</a></td></tr>
<tr class="separator:a093d11d8fa0cc22dee2f284cbc3790e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_class_o_n___object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_o_n___object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_o_n___object.html">ON_Object</a></td></tr>
<tr class="memitem:a7f520e987ffa14e71b06493340f9956c inherit pub_types_class_o_n___object"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956c">UserDataConflictResolution</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956caba9e24ac13ffcde7d2f6b554a33df7cd">UserDataConflictResolution::destination_object</a> = 0, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956ca34f1a09f0cf6c7e702b6aad2260c6b0f">UserDataConflictResolution::source_object</a> = 1, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956cad741a50b9ec9ac0de6491a83bc5b166f">UserDataConflictResolution::source_copycount_gt</a> = 2, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956ca35055504b8fe7e98f97c2b2ea6168ad2">UserDataConflictResolution::source_copycount_ge</a> = 3, 
<br />
&#160;&#160;<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956ca6c944380c6bd502741a041a82ad00a5a">UserDataConflictResolution::destination_copycount_gt</a> = 4, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956cadb77cee2050a09b500c679688e45a105">UserDataConflictResolution::destination_copycount_ge</a> = 5, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956ca880ec7882afd9386e91140bf4f77e594">UserDataConflictResolution::delete_item</a> = 6
<br />
 }</td></tr>
<tr class="separator:a7f520e987ffa14e71b06493340f9956c inherit pub_types_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aae117c9788c5c8f66ba927af0bc37d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae117c9788c5c8f66ba927af0bc37d13">&#9670;&nbsp;</a></span>ON_Mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_Mesh::ON_Mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ee37aa93246b181563b9aabed637a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee37aa93246b181563b9aabed637a0e">&#9670;&nbsp;</a></span>ON_Mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_Mesh::ON_Mesh </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initial_face_array_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>initial_vertex_array_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_vertex_normals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_texture_coordinates</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initial_face_array_capacity</td><td>initial face array capacity </td></tr>
    <tr><td class="paramname">initial_vertex_array_capacity</td><td>initial vertex array capacity </td></tr>
    <tr><td class="paramname">has_vertex_normals</td><td>true if mesh has vertex normals </td></tr>
    <tr><td class="paramname">has_texture_coordinates</td><td>true if mesh has texture coordinates </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a332c7a7ffd31f4670a9aceee1d4d959f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332c7a7ffd31f4670a9aceee1d4d959f">&#9670;&nbsp;</a></span>ON_Mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_Mesh::ON_Mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8da15ad65efff0f1967534245d81383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8da15ad65efff0f1967534245d81383">&#9670;&nbsp;</a></span>~ON_Mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_Mesh::~ON_Mesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a34cab5280e39fd919b5e019817ce04dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34cab5280e39fd919b5e019817ce04dc">&#9670;&nbsp;</a></span>AddNgon() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::AddNgon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ngon_fi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add a new ngon to the mesh. Does not allow the creation of inner boundaries. Parameters: ngon_fi[] An array of distinct <a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450" title="m_F[] facets (triangles or quads)">ON_Mesh.m_F</a>[] face indices referencing a set of connected faces. Returns: index of the new n-gon. -1: If input information is not valid. </p>

</div>
</div>
<a id="adb812b572f4ced402594a186fde4d243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb812b572f4ced402594a186fde4d243">&#9670;&nbsp;</a></span>AddNgon() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::AddNgon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ngon_fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermitHoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add a new ngon to the mesh. Parameters: ngon_fi[] An array of distinct <a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450" title="m_F[] facets (triangles or quads)">ON_Mesh.m_F</a>[] face indices referencing a set of connected faces. bPermitHoles If true, also ngons that contain inner boundaries are allowed. Returns: index of the new n-gon. -1: If input information is not valid. <br  />
 </p>

</div>
</div>
<a id="abb3d88b51027b886d9b467eda75036eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3d88b51027b886d9b467eda75036eb">&#9670;&nbsp;</a></span>AddNgon() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::AddNgon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td>
          <td class="paramname"><em>ngon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: An expert user function that unconditionally appends the ngon pointer to <a class="el" href="class_o_n___mesh.html#ab91153bed501502cd587b18884c48d22">ON_Mesh.m_Ngon</a>[]. Parameters: ngon - [in] Returns: ON_UNSET_UINT_INDEX: invalid input &lt; ON_UNSET_UINT_INDEX: index of the new n-gon. </p>

</div>
</div>
<a id="a1f89a4ba64a5e25a7a20ad3ac6881ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f89a4ba64a5e25a7a20ad3ac6881ab7">&#9670;&nbsp;</a></span>AddNgon() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::AddNgon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Fcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add a new ngon to the mesh. Does not allow the creation of inner boundaries. Parameters: Fcount - [in] Number of face that make up the ngon. ngon_fi[] An array of N distinct <a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450" title="m_F[] facets (triangles or quads)">ON_Mesh.m_F</a>[] face indices referencing a set of connected faces. Returns: index of the new n-gon. -1: If input information is not valid. </p>

</div>
</div>
<a id="a3cb115a0baab6a1b37bbc5c95f61937e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb115a0baab6a1b37bbc5c95f61937e">&#9670;&nbsp;</a></span>AddNgon() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::AddNgon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Fcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermitHoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add a new ngon to the mesh. Parameters: Fcount - [in] Number of face that make up the ngon. ngon_fi[] An array of N distinct <a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450" title="m_F[] facets (triangles or quads)">ON_Mesh.m_F</a>[] face indices referencing a set of connected faces. bPermitHoles If true, also ngons that contain inner boundaries are allowed. Returns: index of the new n-gon. -1: If input information is not valid. </p>

</div>
</div>
<a id="a19a5572ee9d7de8a703aa4a432934655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a5572ee9d7de8a703aa4a432934655">&#9670;&nbsp;</a></span>AddNgon() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::AddNgon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Vcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Fcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add a new ngon to the mesh. Parameters: Vcount - number of vertices and number of sides in the n-gon ngon_vi[] - in An array of N distinct <a class="el" href="class_o_n___mesh.html#a6cc720e646b5fb26e5285b1838f71c7d">ON_Mesh.m_V</a>[] vertex indices Fcount - [in] Number of face that make up the ngon. ngon_fi[] An array of N distinct <a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450" title="m_F[] facets (triangles or quads)">ON_Mesh.m_F</a>[] face indices The outer boundary of this group of faces should be the list of vertices passes as ngon_vi[] Returns: index of the new n-gon. -1: If input information is not valid. </p>

</div>
</div>
<a id="a21cc7b60eb21a8836512136c951929c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21cc7b60eb21a8836512136c951929c2">&#9670;&nbsp;</a></span>AddNgon_Expert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::AddNgon_Expert </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Fcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermitHoles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh_vertex_face_map.html">ON_MeshVertexFaceMap</a> *&#160;</td>
          <td class="paramname"><em>vertexFaceMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add a new ngon to the mesh. WARNING! The usage of this particular overload is discouraged unless its usage is critical for performance. If vertexFaceMap is set to something other than nullptr, then the value will be filled and can be re-fed to the function. Parameters: Fcount - [in] Number of face that make up the ngon. ngon_fi[] An array of N distinct <a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450" title="m_F[] facets (triangles or quads)">ON_Mesh.m_F</a>[] face indices referencing a set of connected faces. bPermitHoles If true, also ngons that contain inner boundaries are allowed. faceVertexMap If nullptr, this will be set to a new faceVertexMap. Must be freed with <a class="el" href="group__open_n_u_r_b_s.html#ga11bd5c38846c84d11a00bd1b1cd31e61">onfree()</a>. It is responsability of the user to call <a class="el" href="group__open_n_u_r_b_s.html#ga11bd5c38846c84d11a00bd1b1cd31e61">onfree()</a> on the created object. Returns: index of the new n-gon. -1: If input information is not valid. </p>

</div>
</div>
<a id="a61cd035aeaea26d6814a8711a657a00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61cd035aeaea26d6814a8711a657a00c">&#9670;&nbsp;</a></span>AddNgons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::AddNgons </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fb69972dd0035076ee1a393e7aae1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb69972dd0035076ee1a393e7aae1a0">&#9670;&nbsp;</a></span>AddPlanarNgons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::AddPlanarNgons </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *const *&#160;</td>
          <td class="paramname"><em>vertex_face_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>planar_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_ngon_vertex_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_ngon_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowHoles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: For each set of coplanar connected faces in the mesh that qualifies as an n-gon, an new <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> will be appended to the Ngons[] array. Faces belonging to existing ngons are ignored. Parameters: vertex_face_map - [in]</p><ul>
<li>Pass null if you don't have one.</li>
<li>See <a class="el" href="class_o_n___mesh_vertex_face_map.html">ON_MeshVertexFaceMap</a> for details about making one. The only reason to pass one in is because you need it for other reasons or you already have one. planar_tolerance - [in] For faces to be coplanar, all the points in the n-gon must be withing planar_tolerance of the plane defined by the first face in the n-gon. minimum_ngon_vertex_count - [in] n-gons must have at least this many sides in order to be added. minimum_ngon_face_count - [in] n-gons must have at least this many faces in order to be added. bAllowHoles - [in] If true, then the added ngons are permitted to have holes. bSeparateNgons - [in] If true, any face belonging to a new ngon, will not share vertices with a face that does not belong to that ngon and the vertex normals for all vertices in an ngon will be set to the plane's normal. bSetNgonVertexNormals - [in] If bSeparateNgons and bSetNgonVertexNormals are both true, then all vertex normals vertices in a new ngon will be set to the ngon's plane normal. bRemoveNgonInteriorPoints - [in] If true, the new ngons will not have interior vertices. This will result in the ngon being retriangluated when connected coplanar faces Returns: The number of new n-gons appended to m_Ngons[] </li>
</ul>

</div>
</div>
<a id="ab9b7951b3d2892e63d866c4ff8d65dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9b7951b3d2892e63d866c4ff8d65dfd">&#9670;&nbsp;</a></span>AllocateNgon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a>* ON_Mesh::AllocateNgon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Vcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Fcount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: An expert user function that allocates an ngon from heap memory managed by this <a class="el" href="class_o_n___mesh.html">ON_Mesh</a>. Parameters: N - [in] (&gt;= 3) Fcount - [in] Returns: A pointer to an uninitialized ngon. Use the ON_Mesh::AddNgon(ngon) to add this ngon to the mesh or use DeallocateNgon(ngon) to deallocate the ngon. </p>

</div>
</div>
<a id="a3c0198c652c36b53f12c0d74cd595fb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0198c652c36b53f12c0d74cd595fb3">&#9670;&nbsp;</a></span>Append() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::Append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>appends a copy of mesh to this and updates indices of appended mesh parts </p>

</div>
</div>
<a id="ae777b88e5fabcbc1c30be351f6fc66ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae777b88e5fabcbc1c30be351f6fc66ef">&#9670;&nbsp;</a></span>Append() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::Append </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *const *&#160;</td>
          <td class="paramname"><em>meshes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Append a list of meshes. This function is much more efficient than making repeated calls to <a class="el" href="class_o_n___mesh.html#a3c0198c652c36b53f12c0d74cd595fb3">ON_Mesh::Append(const ON_Mesh&amp;)</a> when lots of meshes are being joined into a single large mesh. Parameters: count - [in] length of meshes[] array. meshes - [in] array of meshes to append. </p>

</div>
</div>
<a id="ad16aa24cbbaec4719b4d8c769c3c228a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16aa24cbbaec4719b4d8c769c3c228a">&#9670;&nbsp;</a></span>AppendDuplicateVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::AppendDuplicateVertex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vertex_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Use this function to append a duplicate of an existing vertex. Parameters: vertex_index - [in] index of the existing vertex Returns: If vertex_index is valid, the index of the duplicate is returned. Otherwise, ON_UNSET_UINT_INDEX is returned. Remarks: This function duplicates all information associated with the input vertex and is a good way to insure that optional vertex information like color, texture, surface parameters, curvatures, vertex normals, and so on get duplicated as well. </p>

</div>
</div>
<a id="a6d01c5ae22270259f4b6e9479435dc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d01c5ae22270259f4b6e9479435dc1b">&#9670;&nbsp;</a></span>Area()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_Mesh::Area </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>error_estimate</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Compute area of the mesh. Parameters: error_estimate - [out] if not nullptr, an upper bound on the error in the area calculation is returned. Example: </p><pre class="fragment">      ON_Mesh mesh = ...;
      double area, error_estimate;
      area = mesh.Area(&amp;error_estimate);
      printf("mesh area = %g (+/- %g)\n",area,error_estimate);
</pre><p>Returns: Area of the mesh. </p>

</div>
</div>
<a id="a871cd5388f731d384c4e0b1691466d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871cd5388f731d384c4e0b1691466d8e">&#9670;&nbsp;</a></span>AreaCentroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_Mesh::AreaCentroid </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>area</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Compute area centroid of the mesh. Parameters: area - [out] it not nullptr, area of the mesh Returns: Location of area centroid. See Also: <a class="el" href="class_o_n___mesh.html#a30a5c36e20952ce0093357198bea41de">ON_Mesh::AreaMassProperties</a> </p>

</div>
</div>
<a id="a30a5c36e20952ce0093357198bea41de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a5c36e20952ce0093357198bea41de">&#9670;&nbsp;</a></span>AreaMassProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::AreaMassProperties </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___mass_properties.html">ON_MassProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bArea</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFirstMoments</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSecondMoments</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bProductMoments</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Calculate area mass properties of the mesh. Parameters: mp - [out] bArea - [in] true to calculate area bFirstMoments - [in] true to calculate area first moments, area and area centroid. bSecondMoments - [in] true to calculate area second moments. bProductMoments - [in] true to calculate area product moments. Returns: True if successful. </p>

</div>
</div>
<a id="a957ffd9a3063108424eac2fa074679bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957ffd9a3063108424eac2fa074679bf">&#9670;&nbsp;</a></span>CachedTextureCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___texture_coordinates.html">ON_TextureCoordinates</a>* ON_Mesh::CachedTextureCoordinates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0a3818ee6b07ff3eb51041bf73043aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a3818ee6b07ff3eb51041bf73043aca">&#9670;&nbsp;</a></span>Cleanup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::Cleanup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveNgons</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Calls the latest version of the detailed cleanup command passing the value for bRemoveNgons and setting all other parameters to true. Parameters: bRemoveNgons - [in] If true, all n-gon information is removed. </p>

</div>
</div>
<a id="a00a7d6a2dacb62aedb47da2078085d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a7d6a2dacb62aedb47da2078085d8a">&#9670;&nbsp;</a></span>Cleanup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::Cleanup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveNgons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveDegenerateFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCompact</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Removes and unsets all possible cached information and then calls <a class="el" href="class_o_n___mesh.html#aef1590fcf5ed72349c51fc2da3c5a5e6">Compact()</a>. Parameters: bRemoveNgons - [in] If true, all n-gon information is removed. bRemoveDegenerateFaces - [in] If true, <a class="el" href="class_o_n___mesh.html#a285f54befb68149d3a23ac29fc1042a7" title="returns number of degenerate faces">CullDegenerateFaces()</a> is used to remove degenerate faces. bCompact - [in] If true, <a class="el" href="class_o_n___mesh.html#aef1590fcf5ed72349c51fc2da3c5a5e6">Compact()</a> is called after removing cached information. </p>

</div>
</div>
<a id="abfbed67618c3ce4d2811331d61b78efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfbed67618c3ce4d2811331d61b78efa">&#9670;&nbsp;</a></span>CollapseEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::CollapseEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>topei</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mesh editing Description: Replace a mesh edge with a vertex at its center and update adjacent faces as needed. Parameters: topei - [in] index of edge in MeshTopology().m_tope[] array Returns: true if successful. </p>

</div>
</div>
<a id="a116aab0639f1fd05524f06f25a0eb533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a116aab0639f1fd05524f06f25a0eb533">&#9670;&nbsp;</a></span>CombineCoincidentVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::CombineCoincidentVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3f_vector.html">ON_3fVector</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>finds all coincident vertices and merges them if break angle is small enough </p>

</div>
</div>
<a id="a5b8698cebf5ea96d81e3c1c9821a26f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8698cebf5ea96d81e3c1c9821a26f2">&#9670;&nbsp;</a></span>CombineIdenticalVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::CombineIdenticalVertices </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoreVertexNormals</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoreTextureCoordinates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combines identical vertices. Parameters: bIgnoreVertexNormals - [in] If true, then vertex normals are ignored when comparing vertices. bIgnoreTextureCoordinates - [in] If true, then vertex texture coordinates, colors, and principal curvatures are ignored when comparing vertices. Returns: True if the mesh is changed, in which case the returned mesh will have fewer vertices than the input mesh. </p>

</div>
</div>
<a id="aef1590fcf5ed72349c51fc2da3c5a5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1590fcf5ed72349c51fc2da3c5a5e6">&#9670;&nbsp;</a></span>Compact()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::Compact </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Removes any unreferenced objects from arrays, reindexes as needed, and shrinks arrays to minimum required size. </p>

</div>
</div>
<a id="a75f00ddce6c37d48f37bf2b34cf89ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f00ddce6c37d48f37bf2b34cf89ead">&#9670;&nbsp;</a></span>ComputeFaceNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ComputeFaceNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>computes face normal of indexed face </p>

</div>
</div>
<a id="a1e1b2cfc861f0d4eb50c8371948cab1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e1b2cfc861f0d4eb50c8371948cab1d">&#9670;&nbsp;</a></span>ComputeFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ComputeFaceNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>compute face normals for all faces </p>

</div>
</div>
<a id="a800e2ba9bc8d9707d412acd265790851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800e2ba9bc8d9707d412acd265790851">&#9670;&nbsp;</a></span>ComputeVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ComputeVertexNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>uses face normals to cook up a vertex normal </p>

</div>
</div>
<a id="ae00a4a72333babfcd3ceff79cfc8ffa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00a4a72333babfcd3ceff79cfc8ffa4">&#9670;&nbsp;</a></span>ConvertNonPlanarQuadsToTriangles() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::ConvertNonPlanarQuadsToTriangles </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>planar_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_tolerance_radians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>split_method</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Splits non-planer quads into two triangles.</p>
<p>Parameters: planar_tolerance - [in] If planar_tolerance &gt;= 0, then a quad is split if its vertices are not coplaner. <br  />
</p>
<p>If both planar_tolerance = ON_UNSET_VALUE and angle_tolerance_radians &gt;= 0.0, then the planarity test is skipped.</p>
<p>If both planar_tolerance = ON_UNSET_VALUE and angle_tolerance_radians = ON_UNSET_VALUE, then all quads are split.</p>
<p>angle_tolerance_radians - [in] If angle_tolerance_radians &gt;= 0.0, then a quad is split if the angle between opposite corner normals is &gt; angle_tolerance_radians. The corner normal is the normal to the triangle formed by two adjacent edges and the diagonal connecting their endpoints. A quad has for corner normals.</p>
<p>If both angle_tolerance_radians = ON_UNSET_VALUE and planar_tolerance &gt;= 0.0, then the corner normal angle test is skipped.</p>
<p>If both planar_tolerance = ON_UNSET_VALUE and angle_tolerance_radians = ON_UNSET_VALUE, then all quads are split.</p>
<p>split_method - [in] 0 default Currently divides along the short diagonal. This may be changed as better methods are found or preferences change. By passing zero, you let the developers of this code decide what's best for you over time. 1 divide along the short diagonal 2 divide along the long diagonal 3 minimize resulting area 4 maximize resulting area 5 minimize angle between triangle normals 6 maximize angle between triangle normals</p>
<p>bDeleteNgonsContainingSplitQuads - [in] If true, ngons that contain a split quad are deleted.</p>
<p>Returns: Number of quads that were converted to triangles. </p>

</div>
</div>
<a id="a0529b451509d9f1ce30e57b0e54b1fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0529b451509d9f1ce30e57b0e54b1fda">&#9670;&nbsp;</a></span>ConvertNonPlanarQuadsToTriangles() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::ConvertNonPlanarQuadsToTriangles </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>planar_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_tolerance_radians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>split_method</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDeleteNgonsContainingSplitQuads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accc2de02378ef1ce0b3f4fd71f186b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accc2de02378ef1ce0b3f4fd71f186b7a">&#9670;&nbsp;</a></span>ConvertQuadsToTriangles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ConvertQuadsToTriangles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Splits all quads along the short diagonal. </p>

</div>
</div>
<a id="a728e81940561392fbcc5d6def5c53abc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a728e81940561392fbcc5d6def5c53abc">&#9670;&nbsp;</a></span>ConvertTrianglesToQuads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ConvertTrianglesToQuads </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_tol_radians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_diagonal_length_ratio</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Joins adjacent triangles into quads if the resulting quad is nice. Parameters: angle_tol_radians - [in] Used to compare adjacent triangles' face normals. For two triangles to be considered, the angle between their face normals has to be &lt;= angle_tol_radians. When in doubt use ON_PI/90.0 (2 degrees). min_diagonal_length_ratio - <a href="= 1.0">in</a> For two triangles to be considered the ratio of the resulting quad's diagonals (length of the shortest diagonal)/(length of longest diagonal). has to be &gt;= min_diagonal_length_ratio. When in doubt us .875. </p>

</div>
</div>
<a id="af0bcbdf815fb79bfe45a077a46a46357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0bcbdf815fb79bfe45a077a46a46357">&#9670;&nbsp;</a></span>CopyComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_Mesh::CopyComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>destination_mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Copy the subset of the mesh idenfied in the component list. Parameters: ci_list - [in] ci_count - [in] ci_list[] is an array of ci_count components that identify the parts of the mesh to copy. If a face or ngon is specified, then any vertices or faces needed for a valid copy are automatically copied as well. destination_mesh - [in] If null, a new mesh is allocated for the copy. If not null, the copy is put in this mesh. Return: null - invalid input - no copy created not null - a pointer to the copy. </p>

</div>
</div>
<a id="a7cc45502751438b2926f116b222f0a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc45502751438b2926f116b222f0a33">&#9670;&nbsp;</a></span>CopyComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_Mesh::CopyComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>destination_mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Copy the subset of the mesh idenfied in the component list. Parameters: ci_list - [in] ci_list[] is an array of ci_count components that identify the parts of the mesh to copy. If a face or ngon is specified, then any vertices or faces needed for a valid copy are automatically copied as well. destination_mesh - [in] If null, a new mesh is allocated for the copy. If not null, the copy is put in this mesh. Return: null - invalid input - no copy created not null - a pointer to the copy. </p>

</div>
</div>
<a id="afce044b87f7573b019c215063fe85e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce044b87f7573b019c215063fe85e93">&#9670;&nbsp;</a></span>CountQuads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::CountQuads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a03df67e386dc849f2c3badf9280da0c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03df67e386dc849f2c3badf9280da0c6">&#9670;&nbsp;</a></span>CreateNgonMap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int* ON_Mesh::CreateNgonMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user function to update n-gon map after the expert user does something to make the current one invalid. Returns: null: The mesh does not have ngon-information. an array of length m_F.Count() ngon_map[]</p><ul>
<li>If ngon_map[fi] &gt;= 0, then ON_MeshFace.m_F[fi] belongs to ON_Mesh.Ngon(ngon_map[fi]).</li>
<li>Otherwise, ngon_map[fi] = -1. </li>
</ul>

</div>
</div>
<a id="a43669dda3f5ca8bd9151487fa915c60e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43669dda3f5ca8bd9151487fa915c60e">&#9670;&nbsp;</a></span>CreateNgonMap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::CreateNgonMap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user function to construct n-gon map even on const objects after the expert user did something that made the current one invalid. map [out]: The map is modified to match the new ngon map, if true is returned. Returns: A value indicating if the mesh has ngon information. The map is an array of length m_F.Count(), ngon_map[]</p><ul>
<li>If ngon_map[fi] &gt;= 0, then ON_MeshFace.m_F[fi] belongs to ON_Mesh.Ngon(ngon_map[fi]).</li>
<li>Otherwise, ngon_map[fi] = -1. </li>
</ul>

</div>
</div>
<a id="a9e6c90461ff94aa261d94fb4f6aaa160"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6c90461ff94aa261d94fb4f6aaa160">&#9670;&nbsp;</a></span>CreateNgonMap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::CreateNgonMap </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_map</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user function to construct n-gon map even on const objects after the expert user did something that made the current one invalid. map [in-out]: The map must have at least m_F elements It is modified to match the new ngon map, if true is returned. Returns: A value indicating if the mesh has ngon information. The map is an array of length m_F.Count(), ngon_map[]</p><ul>
<li>If ngon_map[fi] &gt;= 0, then ON_MeshFace.m_F[fi] belongs to ON_Mesh.Ngon(ngon_map[fi]).</li>
<li>Otherwise, ngon_map[fi] = -1. </li>
</ul>

</div>
</div>
<a id="ac4bc3aabd5155e282910738daa1b3c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4bc3aabd5155e282910738daa1b3c62">&#9670;&nbsp;</a></span>CreatePartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___mesh_partition.html">ON_MeshPartition</a>* ON_Mesh::CreatePartition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mesh partitions</p>
<p>In ancient times, some rendering engines were only able to process small batches of triangles and th <a class="el" href="class_o_n___mesh.html#ac4bc3aabd5155e282910738daa1b3c62">CreatePartition()</a> function was provided to partition the mesh into subsets of vertices and faces that those renering engines could handle. </p>

</div>
</div>
<a id="a105368d48f28f2c7def8eafc7d2e7e20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a105368d48f28f2c7def8eafc7d2e7e20">&#9670;&nbsp;</a></span>CullClashingFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::CullClashingFaces </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>what_to_cull</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Cull clashing faces from the mesh. Parameters: what_to_cull - [in] 0: when a pair of faces clash, cull both faces 1: when a pair of faces clash, leave the face with the longest edge. 2: when a pair of faces clash, cull the face with the longest edge. 3: when a pair of faces clash, leave the face with the largest area. 4: when a pair of faces clash, cull the face with the largest area. Returns: Number of faces culled from the mesh. Remarks: If a large face clashes with many small faces, the large face and one small face will be removed. When a degenerate face is encountered, it is also culled. </p>

</div>
</div>
<a id="a285f54befb68149d3a23ac29fc1042a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285f54befb68149d3a23ac29fc1042a7">&#9670;&nbsp;</a></span>CullDegenerateFaces()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::CullDegenerateFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns number of degenerate faces </p>

</div>
</div>
<a id="a95987b3668ca3c6958426adb4d3268ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95987b3668ca3c6958426adb4d3268ec">&#9670;&nbsp;</a></span>CullDegenerates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::CullDegenerates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Removes degenerate and unused mesh components. Returns: Number of removed components; </p>

</div>
</div>
<a id="a2a28c1db5796622470a0d8cd4c8d4f7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a28c1db5796622470a0d8cd4c8d4f7c">&#9670;&nbsp;</a></span>CullUnusedVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::CullUnusedVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns number of culled vertices </p>

</div>
</div>
<a id="ad7f71b595855073034c29bd74c15305f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f71b595855073034c29bd74c15305f">&#9670;&nbsp;</a></span>DataCRC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#gaea03c6f4bab106103ada72c766f7fe5c">ON__UINT32</a> ON_Mesh::DataCRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gaea03c6f4bab106103ada72c766f7fe5c">ON__UINT32</a>&#160;</td>
          <td class="paramname"><em>current_remainder</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___object.html#af51d5fcec9379ad9b7a56ac4dfc9a8b2">ON_Object::DataCRC</a> override </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#af51d5fcec9379ad9b7a56ac4dfc9a8b2">ON_Object</a>.</p>

</div>
</div>
<a id="a9b7c5789e6d14e09a8255134fc5e390d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7c5789e6d14e09a8255134fc5e390d">&#9670;&nbsp;</a></span>DeallocateNgon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::DeallocateNgon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td>
          <td class="paramname"><em>ngon</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: An expert user function that deallocates an ngon that was created by <a class="el" href="class_o_n___mesh.html#ab9b7951b3d2892e63d866c4ff8d65dfd">AllocateNgon()</a>. Parameters: ngon - [in] </p>

</div>
</div>
<a id="a11d7dd764beb453d7b613a2bf090a1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d7dd764beb453d7b613a2bf090a1b7">&#9670;&nbsp;</a></span>DeleteComponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::DeleteComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>ci</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Calls the detailed version of <a class="el" href="class_o_n___mesh.html#a24b28034b4aeb5425af27969919eea63">DeleteComponents()</a> with bool bIgnoreInvalidComponents = true; bool bRemoveDegenerateFaces = false; bool bRemoveUnusedVertices = true; bool bRemoveEmptyNgons = true; </p>

</div>
</div>
<a id="a57ee1525a489f197b6a1a2cb9d0f439e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ee1525a489f197b6a1a2cb9d0f439e">&#9670;&nbsp;</a></span>DeleteComponents() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::DeleteComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Calls the detailed version of <a class="el" href="class_o_n___mesh.html#a24b28034b4aeb5425af27969919eea63">DeleteComponents()</a> with bool bIgnoreInvalidComponents = true; bool bRemoveDegenerateFaces = false; bool bRemoveUnusedVertices = true; bool bRemoveEmptyNgons = true; </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#aa67be7d8cc76ec82ae22a30093ecf98f">ON_Object</a>.</p>

</div>
</div>
<a id="a24b28034b4aeb5425af27969919eea63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b28034b4aeb5425af27969919eea63">&#9670;&nbsp;</a></span>DeleteComponents() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::DeleteComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoreInvalidComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveDegenerateFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveUnusedVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveEmptyNgons</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Delete the portions of the mesh identified in ci_list[]. Parameters: ci_list - [in] List of components to delete. ci_list_count - [in] Number of elements in the ci_list[] array. Can be zero if you are using this function to remove unused vertices or empty ngons. bIgnoreInvalidComponents - [in] If true, invalid elements in ci_list[] are ignored. If false and ci_list[] contains an invalid element, then no changes are made and false is returned. bRemoveDegenerateFaces - [in] If true, remove degenerate faces. bCullUnusedVertices - [in] Remove vertices that are not referenced by a face. Pass true unless you have a good reason for keeping unreferenced vertices. bRemoveEmptyNgons - [in] Remove ngons that are empty. Pass true unless you have a good reason for keeping empty ngons. Returns: True: succesful False: failure - no changes. </p>

</div>
</div>
<a id="ae9c08746dc896cf1de9be6087f74e8c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c08746dc896cf1de9be6087f74e8c3">&#9670;&nbsp;</a></span>DeleteComponents() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::DeleteComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoreInvalidComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveDegenerateFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveUnusedVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRemoveEmptyNgons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>faceMap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Delete the portions of the mesh identified in ci_list[]. Parameters: ci_list - [in] List of components to delete. ci_list_count - [in] Number of elements in the ci_list[] array. Can be zero if you are using this function to remove unused vertices or empty ngons. bIgnoreInvalidComponents - [in] If true, invalid elements in ci_list[] are ignored. If false and ci_list[] contains an invalid element, then no changes are made and false is returned. bRemoveDegenerateFaces - [in] If true, remove degenerate faces. bCullUnusedVertices - [in] Remove vertices that are not referenced by a face. Pass true unless you have a good reason for keeping unreferenced vertices. bRemoveEmptyNgons - [in] Remove ngons that are empty. Pass true unless you have a good reason for keeping empty ngons. faceMap - [i] If anything other than nullptr is passed in, then faceMap[fi] is the index of the new face after the removal of vertices, faces, etc. This needs to be allocated to be at least m_F.Count() long. Returns: True: succesful False: failure - no changes. </p>

</div>
</div>
<a id="a8ae0206ba06af5b6a2895582caad8ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae0206ba06af5b6a2895582caad8ca0">&#9670;&nbsp;</a></span>DeleteComponents() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::DeleteComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Calls the detailed version of <a class="el" href="class_o_n___mesh.html#a24b28034b4aeb5425af27969919eea63">DeleteComponents()</a> with bool bIgnoreInvalidComponents = true; bool bRemoveDegenerateFaces = false; bool bRemoveUnusedVertices = true; bool bRemoveEmptyNgons = true; </p>

</div>
</div>
<a id="afc0108f56f056f60f2918924e1152103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0108f56f056f60f2918924e1152103">&#9670;&nbsp;</a></span>DeleteFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::DeleteFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshfi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Removes a face from a mesh and does not alter the geometry of the remaining mesh. Parameters: meshfi - [in] index of face in <a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450" title="m_F[] facets (triangles or quads)">ON_Mesh.m_F</a>[] array Remarks: This function calls <a class="el" href="class_o_n___mesh.html#ad638bb8cfee148bb00f5224fa2d0beb9">DestroyTopology()</a> and <a class="el" href="class_o_n___mesh.html#aa78b1905e2cc313ea6c336a1ecc761e7">DestroyPartition()</a>. The caller is responsible for calling <a class="el" href="class_o_n___mesh.html#aef1590fcf5ed72349c51fc2da3c5a5e6">Compact()</a> if that step is required. Returns: true if successful </p>

</div>
</div>
<a id="afcfff4b2fada773a65109d43fc1c42b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcfff4b2fada773a65109d43fc1c42b9">&#9670;&nbsp;</a></span>DeleteMeshParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::DeleteMeshParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add8ff2bad015852719a2517f10967cc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add8ff2bad015852719a2517f10967cc0">&#9670;&nbsp;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a878de28d1068302a28553258ec2e69f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878de28d1068302a28553258ec2e69f4">&#9670;&nbsp;</a></span>DestroyDoublePrecisionVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::DestroyDoublePrecisionVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: The function removes all double precision vertex information. </p>

</div>
</div>
<a id="af769ba8c3f555d132cf0714cd26bcd5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af769ba8c3f555d132cf0714cd26bcd5e">&#9670;&nbsp;</a></span>DestroyHiddenVertexArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::DestroyHiddenVertexArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Destroys the m_H[] array and sets m_hidden_count=0. </p>

</div>
</div>
<a id="aa78b1905e2cc313ea6c336a1ecc761e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78b1905e2cc313ea6c336a1ecc761e7">&#9670;&nbsp;</a></span>DestroyPartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::DestroyPartition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7214a8028954b0a820e64e9b8a61854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7214a8028954b0a820e64e9b8a61854">&#9670;&nbsp;</a></span>DestroyRuntimeCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::DestroyRuntimeCache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDelete</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___object.html#af8435c33ab53af41c22dac75e8917569">ON_Object::DestroyRuntimeCache</a> override </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#af8435c33ab53af41c22dac75e8917569">ON_Object</a>.</p>

</div>
</div>
<a id="ad638bb8cfee148bb00f5224fa2d0beb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad638bb8cfee148bb00f5224fa2d0beb9">&#9670;&nbsp;</a></span>DestroyTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::DestroyTopology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If you modify the mesh in any way that may change its topology, then call <a class="el" href="class_o_n___mesh.html#ad638bb8cfee148bb00f5224fa2d0beb9">DestroyTopology()</a>. Specifically if you add or remove vertices or face, change vertex locations, or change the face m_vi[] values, then you must call <a class="el" href="class_o_n___mesh.html#ad638bb8cfee148bb00f5224fa2d0beb9">DestroyTopology()</a>. </p>

</div>
</div>
<a id="a58b83087a2c0691ef81d44e75ccbe4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b83087a2c0691ef81d44e75ccbe4da">&#9670;&nbsp;</a></span>DestroyTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::DestroyTree </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDeleteTree</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa029aafe4a524b31a986fa46374d6c5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa029aafe4a524b31a986fa46374d6c5b">&#9670;&nbsp;</a></span>Dimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::Dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___geometry.html">ON_Geometry</a> overrides. </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#a0d66ab16e2fddfd1b3e6cf3d6ebbd364">ON_Geometry</a>.</p>

</div>
</div>
<a id="ac4e376f80851554edae4fa183347124a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e376f80851554edae4fa183347124a">&#9670;&nbsp;</a></span>DissolveOrDelete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::DissolveOrDelete </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge faces like <a class="el" href="class_o_n___sub_d.html#a0412e0107132bcad5a3def31ed368f01">ON_SubD::MergeFaces()</a> does. Parameters: ci_list - [in] vertices, edges, and faces that trigger merging. Returns: If ngons were added, then the index of the first added ngon is returned. Otherwise ON_UNSET_UINT_INDEX is returned. </p>

</div>
</div>
<a id="a1b101813d31f261ef0a6ca950cfcf14a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b101813d31f261ef0a6ca950cfcf14a">&#9670;&nbsp;</a></span>DoublePrecisionVertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a>&amp; ON_Mesh::DoublePrecisionVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation - mesh geometry. </p>
<p>Vertex locations In a case where adjacent facets share a vertex location but have distinct normals or texture coordinates at that location, the vertex must be duplicated. Description: Get double precision vertices. If they do not exist, they will be created and match the existing single precision vertices. Returns: Array of double precision vertices. If you modify the values in this array, you must make the same modifications to the single precision vertices, or call UpdateSinglePrecisonVertices(). Example:</p>
<p>/ add a bunch of double precision information <a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a>&amp; dv = mesh.DoublePrecisionVertices(); for ( i = 0; i &lt; lots; i++ ) { dv[i] = ... } / This call updates the single precison values / in m_V[] and sets all the counts and CRCs that / are used in validity checking. mesh.UpdateSinglePrecisonVertices();</p>
<p>Remarks: Avoid mulitple calls to <a class="el" href="class_o_n___mesh.html#a1b101813d31f261ef0a6ca950cfcf14a" title="Implementation - mesh geometry.">DoublePrecisionVertices()</a>. It is most efficient to make one call, save a local reference, and use the local reference as needed. </p>

</div>
</div>
<a id="afce02d0446f6a17f2c4eddbd15b4d636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afce02d0446f6a17f2c4eddbd15b4d636">&#9670;&nbsp;</a></span>DoublePrecisionVertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a>&amp; ON_Mesh::DoublePrecisionVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9621f32fa9123a6feae820085d14a02d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9621f32fa9123a6feae820085d14a02d">&#9670;&nbsp;</a></span>Dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::Dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>for debugging </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a21c7b04a80f1806c3a45f72d7c491a44">ON_Object</a>.</p>

</div>
</div>
<a id="a3ae1553b8fc5e622e1115dee760987f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae1553b8fc5e622e1115dee760987f3">&#9670;&nbsp;</a></span>DuplicateBorder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::DuplicateBorder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>joinOverUnweldedVertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Finds the naked border of a mesh. Parameters: polylines - [in] An array to which objects will be added. joinOverUnweldedVertices - [in] If true, unwelded vertices will stop the polyline. Returns: true if the computation finished successfully, false otherwise. </p>

</div>
</div>
<a id="a7f52a5d5c1b13b9b776fe72a0b7d30d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f52a5d5c1b13b9b776fe72a0b7d30d7">&#9670;&nbsp;</a></span>DuplicateFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_Mesh::DuplicateFace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>face_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Create a mesh that is a single face of this mesh. Parameters: Returns: A pointer to the submesh. If the input mesh parameter is null, then the caller must delete this mesh when it is no longer needed. If the input is invalid, then null is returned. </p>

</div>
</div>
<a id="abaee0bc734648a07a275f51005596d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaee0bc734648a07a275f51005596d69">&#9670;&nbsp;</a></span>EmergencyDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::EmergencyDestroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call only when memory used by this class's members will soon become invalid for reasons beyond your control. <a class="el" href="class_o_n___mesh.html#abaee0bc734648a07a275f51005596d69">EmergencyDestroy()</a> zeros anything that could possibly cause <a class="el" href="class_o_n___mesh.html#af8da15ad65efff0f1967534245d81383">~ON_Mesh()</a> to crash. Calling <a class="el" href="class_o_n___mesh.html#abaee0bc734648a07a275f51005596d69">EmergencyDestroy()</a> under normal conditions will result in <a class="el" href="class_o_n___mesh.html#af8da15ad65efff0f1967534245d81383">~ON_Mesh()</a> leaking memory. </p>

</div>
</div>
<a id="a1278d2924ed75f4a4fc3839cb95933ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1278d2924ed75f4a4fc3839cb95933ea">&#9670;&nbsp;</a></span>EvaluateMeshGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::EvaluateMeshGeometry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___surface.html">ON_Surface</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>evaluate surface at tcoords to set mesh geometry </p>

</div>
</div>
<a id="ad1679331cf0fc060385912d1aaf471bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1679331cf0fc060385912d1aaf471bb">&#9670;&nbsp;</a></span>EvaluatePoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::EvaluatePoint </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___obj_ref.html">ON_ObjRef</a> &amp;&#160;</td>
          <td class="paramname"><em>objref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> override </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#adcb646d6ca698c092b73f2f05373bfc2">ON_Geometry</a>.</p>

</div>
</div>
<a id="afbee1f8aea211a5c2b78932ce6d540e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbee1f8aea211a5c2b78932ce6d540e0">&#9670;&nbsp;</a></span>FaceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::FaceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a9a74ac467f28d007b8191bea463fed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a9a74ac467f28d007b8191bea463fed">&#9670;&nbsp;</a></span>FaceIsHidden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::FaceIsHidden </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshvi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Returns true if the mesh face is hidden. This is a runtime setting that is not saved in 3dm files. Parameters: meshfi - [in] mesh face index. Returns: True if mesh face is hidden. Remarks: A face is hidden if, and only if, at least one of its vertices is hidden. </p>

</div>
</div>
<a id="a850c12c7e0efeb7acd5dbe3256c74b09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850c12c7e0efeb7acd5dbe3256c74b09">&#9670;&nbsp;</a></span>FaceUnsignedCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::FaceUnsignedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6dba1564679d8fd692ace1bdda0462f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dba1564679d8fd692ace1bdda0462f6">&#9670;&nbsp;</a></span>Flip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::Flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverses face orientations and flips vertex and face normals </p>

</div>
</div>
<a id="a422d77aff314fb1f2b8e795e0fa1a206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a422d77aff314fb1f2b8e795e0fa1a206">&#9670;&nbsp;</a></span>FlipFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::FlipFaceNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverses face normals </p>

</div>
</div>
<a id="a28800ae891830cc60f1bd86f3f2f5f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28800ae891830cc60f1bd86f3f2f5f29">&#9670;&nbsp;</a></span>FlipFaceOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::FlipFaceOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverses face orientation (does nothing to normals) </p>

</div>
</div>
<a id="a7e578752dcc1c037e3c3c5c9973fc8d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e578752dcc1c037e3c3c5c9973fc8d8">&#9670;&nbsp;</a></span>FlipNgonOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::FlipNgonOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverses ngon boundary direction </p>

</div>
</div>
<a id="a1981fd37dbe338ada348915342b1d99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1981fd37dbe338ada348915342b1d99d">&#9670;&nbsp;</a></span>FlipVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::FlipVertexNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverses vertex normals </p>

</div>
</div>
<a id="ad55fc7bbc2c7082c2a5b13da37516579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55fc7bbc2c7082c2a5b13da37516579">&#9670;&nbsp;</a></span>From3dPolygon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_Mesh::From3dPolygon </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polygon_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>planar_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>destintation_mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f0120c2518091a21db432e686f39cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0120c2518091a21db432e686f39cd5">&#9670;&nbsp;</a></span>From3dPolygon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_Mesh::From3dPolygon </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>polygon_points_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *&#160;</td>
          <td class="paramname"><em>polygon_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>planar_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>destintation_mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a mesh that fills in a 3d polygon. Parameters: polygon_points_count - [in] &gt;= 3 polygon_points - [in] An array of distinct 3d points that forms a polygon. The points do not have to be coplanar, but they should be close to coplanar if you want a decent result. planar_tolerance - [in] If planar_tolerance &gt;= 0.0 and polygon_points &gt;= 4, then planar_tolerance is a 3d distance tolerance use to determine if the polygon is planar. When a polygon is planar, all vertex normals are identical. When a polygon is not planar, vertex normals may vary. If planar_tolerance is not &gt;= 0.0, then all vertex normals are identical in all cases. destintation_mesh - [in] null or a pointer to the mesh to be used. Returns: A pointer to a mesh that fills the 3d polygon or null if the input is not valid. </p>

</div>
</div>
<a id="a09213661dab9943eab473e8f369f2196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09213661dab9943eab473e8f369f2196">&#9670;&nbsp;</a></span>FromFilteredFaceList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_Mesh::FromFilteredFaceList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>patternLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a mesh from a filtered mesh list. Parameters: original - [in] a mesh input pattern - [in] An array of boolean values. patternLength - [in] Length of pattern. Returns: A pointer to a mesh that is the result, or nullptr. </p>

</div>
</div>
<a id="a9c41bb93f38981333f13fd777fb4e50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c41bb93f38981333f13fd777fb4e50a">&#9670;&nbsp;</a></span>GetBBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::GetBBox </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>boxmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>boxmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGrowBox</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> GetBBox override <br  />
 </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#ad615e08fe92af659c8d10cbb4f8fc5e3">ON_Geometry</a>.</p>

</div>
</div>
<a id="a5405260e85535484e4469b7590d2cdc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5405260e85535484e4469b7590d2cdc7">&#9670;&nbsp;</a></span>GetClashingFacePairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::GetClashingFacePairs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_pair_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clashing_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a list of pairs of faces that clash. Parameters: max_pair_count - [in] If max_pair_count &gt; 0, then at most this many pairs will be appended to the clashing_pairs[] array. If max_pair_count &lt;= 0, then all clashing pairs will be appended to the clashing_pairs[] array. clashing_pairs - [out] The faces indices of clashing pairs are appended to this array. Returns: Number of pairs appended to clashing_pairs[]. </p>

</div>
</div>
<a id="ab8243e8139c5e818bf7a30aa3737e66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8243e8139c5e818bf7a30aa3737e66a">&#9670;&nbsp;</a></span>GetClosestPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::GetClosestPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___m_e_s_h___p_o_i_n_t.html">ON_MESH_POINT</a> *&#160;</td>
          <td class="paramname"><em>Q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maximum_distance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the point on the mesh that is closest to P. Parameters: P - [in] test point Q - [out] point on the mesh maximum_distance = 0.0 - [in] optional upper bound on the distance from P to the mesh. If you are only interested in finding a point Q on the mesh when P.DistanceTo(Q) &lt; maximum_distance, then set maximum_distance to that value. Returns: True if successful. If false, the value of Q is undefined. </p>

</div>
</div>
<a id="a197536fdd69e119ee89d1f787a9dfcf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a197536fdd69e119ee89d1f787a9dfcf8">&#9670;&nbsp;</a></span>GetConnectedComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::GetConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseVertexConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bTopologicalConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>facet_component_labels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mesh components <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> objects can consist of sets of faces that are isolated from any other sets of faces. The following 2 functions will dissect a mesh into these sets, called components. Not to be confused with <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>. Description: Calculates the components of a mesh and sets a label for each face in the facet_component_labels array. Parameters: bUseVertexConnections- [in] If this parameter is true, then facets that share a common vertex are considered connected. If this parameter is false, then facets must share an edge to be considered connected. bUseTopologicalConnections - [in] If this parameter is true, then geometric location is used to determine if facets are connected. If this parameter is false, then facets must share the same vertex or vertices to be considered connected. facet_component_labels- [out] facet_component_labels[] will be an array with the same size as ON_Mesh.m_F.Count() and facet_component_labels[i] is the component id m_F[i] belongs to. The component id will be 1 to the number of compoents. Returns: Number of components on success, 0 on failure </p>

</div>
</div>
<a id="a46b297eb77352e4c82d664ee2ea3cb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b297eb77352e4c82d664ee2ea3cb2a">&#9670;&nbsp;</a></span>GetConnectedComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::GetConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseVertexConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bTopologicalConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; *&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Calculates the components of a mesh and sets a label for each face in the facet_component_labels array. Parameters: bUseVertexConnections- [in] If this parameter is true, then facets that share a common vertex are considered connected. If this parameter is false, then facets must share an edge to be considered connected. bUseTopologicalConnections - [in] If this parameter is true, then geometric location is used to determine if facets are connected. If this parameter is false, then facets must share the same vertex or vertices to be considered connected. components - [out] New components are appended to this array if this parameter is null, then the components are just counted. Returns: Number of components on success, 0 on failure </p>

</div>
</div>
<a id="a692b6ca07ffdcd0ed8b32e4b270d0ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a692b6ca07ffdcd0ed8b32e4b270d0ce1">&#9670;&nbsp;</a></span>GetCurvatureStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::GetCurvatureStats </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n.html#a86bff53cc45eaeb4b4dcd0268b9e1e8f">ON::curvature_style</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh_curvature_stats.html">ON_MeshCurvatureStats</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f2bef19d6d37f651c611b75a80b4a8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f2bef19d6d37f651c611b75a80b4a8b">&#9670;&nbsp;</a></span>GetIntersections() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::GetIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>withTheseOtherMeshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *&#160;</td>
          <td class="paramname"><em>perforatingResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *&#160;</td>
          <td class="paramname"><em>overlapResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>overlapMeshResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *&#160;</td>
          <td class="paramname"><em>cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *&#160;</td>
          <td class="paramname"><em>reporter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get intersections with the current mesh. Intersections between other meshes are ignored. See the parameter description in the function above. </p>

</div>
</div>
<a id="a4c90cb307e886840900b63e91cb74a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c90cb307e886840900b63e91cb74a79">&#9670;&nbsp;</a></span>GetIntersections() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::GetIntersections </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>withTheseOtherMeshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh_intersection_cache.html">ON_MeshIntersectionCache</a> *&#160;</td>
          <td class="paramname"><em>cacheForOtherMeshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *&#160;</td>
          <td class="paramname"><em>perforatingResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *&#160;</td>
          <td class="paramname"><em>overlapResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>overlapMeshResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *&#160;</td>
          <td class="paramname"><em>cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *&#160;</td>
          <td class="paramname"><em>reporter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get intersections with the current mesh. Intersections between other meshes are ignored. See the parameter description in the function above.</p>
<p>cacheForOtherMeshes [in/out] - Users of this class can provide nullptr, or call this method with a default-initialized instance of <a class="el" href="class_o_n___mesh_intersection_cache.html" title="Provides a mechanism for lazily evaluating mesh data. The implementation is private and subject to ch...">ON_MeshIntersectionCache</a>. In this case, the cache can be used with other calls of this function that include exactly withTheseOtherMeshes. </p>

</div>
</div>
<a id="a973789f53a04031d403389b952cb6154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973789f53a04031d403389b952cb6154">&#9670;&nbsp;</a></span>GetMeshEdgeList() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetMeshEdgeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLookForNgonInteriorEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOmitHiddenEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_meshtop_edge_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_meshtop_vertex_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_type_partition</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a662c3c3cbbd3a669ac3651413fb2b303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662c3c3cbbd3a669ac3651413fb2b303">&#9670;&nbsp;</a></span>GetMeshEdgeList() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetMeshEdgeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLookForNgonInteriorEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOmitHiddenEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_meshtop_edge_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_type_partition</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c5293cbd867654e2219ecef6c1076e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c5293cbd867654e2219ecef6c1076e6">&#9670;&nbsp;</a></span>GetMeshEdgeList() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetMeshEdgeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLookForNgonInteriorEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOmitHiddenEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_type_partition</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae3a9cc4d7caba3bce428620870c97eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a9cc4d7caba3bce428620870c97eab">&#9670;&nbsp;</a></span>GetMeshEdgeList() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetMeshEdgeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLookForNgonInteriorEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_meshtop_edge_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_meshtop_vertex_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_type_partition</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af02d62461c66d3315b5da5a4b18716cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02d62461c66d3315b5da5a4b18716cf">&#9670;&nbsp;</a></span>GetMeshEdgeList() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetMeshEdgeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLookForNgonInteriorEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_meshtop_edge_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_type_partition</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aded8849a0a64d357855af23a2bd6155d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded8849a0a64d357855af23a2bd6155d">&#9670;&nbsp;</a></span>GetMeshEdgeList() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetMeshEdgeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLookForNgonInteriorEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_type_partition</em>[6]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a list of the geometrically uniqued edges in a mesh. Parameters: edge_list - [out] The edge list for this mesh is appended to edge_list[]. <br  />
 The <a class="el" href="class_o_n__2dex.html">ON_2dex</a> i and j values are mesh-&gt;m_V[] array indices. There is exactly one element in edge_list[] for each unoriented 3d line segment in the mesh. The edges are oriented the same way the corresponding <a class="el" href="class_o_n___mesh_topology.html">ON_MeshTopology</a> edge is oriented. bLookForNgonInteriorEdges - [in] true if ngon interior edges should be separated from manifold edges. bOmitHiddenEdges - [in] true if edges that have at least one hidden vertex should be omitted from the returned lists. ci_meshtop_edge_map - [out] If you call the verson of <a class="el" href="class_o_n___mesh.html#aded8849a0a64d357855af23a2bd6155d">GetMeshEdgeList()</a> with the ci_meshtop_edge_map[], parameter, then the edge in edge_list[i] cooresponds to the edge in <a class="el" href="class_o_n___mesh_topology.html#a541e6ab0313e7b1003a2f757ef093fed">ON_MeshTopology.m_tope</a>[ci_meshtop_edge_map[i]]. The value ci_meshtop_edge_map[i] is useful if you need to convert an edge_list[] index into an <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> with type meshtop_edge. ci_meshtop_vertex_map - [out] If you call the verson of <a class="el" href="class_o_n___mesh.html#aded8849a0a64d357855af23a2bd6155d">GetMeshEdgeList()</a> with the ci_meshtop_vertex_map[], parameter, then the vertex m_V[i] cooresponds to the vertex in <a class="el" href="class_o_n___mesh_topology.html#ad39c817f6f8dfdf54bbeaa32982bdb74">ON_MeshTopology.m_topv</a>[ci_meshtop_vertex_map[i]]. The value ci_meshtop_vertex_map[i] is useful if you need to convert an m_V[] index into an <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> with type meshtop_vertex. edge_list_partition - [out] (can be null) The edge_list[] is always ordered so that edge_types are partitioned into contiguous regions. The edge_list_partition[5] values report the edge type regions. If edge_type_partition[0] &lt;= ei &lt; edge_type_partition[1], then edge_list[ei] is an edge of exactly two faces and the vertices used by the faces are identical. These are also called "manifold edges". If edge_type_partition[1] &lt;= ei &lt; edge_type_partition[2], then edge_list[ei] is an edge of exactly two faces, but at least one of the vertices is duplicated. These are also called "crease edges". If edge_type_partition[2] &lt;= ei &lt; edge_type_partition[3], then edge_list[ei] is an edge of 3 or more faces. These are also called "nonmanifold edges". If edge_type_partition[3] &lt;= ei &lt; edge_type_partition[4], then edge_list[ei] is a boundary edge of exactly one mesh face. These are also called "naked edges". If edge_type_partition[4] &lt;= ei &lt; edge_type_partition[5], then edge_list[ei] is an edge of exactly two faces that belong to the same ngon. These are also called "ngon interior edges". Returns: Number of edges added to edge_list[]. Remarks: This calculation also sets m_closed. If you modify the mesh's m_V or m_F information after calling this function, be sure to clear m_is_closed. </p>

</div>
</div>
<a id="a4a2631a57074d47d73a086470574dd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a2631a57074d47d73a086470574dd1f">&#9670;&nbsp;</a></span>GetMeshEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::GetMeshEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Appends a list of mesh edges to the edges[] array. Parameters: edges - [out] Each edges[] element is a pair of vertex indices. There is at least one face in the mesh with an edge running between the indicies. Returns: Number of <a class="el" href="class_o_n__2dex.html">ON_2dex</a> values appended to the edges[] array. </p>

</div>
</div>
<a id="a4ba7721378a6841ae06af7614f71511f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba7721378a6841ae06af7614f71511f">&#9670;&nbsp;</a></span>GetMeshFaceSideList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetMeshFaceSideList </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>Vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___mesh_face_side.html">ON_MeshFaceSide</a> *&amp;&#160;</td>
          <td class="paramname"><em>sides</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a list of the sides of every face. Parameters: Vid - [in] (can be null) If Vid is null, then the mesh m_V[] index values are used to set the ON_MeshFaceSide::vi[] values. If Vid is not null, then it must be an array of length <a class="el" href="class_o_n___mesh.html#a96f6f2497feca5e9ba8a038f260c07e5" title="query">VertexCount()</a>. The value Vid[mesh m_V[] index] will be used to set the ON_MeshFaceSide::vi[] values. sides - [out] If the input value of sides is not null, then sides[] must be long enough to hold the returned side list. The maximum posssible length is 4*FaceCount() for a mesh contining <a class="el" href="class_o_n___mesh.html#afbee1f8aea211a5c2b78932ce6d540e0">FaceCount()</a> nondegenerate quads. If the input value of sides is null, memory will be allocated using <a class="el" href="group__open_n_u_r_b_s.html#gacadf2b280c0895b23634d3ad33a6a04b">onmalloc()</a> and the caller is responsible for calling <a class="el" href="group__open_n_u_r_b_s.html#ga11bd5c38846c84d11a00bd1b1cd31e61">onfree()</a> at an appropriate time. This function fills in the sides[] array with face side information. The returned list is sorted by sides[].fi and the sides[].side and each element has vi[0] &lt;= vi[1]. <br  />
 The function ON_SortMeshFaceSidesByVertexIndex() can be used to sort the list by the sides[].vi[] values. Returns: Number of elements added to sides[]. Remarks: Faces with out of range <a class="el" href="class_o_n___mesh_face.html#a48215097327f42857c4761bebb6252e1" title="vertex index - vi[2]==vi[3] for tirangles">ON_MeshFace.vi</a>[] values are skipped. Degenerate faces are processed, but degenerate sides (equal vertex indices) are not added to the list. </p>

</div>
</div>
<a id="a805b093e3860a05c0b8c74b07f2ae60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805b093e3860a05c0b8c74b07f2ae60b">&#9670;&nbsp;</a></span>GetMeshNakedEdgeList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetMeshNakedEdgeList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>naked_edge_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>ci_meshtop_vertex_map</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLookForNgonInteriorEdges</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b1b8f8504f4842c9ada4a49e715033a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b1b8f8504f4842c9ada4a49e715033a">&#9670;&nbsp;</a></span>GetNgonBoundaryPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetNgonBoundaryPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td>
          <td class="paramname"><em>ngon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAppendStartPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *&#160;</td>
          <td class="paramname"><em>ngon_boundary_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: ngon - [in] bAppendStartPoint - [in] If true, the initial point in the boundary will be added as the first point of ngon_boundary_points[] and then added again as the last point of ngon_boundary_points[]. This is useful when you need a closed polyline. ngon_boundary_points - [out] An array of ngon-&gt;m_Vcount + (bAppendStartPoint ? 1 : 0) points is returned in ngon_boundary_points[]. The caller must insure that ngon_boundary_points[] has room for this many elements. Returns: Number of points added to ngon_boundary_points[] or 0 if invalid input is encountered. </p>

</div>
</div>
<a id="ac770d4e7641dafddb357881012b49c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac770d4e7641dafddb357881012b49c53">&#9670;&nbsp;</a></span>GetNgonBoundaryPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetNgonBoundaryPoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td>
          <td class="paramname"><em>ngon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAppendStartPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ngon_boundary_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: ngon - [in] bAppendStartPoint - [in] If true, the initial point in the boundary will be added as the first point of ngon_boundary_points[] and then added again as the last point of ngon_boundary_points[]. This is useful when you need a closed polyline. ngon_boundary_points - [out] An array of ngon-&gt;m_Vcount + (bAppendStartPoint ? 1 : 0) points. Returns: Number of points added to ngon_boundary_points[] or 0 if invalid input is encountered. </p>

</div>
</div>
<a id="a6edacf07064f4635d781dd5252702639"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6edacf07064f4635d781dd5252702639">&#9670;&nbsp;</a></span>GetNgonOuterBoundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::GetNgonOuterBoundary </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_fi_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_fi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ngon_vi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descrption: Given a group of connected coplanar faces, find the n-gon boundary. ngon_fi_count - [in] number of indices in ngon_fi[] ngon_fi - [in] Indices of faces in the <a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450" title="m_F[] facets (triangles or quads)">ON_Mesh.m_F</a>[] array. ngon_vi - [out] An ordered list of indices of vertices in the <a class="el" href="class_o_n___mesh.html#a6cc720e646b5fb26e5285b1838f71c7d">ON_Mesh.m_V</a>[] array that for the outer boundary of the n-gon. The natural counter-clockwise orientation of the first face with a boundary edge determines the order of the ngon_vi[] list. </p>

</div>
</div>
<a id="a22229d8f7d94c1e74a846c7c63ab6059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22229d8f7d94c1e74a846c7c63ab6059">&#9670;&nbsp;</a></span>GetSelfIntersections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::GetSelfIntersections </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *&#160;</td>
          <td class="paramname"><em>perforatingResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *&#160;</td>
          <td class="paramname"><em>overlapResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>overlapMeshResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *&#160;</td>
          <td class="paramname"><em>cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *&#160;</td>
          <td class="paramname"><em>reporter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get self intersections on the current mesh. See the parameter description in the function above. </p>

</div>
</div>
<a id="ac0542ef954af83954f70d55b37455d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0542ef954af83954f70d55b37455d03">&#9670;&nbsp;</a></span>GetSilhouette()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::GetSilhouette </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___silhouette_parameters.html">ON_SilhouetteParameters</a>&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a> *&#160;</td>
          <td class="paramname"><em>clipping_planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>clipping_plane_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___s_i_l___e_v_e_n_t.html">ON_SIL_EVENT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>silhouettes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *&#160;</td>
          <td class="paramname"><em>progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *&#160;</td>
          <td class="paramname"><em>terminator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af63e6ec48221680b4eea2344efb07013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63e6ec48221680b4eea2344efb07013">&#9670;&nbsp;</a></span>GetTightBoundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::GetTightBoundingBox </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>tight_bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGrowBox</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *&#160;</td>
          <td class="paramname"><em>xform</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> GetTightBoundingBox override <br  />
 </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#ab59968e400d15d016517b7b4f2e32ea4">ON_Geometry</a>.</p>

</div>
</div>
<a id="adcc969ccace58c665344d45db4515286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc969ccace58c665344d45db4515286">&#9670;&nbsp;</a></span>GetTightBoundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::GetTightBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>tight_bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGrowBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>clipping_planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___xform.html">ON_Xform</a> *&#160;</td>
          <td class="paramname"><em>xform</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7696c1cc1632aeaee8966d392814e9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7696c1cc1632aeaee8966d392814e9d7">&#9670;&nbsp;</a></span>GetVertexEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::GetVertexEdges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>vertex_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bNoDuplicates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__2dex.html">ON_2dex</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Appends a list of mesh edges that begin or end at the specified vertices to the edges[] array. Parameters: vcount - [in] number of vertices vertex_index - [in] array of vertex indices bNoDuplicates - [in] If true, then only one edges[] is added for each edge, the first vertex index will always be less than the second, and the returned elements are sorted in dictionary order. If false and an edge is shared by multiple faces, then there will be an edges[] element added for each face and the order of the vertex indicies will indicate the orientation of the edge with respect to the face. No sorting is performed in this case. edges - [out] Edges that begin or end at one of the specified vertices are appended to this array. Each <a class="el" href="class_o_n__2dex.html">ON_2dex</a> records the start and end vertex index. Returns: Number of <a class="el" href="class_o_n__2dex.html">ON_2dex</a> values appended to the edges[] array. </p>

</div>
</div>
<a id="a5859f1a15ccad8f68ccdee830b43ab03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5859f1a15ccad8f68ccdee830b43ab03">&#9670;&nbsp;</a></span>GetVertexLocationIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int* ON_Mesh::GetVertexLocationIds </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>first_vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>Vid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>Vindex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Assign a unique id to each vertex location. Coincident vertices get the same id. Parameters: first_vid - [in] Initial vertex id. Typically 1 or 0. Vid - [out] If not null, then Vid[] sould be an array of length <a class="el" href="class_o_n___mesh.html#a96f6f2497feca5e9ba8a038f260c07e5" title="query">VertexCount()</a>. and the vertex ids will be stored in this array. If null, the array will be allocated by calling <a class="el" href="group__open_n_u_r_b_s.html#gacadf2b280c0895b23634d3ad33a6a04b">onmalloc()</a>. The returned array Vid[i] is the id of the vertex m_V[i]. If m_V[i] and m_V[j] are the same 3d point, then Vid[i] and Vid[j] will have the same value. Vindex - [out] (can be null) If Vindex is not null, then it must have length at least m_V.Count() and the returned array will be a permutation of (0,1,...,m_V.Count()-1) such (Vid[Vindex[0]], Vid[Vindex[1]], ..., Vid[Vindex[m_V.Count()-1]]) is an increasing list of value. Returns: null if the mesh has no vertices. An array of length <a class="el" href="class_o_n___mesh.html#a96f6f2497feca5e9ba8a038f260c07e5" title="query">VertexCount()</a>. If vertices m_V[i] and m_V[j] are coincident, then Vid[i] = Vid[j]. The id values begin at first_vid. The maximum vertex id is Vid[Vindex[m_V.Count()-1]]. The number of unique vertex locations is (Vid[Vindex[m_V.Count()-1]] - first_vid + 1). </p>

</div>
</div>
<a id="ae985f186709c0e824170506627469412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae985f186709c0e824170506627469412">&#9670;&nbsp;</a></span>HasCachedTextureCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasCachedTextureCoordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a01fddeadd7c48d8c0c2060fffaf9f8c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fddeadd7c48d8c0c2060fffaf9f8c5">&#9670;&nbsp;</a></span>HasDoublePrecisionVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasDoublePrecisionVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if the mesh has double precision vertices (m_dV.Count() &gt; 0). Remarks: Use <a class="el" href="class_o_n___mesh.html#aab94df03536804d2573b383699db4c57">ON_Mesh::UpdateDoublePrecisionVertices()</a> or <a class="el" href="class_o_n___mesh.html#ac78c5b48affca5a6218278c7037a2776">ON_Mesh::UpdateSinglePrecisionVertices()</a> to synchronize values of single and double precision vertices. </p>

</div>
</div>
<a id="a4f0c02892c0584a53f665b22b1967e6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f0c02892c0584a53f665b22b1967e6a">&#9670;&nbsp;</a></span>HasFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasFaceNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4e263be3e64bcf04bcf6151d1f93f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e263be3e64bcf04bcf6151d1f93f75">&#9670;&nbsp;</a></span>HasMeshTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasMeshTopology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a669b054bd1a6ec07a73ed983c226176c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669b054bd1a6ec07a73ed983c226176c">&#9670;&nbsp;</a></span>HasNgons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasNgons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if the mesh has ngons. </p>

</div>
</div>
<a id="a036aa49ec05cb293126bf27445f245f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036aa49ec05cb293126bf27445f245f5">&#9670;&nbsp;</a></span>HasPackedTextureRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasPackedTextureRegion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if the m_srf_scale[] values are positive and the m_packed_tex_domain[] intervals are set to values that describe a proper subrectangle of (0,1)x(0,1). True does not necessarily mean the current values in m_T[] are packed texture coordinates. </p>

</div>
</div>
<a id="a66dc2d1bd14a4cb90d18916aae1aed65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66dc2d1bd14a4cb90d18916aae1aed65">&#9670;&nbsp;</a></span>HasPrincipalCurvatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasPrincipalCurvatures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a761a8bb237b6b5b8d4a4b3433f44b365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761a8bb237b6b5b8d4a4b3433f44b365">&#9670;&nbsp;</a></span>HasSinglePrecisionVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasSinglePrecisionVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a930cd9676f76c8a4502472590529eb5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930cd9676f76c8a4502472590529eb5a">&#9670;&nbsp;</a></span>HasSurfaceParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasSurfaceParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6caf4d03d31476b0b09763023d44e8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caf4d03d31476b0b09763023d44e8a9">&#9670;&nbsp;</a></span>HasSynchronizedDoubleAndSinglePrecisionVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasSynchronizedDoubleAndSinglePrecisionVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Double precision vertex support Returns: True if the mesh vertex count is &gt; 0, the mesh has single and double precision vertices, and the values of the locations are synchronized. </p>

</div>
</div>
<a id="aba88cd8af101d94fecdf3790a9b23e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba88cd8af101d94fecdf3790a9b23e5e">&#9670;&nbsp;</a></span>HasTextureCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasTextureCoordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd2df640918669255c222cac7d360332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd2df640918669255c222cac7d360332">&#9670;&nbsp;</a></span>HasVertexColors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasVertexColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f7f35cdc59fd53401d137492161fcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7f35cdc59fd53401d137492161fcd2">&#9670;&nbsp;</a></span>HasVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::HasVertexNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>normals at vertices </p>

</div>
</div>
<a id="ab56a4e9072e14c1e8cd21acb6ba6bac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56a4e9072e14c1e8cd21acb6ba6bac4">&#9670;&nbsp;</a></span>HiddenVertexArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bool* ON_Mesh::HiddenVertexArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: If the mesh has some hidden vertices, then an array of length <a class="el" href="class_o_n___mesh.html#a96f6f2497feca5e9ba8a038f260c07e5" title="query">VertexCount()</a> is returned and the i-th element is true if the i-th vertex is hidden. If no vertices are hidden, nullptr is returned. </p>

</div>
</div>
<a id="abb8e01a4cff0e47dccb959e14a2c9aa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb8e01a4cff0e47dccb959e14a2c9aa4">&#9670;&nbsp;</a></span>HiddenVertexCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::HiddenVertexCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Number of vertices that are hidden. </p>

</div>
</div>
<a id="a64719ca819bfb9e1beb541176445bc96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64719ca819bfb9e1beb541176445bc96">&#9670;&nbsp;</a></span>InsertNgon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::InsertNgon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td>
          <td class="paramname"><em>ngon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Insert an n-gon in the ngon list. This is generally slow. Use AddNgon or ModifyNgon. </p>

</div>
</div>
<a id="a2f2ba77f7480c01babab680a1c089df0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f2ba77f7480c01babab680a1c089df0">&#9670;&nbsp;</a></span>IntersectArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_Mesh::IntersectArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *&#160;</td>
          <td class="paramname"><em>perforatingResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; *&#160;</td>
          <td class="paramname"><em>overlapResults</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>overlapMeshResult</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *&#160;</td>
          <td class="paramname"><em>cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *&#160;</td>
          <td class="paramname"><em>reporter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Intersects a group of meshes. This method uses the new code. Parameters: meshes - [in] The mesh input list. nullptr entries are tolerated. tolerance - [in] A 3d-distance tolerance value. If tolerance is:</p><ul>
<li>negative: the positive value will be used.</li>
<li>0.0: no tolerance will be used. This is rarely useful, and only in cases where perforations intersections happen inside faces, and/or there is coplanarity parallel to one of the three fundamental axes.</li>
<li>ON_DBL_QNAN, ON_UNSET_VALUE and ON_UNSET_POSITIVE_VALUE: the function picks a suitable, or default, tolerance value. WARNING! Generally, good tolerance values for objects drawn near the origin are in the magnitude of 10^-7, or ON_SQRT_EPSILON * 10. Often, the document absolute tolerance is not a good tolerance value. You might use a fractional coeffiecient to scale the document tolerance to a suitable value, while accepting a user-provided value. This function expects that each mesh conforms to the tolerance that is provided, and that means that features in the mesh are always larger than the mentioned tolerance. Coplanar gaps between meshes that are smaller than tolerance are overlaps. perforatingResults - [out] If not nullptr, this array will be filled with the polylines from perforating intersections. overlapResults - [out] If not nullptr, this array will be filled with the polylines from overlaps. This can be (but does not need to be) the same object provided to intersectionResults. overlapMeshResult - [out] If not nullptr, this mesh will have new faces added that represent the coplar unions of inputs. If this output is not required, it's best to leave this as nullptr. log - [out] If not nullptr, intersection warnings and errors are printed here. If the intersection runs smoothly, nothing will generally be printed. cancel - [out] If not nullptr, a trigger to request termination. When cancellation is requested, the return value will often be false. You are responsible to delete new objects that were returned, even if you requested cancellation. reporter - [out] If not nullptr, an indicative progress is reported. Returns: true if the computation finished successfully, false otherwise. </li>
</ul>

</div>
</div>
<a id="a8edfe4badff618e7fdbf16f0e20d538a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edfe4badff618e7fdbf16f0e20d538a">&#9670;&nbsp;</a></span>IntersectMesh() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::IntersectMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>meshB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___m_m_x___p_o_i_n_t.html">ON_MMX_POINT</a> &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>intersection_tolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>overlap_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Carefully intersect this mesh with meshB. This method currently uses the old code. Parameters: meshB - [in] x - [out] Each element of x is a polyline of ON_MMX_POINTs. intersection_tolerance - [in] overlap_tolerance - [in] Returns: number of olylines appended to x[] array. Remarks: The InstersectMesh function will will create a meshtree, a mesh topology and face normals of this mesh and meshB. Note: if you create these in multiple memory pools you run the risk of crashing or leaking memory if you are not careful. </p>

</div>
</div>
<a id="a5fe11e9cdbc9e47c986011d408e9ebb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fe11e9cdbc9e47c986011d408e9ebb1">&#9670;&nbsp;</a></span>IntersectMesh() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::IntersectMesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>meshB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___line.html">ON_Line</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Quickly intersect this mesh with meshB. Ignore overlaps and near misses. Parameters: meshB - [in] lines - [out] Intersection lines are appended to this list. Returns: number of lines appended to lines[] array. Remarks: The InstersectMesh function will will create a meshtree, a mesh topology and face normals of this mesh and meshB. Note: if you create these in multiple memory pools you run the risk of crashing or leaking memory if you are not careful. </p>

</div>
</div>
<a id="aa1870824b2eb5da0889fc382488252af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1870824b2eb5da0889fc382488252af">&#9670;&nbsp;</a></span>IntersectPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::IntersectPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a>&#160;</td>
          <td class="paramname"><em>plane_equation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___line.html">ON_Line</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Intersect this mesh with an infinite plane. Parameters: plane_equation - [in] lines - [out] Intersection lines are appended to this list. Returns: number of lines appended to lines[] array. </p>

</div>
</div>
<a id="aba8065a1d1dd17ac978676c2bc19113d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba8065a1d1dd17ac978676c2bc19113d">&#9670;&nbsp;</a></span>InvalidateBoundingBoxes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::InvalidateBoundingBoxes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>directly manipulating the m_T[] array. </p>
<p>Invalidates all cached bounding box information. </p>

</div>
</div>
<a id="a715399127e4605246faecd616731a5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715399127e4605246faecd616731a5c8">&#9670;&nbsp;</a></span>InvalidateCurvatureStats()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::InvalidateCurvatureStats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>directly manipulating the m_T[] array. </p>
<p>Call if defining geometry is changed by <br  />
 </p>

</div>
</div>
<a id="a76a7b8674f110f83757069a119ff29c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76a7b8674f110f83757069a119ff29c0">&#9670;&nbsp;</a></span>InvalidateTextureCoordinateBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::InvalidateTextureCoordinateBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>directly manipulating the m_N[] array. </p>
<p>Call if defining geometry is changed by <br  />
 </p>

</div>
</div>
<a id="a52717d2c07df6a6e262c8428f06d3ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52717d2c07df6a6e262c8428f06d3ac7">&#9670;&nbsp;</a></span>InvalidateVertexBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::InvalidateVertexBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call if defining geometry is changed by <br  />
 </p>

</div>
</div>
<a id="af086160efaa29517dc83f431c7dc1a5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af086160efaa29517dc83f431c7dc1a5c">&#9670;&nbsp;</a></span>InvalidateVertexNormalBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::InvalidateVertexNormalBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>directly manipulating the m_V[] array. </p>
<p>Call if defining geometry is changed by <br  />
 </p>

</div>
</div>
<a id="a749b4f6fc2866a0fdc6d64713d97d4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749b4f6fc2866a0fdc6d64713d97d4b1">&#9670;&nbsp;</a></span>InvalidFaceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::InvalidFaceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of face that have invalid m_vi[] values. </p>

</div>
</div>
<a id="a028ab06bfe084fb116e101f91f82fa7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028ab06bfe084fb116e101f91f82fa7e">&#9670;&nbsp;</a></span>IsClosed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsClosed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if every mesh "edge" has two or more faces. </p>

</div>
</div>
<a id="a09cf3edf84c5022dc5954e0f087d8930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09cf3edf84c5022dc5954e0f087d8930">&#9670;&nbsp;</a></span>IsCorrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsCorrupt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRepair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSilentError</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>text_log</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Check for corrupt data values that are likely to cause crashes. Parameters: bRepair - [in] If true, const_cast&lt;&gt; will be used to change the corrupt data so that crashes are less likely. bSilentError - [in] If true, ON_ERROR will not be called when corruption is detected. text_log - [out] If text_log is not null, then a description of corruption is printed using text_log. Remarks: Ideally, <a class="el" href="class_o_n___mesh.html#a09cf3edf84c5022dc5954e0f087d8930">IsCorrupt()</a> would be a virtual function on <a class="el" href="class_o_n___object.html">ON_Object</a>, but doing that at this point would break the public SDK. </p>

</div>
</div>
<a id="a9b29dad1c91ed6b2d2993384dfd2551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b29dad1c91ed6b2d2993384dfd2551b">&#9670;&nbsp;</a></span>IsDeformable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsDeformable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___geometry.html#af156cd098b9e68fab5f32e76b1e274e2">ON_Geometry::IsDeformable()</a> override </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#af156cd098b9e68fab5f32e76b1e274e2">ON_Geometry</a>.</p>

</div>
</div>
<a id="a7f7cc8b39c510324b756eb2ed20ed88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7cc8b39c510324b756eb2ed20ed88b">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interface Returns true if there are zero vertices or zero faces. </p>

</div>
</div>
<a id="ac09c9dbc6da5c1124b3ebd60c645a526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac09c9dbc6da5c1124b3ebd60c645a526">&#9670;&nbsp;</a></span>IsManifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsManifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if every mesh "edge" has at most two faces. </p>

</div>
</div>
<a id="a3af643d18e1e66ed8a2e9542fa768010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3af643d18e1e66ed8a2e9542fa768010">&#9670;&nbsp;</a></span>IsManifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsManifold </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bTopologicalTest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbIsOriented</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>pbHasBoundary</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Determine if the mesh is a manifold. Parameters: bTopologicalTest - [in] If true, the query treats coincident vertices as the same. pbIsOriented - [out] If the input pointer is not nullptr, then the returned value of *pbIsOriented will be true if the mesh is a manifold and adjacent faces have compatible face normals. pbHasBoundary - [out] If the input pointer is not nullptr, then the returned value of *pbHasBoundary will be true if the mesh is a manifold and there is at least one "edge" with no adjacent faces have compatible face normals. Returns: True if every mesh "edge" has at most two adjacent faces. </p>

</div>
</div>
<a id="a38c8cfd7fc32bddf1aa2ea68204fcbc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38c8cfd7fc32bddf1aa2ea68204fcbc6">&#9670;&nbsp;</a></span>IsMorphable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsMorphable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> override </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#adb46c6b46022d8ea0e7a25c19911d6e3">ON_Geometry</a>.</p>

</div>
</div>
<a id="a890dbca9b3dd42c2744927091a9cad4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890dbca9b3dd42c2744927091a9cad4f">&#9670;&nbsp;</a></span>IsNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsNotEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if there are vertices and faces. </p>

</div>
</div>
<a id="a6cad2bd54873b1a24b9a0d030fd3fc65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cad2bd54873b1a24b9a0d030fd3fc65">&#9670;&nbsp;</a></span>IsOriented()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if the mesh is manifold and every pair of faces that share an "edge" have compatible orientations. </p>

</div>
</div>
<a id="a47f89b45f3e01a4ed5b0c3f8378e6567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47f89b45f3e01a4ed5b0c3f8378e6567">&#9670;&nbsp;</a></span>IsPointInside()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsPointInside </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>test_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStrictlyInside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Determine if a point is inside a solid brep. Paramters: test_point - [in] tolerance - [in] &gt;= 0.0 3d distance tolerance used for ray-mesh intersection and determining strict inclusion. bStrictlyInside - [in] If bStrictlyInside is true, then test_point must be inside mesh by at least tolerance in order for this function to return true. If bStrictlyInside is false, then this function will return true if test_point is inside or the distance from test_point to a mesh face is &lt;= tolerance. Returns: True if test_point is inside the solid mesh. Remarks: The caller is responsible for making certing the mesh is solid before calling this function. If the mesh is not solid, the behavior is unpredictable. See Also: <a class="el" href="class_o_n___mesh.html#a064f4ce98ffdba6c40d6eec8daf8cf1d">ON_Mesh::IsSolid()</a> </p>

</div>
</div>
<a id="a064f4ce98ffdba6c40d6eec8daf8cf1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064f4ce98ffdba6c40d6eec8daf8cf1d">&#9670;&nbsp;</a></span>IsSolid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsSolid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Test mesh to see if it is a solid. (A "solid" is a closed oriented manifold.) Returns: true mesh is a solid fals mesh is not a solid See Also: <a class="el" href="class_o_n___mesh.html#a59e152a0038bf5a96071b5c6ff3a2ef4">ON_Mesh::SolidOrientation</a> <a class="el" href="class_o_n___mesh.html#ac09c9dbc6da5c1124b3ebd60c645a526">ON_Mesh::IsManifold</a> </p>

</div>
</div>
<a id="a45266824480cc73f6ff520c480a86ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45266824480cc73f6ff520c480a86ed4">&#9670;&nbsp;</a></span>IsSwappableEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsSwappableEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>topei</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Tests a mesh edge to see if it is valid as input to ON_Mesh::SwapMeshEdge. Parameters: topei - [in] index of edge in MeshTopology().m_tope[] array Returns: true if edge can be swapped by ON_Mesh::SwapMeshEdge. See Also: <a class="el" href="class_o_n___mesh.html#a14ed95524bdd6ce006fc9943e3f6543b">ON_Mesh::SwapEdge</a> </p>

</div>
</div>
<a id="a08acfd86d40eb163156a7329fb3c52cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08acfd86d40eb163156a7329fb3c52cc">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsValid </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>text_log</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Tests an object to see if its data members are correctly initialized. Parameters: text_log - [in] if the object is not valid and text_log is not nullptr, then a brief englis description of the reason the object is not valid is appened to the log. The information appended to text_log is suitable for low-level debugging purposes by programmers and is not intended to be useful as a high level user interface tool. Returns: @untitled table true object is valid false object is invalid, uninitialized, etc. </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#adf87e5ba0d9939dfabbb9f421b9d2b3b">ON_Geometry</a>.</p>

</div>
</div>
<a id="a39eafead00993bff9106317ddaae5423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eafead00993bff9106317ddaae5423">&#9670;&nbsp;</a></span>IsValidMeshComponentIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsValidMeshComponentIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>ci</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: ci - [in] component index to test Returns: True if ci identifies a component (vertex, edge, face, ngon) that exists in this mesh. </p>

</div>
</div>
<a id="ac87f1bfa6914e2ccee90849f2111bcb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87f1bfa6914e2ccee90849f2111bcb3">&#9670;&nbsp;</a></span>IsValidNewNgonInformation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::IsValidNewNgonInformation </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Vcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Fcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: true if the n-gon information is valid for adding an n-gon to this mesh. Parameters: Vcount - [in] Number of vertices and sides in the n-gon. ngon_vi - [in] </p>

</div>
</div>
<a id="ac9154c4736f20d4f2fa0bc214032b7e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9154c4736f20d4f2fa0bc214032b7e6">&#9670;&nbsp;</a></span>IterativeCleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_Mesh::IterativeCleanup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Performs the maximum currently-available iterative cleanup based on a tolerance value on a group of meshes. This is an iterative process. Parameters: meshes - [in] A group of meshes that are worked on together. A single mesh is also OK. tolerance - [in] A 3d distance. This is usually a value of about 10e-7 magnitude. results - [out] A list that will be filled the exactly mesh.Count() items. If a mesh did not require cleanup, or cleanup did not yield any change, a nullptr is added to this list. Returns: true if the operation was successful, false otherwise. Also returning all nullptr is considered success. </p>

</div>
</div>
<a id="a33d67491f386ad56d11d091d4a2fa548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d67491f386ad56d11d091d4a2fa548">&#9670;&nbsp;</a></span>MakeDeformable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::MakeDeformable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___geometry.html#ac3d5cb708edca66a4a6c1992299329a3">ON_Geometry::MakeDeformable()</a> override </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#ac3d5cb708edca66a4a6c1992299329a3">ON_Geometry</a>.</p>

</div>
</div>
<a id="a946263df140cb0a25931db03ed015759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946263df140cb0a25931db03ed015759">&#9670;&nbsp;</a></span>MemoryRelocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::MemoryRelocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Override of virtual <a class="el" href="class_o_n___object.html#ae0674ccb79b6333e4b3c8e95ee10dd73">ON_Object::MemoryRelocate</a>. </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#ae0674ccb79b6333e4b3c8e95ee10dd73">ON_Object</a>.</p>

</div>
</div>
<a id="a3226b27eca51ba7a97ac8fba12b56b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3226b27eca51ba7a97ac8fba12b56b39">&#9670;&nbsp;</a></span>MergeFaceSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::MergeFaceSets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge faces like <a class="el" href="class_o_n___sub_d.html#a0412e0107132bcad5a3def31ed368f01">ON_SubD::MergeFaces()</a> does. Parameters: ci_list - [in] vertices, edges, and faces that trigger merging. Returns: If ngons were added, then the index of the first added ngon is returned. Otherwise ON_UNSET_UINT_INDEX is returned. </p>

</div>
</div>
<a id="aa634b516a1c1042d78d19a2c4544f0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa634b516a1c1042d78d19a2c4544f0bd">&#9670;&nbsp;</a></span>MeshComponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___mesh_component_ref.html">ON_MeshComponentRef</a>* ON_Mesh::MeshComponent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>ci</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: ci - [in] a component index with type mesh_vertex, meshtop_vertex, meshtop_edge, or mesh_face. Returns: A pointer to an <a class="el" href="class_o_n___mesh_component_ref.html">ON_MeshComponentRef</a> The caller must delete the returned object when it is no longer needed. </p>

</div>
</div>
<a id="a8497796652e5421a57823809746239e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8497796652e5421a57823809746239e4">&#9670;&nbsp;</a></span>MeshComponentRef()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___mesh_component_ref.html">ON_MeshComponentRef</a> ON_Mesh::MeshComponentRef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>ci</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d8253d3294a7208e2b4cf96c429352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d8253d3294a7208e2b4cf96c429352">&#9670;&nbsp;</a></span>MeshFaceTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___r_tree.html">ON_RTree</a>* ON_Mesh::MeshFaceTree </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCreateIfNoneExists</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: bCreateIfNoneExists - [in] If a mesh face rtree is not cached on this mesh and bCreateIfNoneExists is true, then a new one will be created and cached. If a mesh face rtree is not cached on this mesh and bCreateIfNoneExists is false, then null is returned. Returns: An ON_Rtree with 3d node boxes and mesh face indices as the element id values. The pointer may be null and the caller must check it before dereferencing. </p>

</div>
</div>
<a id="a4df6c0c5eb97d8f1c13c4d516ade988e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df6c0c5eb97d8f1c13c4d516ade988e">&#9670;&nbsp;</a></span>MeshParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___mesh_parameters.html">ON_MeshParameters</a>* ON_Mesh::MeshParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4eba9d343e2e84cebf91bf13bda21f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eba9d343e2e84cebf91bf13bda21f8">&#9670;&nbsp;</a></span>MeshPart()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_Mesh::MeshPart </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_o_n___mesh_part.html">ON_MeshPart</a> &amp;&#160;</td>
          <td class="paramname"><em>mesh_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Extract the portion of this mesh defined by mesh_part. Parameters: mesh_part - [in] defines portion of the mesh to extract. mesh - [in] (can be null, cannot be = "this). If mesh is no null, the extracted mesh will be put into this mesh. If mesh is null, the extracted mesh will be created in a mesh allocated on the heap using the new operator. Returns: A pointer to the submesh. If the input mesh parameter is null, then the caller must delete this mesh when it is no longer needed. If the input is invalid, then null is returned. </p>

</div>
</div>
<a id="aa11d2d4e0926c340dd2a3a0eb304b12c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa11d2d4e0926c340dd2a3a0eb304b12c">&#9670;&nbsp;</a></span>MeshTree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___mesh_tree.html">ON_MeshTree</a>* ON_Mesh::MeshTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: bCreateIfNoneExists - [in] If a mesh tree is not cached on this mesh and bCreateIfNoneExists is true, then a new one will be created and cached. If a mesh tree is not cached on this mesh and bCreateIfNoneExists is false, then null is returned. Returns: An pointer <a class="el" href="class_o_n___mesh_tree.html">ON_MeshTree</a> for this mesh. The pointer may be null and the caller must check it before dereferencing. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000059">Deprecated:</a></b></dt><dd>Call MeshTree(true) </dd></dl>

</div>
</div>
<a id="a239c5e5a30b14d756bdcf0bc61bdbcfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239c5e5a30b14d756bdcf0bc61bdbcfd">&#9670;&nbsp;</a></span>MeshTree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___mesh_tree.html">ON_MeshTree</a>* ON_Mesh::MeshTree </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCreateIfNoneExists</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3d4c3495818778426d2448370c03c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d4c3495818778426d2448370c03c94">&#9670;&nbsp;</a></span>ModifyNgon() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ModifyNgon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td>
          <td class="paramname"><em>ngon</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1073baee7566788599b3de47f3d8d0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1073baee7566788599b3de47f3d8d0dc">&#9670;&nbsp;</a></span>ModifyNgon() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ModifyNgon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Vcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_vi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>Fcount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_fi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb6a97fd6853fa9607f6897b3bee4be1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb6a97fd6853fa9607f6897b3bee4be1">&#9670;&nbsp;</a></span>Morph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::Morph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___space_morph.html">ON_SpaceMorph</a> &amp;&#160;</td>
          <td class="paramname"><em>morph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> override </p>

</div>
</div>
<a id="a0bb74c2912dfd22e91828b16017958af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb74c2912dfd22e91828b16017958af">&#9670;&nbsp;</a></span>Ngon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a>* ON_Mesh::Ngon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: ngon_index - [in] Index of an ngon. Returns: A pointetr to the indexed n-gon or null if the indexed ngon is null or ngon_index is out of range. Remarks: If <a class="el" href="class_o_n___mesh.html#a0d1c49c5d8bb7e37cbe30ac895672691">ON_Mesh::RemoveNgon</a> has been called, then a null pointer can be returned even when ngon_index &gt;= 0 and ngon_index &lt; <a class="el" href="class_o_n___mesh.html#a4351c0a15e835215552431473ab84fb4">ON_Mesh.NgonCount()</a>. </p>

</div>
</div>
<a id="a0b63074e3903db1cf10be7f122b7253c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b63074e3903db1cf10be7f122b7253c">&#9670;&nbsp;</a></span>NgonBoundaryBoundingBox() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> ON_Mesh::NgonBoundaryBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td>
          <td class="paramname"><em>ngon</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Bounding box of the n-gon vertex locations. </p>

</div>
</div>
<a id="a3e49693fa501a2465579c87754064eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e49693fa501a2465579c87754064eb5">&#9670;&nbsp;</a></span>NgonBoundaryBoundingBox() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> ON_Mesh::NgonBoundaryBoundingBox </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Bounding box of the n-gon vertex locations. </p>

</div>
</div>
<a id="a97fc52044ad832b7d07411db2521c721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97fc52044ad832b7d07411db2521c721">&#9670;&nbsp;</a></span>NgonBoundaryEdgeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::NgonBoundaryEdgeCount </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: ngon_index - [in] Index of an ngon. Returns: Total number of boundary edges, including interior edges </p>

</div>
</div>
<a id="a10cbdc82dd6d89be8685a82428601964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10cbdc82dd6d89be8685a82428601964">&#9670;&nbsp;</a></span>NgonCenter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_Mesh::NgonCenter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> *&#160;</td>
          <td class="paramname"><em>ngon</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Average of the n-gon vertex locations. </p>

</div>
</div>
<a id="a07b2323a4c55597e6ab2d8784fbf0f85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b2323a4c55597e6ab2d8784fbf0f85">&#9670;&nbsp;</a></span>NgonCenter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_Mesh::NgonCenter </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Average of the n-gon vertex locations. </p>

</div>
</div>
<a id="a4351c0a15e835215552431473ab84fb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4351c0a15e835215552431473ab84fb4">&#9670;&nbsp;</a></span>NgonCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::NgonCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>N-gon</p>
<p>An n-gon is a collection of faces that are grouped together. The outer boundary of the face collection must be a closed polyline. N-gon interface Number of n-gons in this mesh. </p>

</div>
</div>
<a id="aa7dc938246cff27850bd279cb8b9e307"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7dc938246cff27850bd279cb8b9e307">&#9670;&nbsp;</a></span>NgonFromComponentIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a>* ON_Mesh::NgonFromComponentIndex </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___mesh_ngon_buffer.html">ON_MeshNgonBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>ngon_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>ci</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0857d55de805ef93bfe994857ef69be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0857d55de805ef93bfe994857ef69be">&#9670;&nbsp;</a></span>NgonIndexFromFaceIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::NgonIndexFromFaceIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>face_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: face_index - [in] Mesh face <a class="el" href="class_o_n___mesh.html#a005e7e4b0f04014c289264e06e496450" title="m_F[] facets (triangles or quads)">ON_Mesh.m_F</a>[] index. Returns: ON_UNSET_UINT_INDEX: The face is not part of an n-gon. Otherwise: Index of the n-gon the face is part of. </p>

</div>
</div>
<a id="ae6c65cf1ecadb5491a096ce442fd9337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6c65cf1ecadb5491a096ce442fd9337">&#9670;&nbsp;</a></span>NgonMap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int* ON_Mesh::NgonMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: null: The ngonMap does not exist. an array of length m_F.Count(): The value of the i-th element is either the index of the n-gon the mesh face m_F[i] belongs to or ON_UNSET_UINT_INDEX when m_F[i] does not belong to an n-gon. </p>

</div>
</div>
<a id="af3f84a9e00b59d6d477fda0a951ed1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f84a9e00b59d6d477fda0a951ed1ce">&#9670;&nbsp;</a></span>NgonMap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned int* ON_Mesh::NgonMap </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCreateIfMissing</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abeebceaf44e9a38160761dc9bd690f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeebceaf44e9a38160761dc9bd690f53">&#9670;&nbsp;</a></span>Ngons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a>* const * ON_Mesh::Ngons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: null - This mesh does ot have n-gon information. not null - a pointer to an array of <a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a> pointers. The array has length <a class="el" href="class_o_n___mesh.html#a4351c0a15e835215552431473ab84fb4">ON_Mesh::NgonCount()</a>. Remarks: If <a class="el" href="class_o_n___mesh.html#a0d1c49c5d8bb7e37cbe30ac895672691">ON_Mesh::RemoveNgon</a> has been called, then the array can contain null pointers. </p>

</div>
</div>
<a id="a90c3f81acd22e891e91c68ce4cf9a77b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90c3f81acd22e891e91c68ce4cf9a77b">&#9670;&nbsp;</a></span>NgonUnsignedCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::NgonUnsignedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of n-gons in this mesh. </p>

</div>
</div>
<a id="a9295f030b83e008c7c07f43ed33dab97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9295f030b83e008c7c07f43ed33dab97">&#9670;&nbsp;</a></span>NormalizeTextureCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::NormalizeTextureCoordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scales textures so the texture domains are [0,1] and eliminates any texture rotations. </p>

</div>
</div>
<a id="a061ab836e5be4150fb6501d0a0545d85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a061ab836e5be4150fb6501d0a0545d85">&#9670;&nbsp;</a></span>ObjectType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n.html#a328d22b5ad7bf9d4e9ba1123355d3cf9">ON::object_type</a> ON_Mesh::ObjectType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Useful for switch statements that need to differentiate between basic object types like points, curves, surfaces, and so on.</p>
<p>Returns: <a class="el" href="class_o_n.html#a328d22b5ad7bf9d4e9ba1123355d3cf9">ON::object_type</a> enum value.</p>
<p>Remarks: The default implementation of this virtual function returns <a class="el" href="class_o_n.html#a328d22b5ad7bf9d4e9ba1123355d3cf9a14820a0e82c00c488a5f70bf149f0512">ON::unknown_object_type</a> </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#afa19aee4a411a8fda53aff00bd02d86e">ON_Object</a>.</p>

</div>
</div>
<a id="a892efaa4dad96e991cc6c6c9c03db2e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892efaa4dad96e991cc6c6c9c03db2e5">&#9670;&nbsp;</a></span>OffsetMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_Mesh::OffsetMesh </td>
          <td>(</td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mesh offset Description: Offsets a mesh by the input distance</p>
<p>distance - [in] Distance to offset direction - [in] If this parameter is <a class="el" href="class_o_n__3d_vector.html#aa62d84d9817922de5f60ef3b057ed0be" title="(ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)">ON_3dVector::UnsetVector</a>, offset each vertex in the normal direction orherwise, offset every vertex in the input direction Returns: New mesh that is an offset of a duplicate of this mesh Or nullptr if the input was invalid or the mesh could not be duplicated or offset Caller manages memory of new mesh </p>

</div>
</div>
<a id="a10397c31699ec61ec3f0191bb4c91209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10397c31699ec61ec3f0191bb4c91209">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh.html">ON_Mesh</a>&amp; ON_Mesh::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d0c2907958feec6fc5a7361855c77cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0c2907958feec6fc5a7361855c77cb">&#9670;&nbsp;</a></span>OrientNgons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::OrientNgons </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermitHoles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If the mesh has ngons with <a class="el" href="class_o_n___mesh_ngon.html#ad081408a2dc6df86095488eb46f7ca40">ON_MeshNgon.Orientation()</a> = -1, the reverse the ngon's boundary orientation. Parameters: bPermitHoles - [in] ngons may contain holes. Returns: True if all non-empty ngons have <a class="el" href="class_o_n___mesh_ngon.html#ad081408a2dc6df86095488eb46f7ca40">ON_MeshNgon.Orientation()</a>=1 after the call. </p>

</div>
</div>
<a id="aebcaabae10215815145532ff33c72ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcaabae10215815145532ff33c72ff8">&#9670;&nbsp;</a></span>Partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___mesh_partition.html">ON_MeshPartition</a>* ON_Mesh::Partition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64501613756a89e8bd1c52f1a44c4d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64501613756a89e8bd1c52f1a44c4d63">&#9670;&nbsp;</a></span>QuadCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::QuadCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of faces that are quads </p>

</div>
</div>
<a id="abfed633bb6c0ef69b6e0dd585dffb6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfed633bb6c0ef69b6e0dd585dffb6b2">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>binary_archive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Low level archive writing tool used by <a class="el" href="class_o_n___binary_archive.html#a025b86c1da38eb51f66d6260b1141ac3">ON_BinaryArchive::ReadObject()</a>. Parameters: binary_archive - archive to read from Returns: Returns true if the read is successful. Remarks: Use <a class="el" href="class_o_n___binary_archive.html#a025b86c1da38eb51f66d6260b1141ac3">ON_BinaryArchive::ReadObject()</a> to read objects. This <a class="el" href="class_o_n___mesh.html#abfed633bb6c0ef69b6e0dd585dffb6b2">Read()</a> function should read the objects definition back into its data members.</p>
<p>The default implementation of this virtual function returns false and does nothing. </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a09ac9742ead91dd8f9cdd579bcbfed10">ON_Object</a>.</p>

</div>
</div>
<a id="a182b3f6401bc7617ca97d4269378882e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182b3f6401bc7617ca97d4269378882e">&#9670;&nbsp;</a></span>RemoveAllCreases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::RemoveAllCreases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5650aabe73182b671e1a7d60f7993869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5650aabe73182b671e1a7d60f7993869">&#9670;&nbsp;</a></span>RemoveAllNgons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::RemoveAllNgons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Remove all entries from the <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> n-gon list. Remarks: Same as SetNgonCount(0) </p>

</div>
</div>
<a id="a4b0c77dc1381c57b45e87008264ca0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0c77dc1381c57b45e87008264ca0ce">&#9670;&nbsp;</a></span>RemoveEmptyNgons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::RemoveEmptyNgons </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Remove null and empty entries from the <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> n-gon list. </p>

</div>
</div>
<a id="a0d1c49c5d8bb7e37cbe30ac895672691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1c49c5d8bb7e37cbe30ac895672691">&#9670;&nbsp;</a></span>RemoveNgon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::RemoveNgon </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Remove an n-gon. Parameters: ngon_index - [in] Returns: True if ngon_index was valid and the corresponding n-gon was removed. Remarks: The mesh triangles that make up the n-gon are not deleted. </p>

</div>
</div>
<a id="a2f8e867fcd417fe95658d3390396ab07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f8e867fcd417fe95658d3390396ab07">&#9670;&nbsp;</a></span>RemoveNgonInteriorVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::RemoveNgonInteriorVertices </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *const *&#160;</td>
          <td class="paramname"><em>vertex_face_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: For each ngon with index in the specified range that has interior vertices, remove the interior vertices and triangluate the ngon. Parameters: vertex_face_map - [in]</p><ul>
<li>Pass null if you don't have one.</li>
<li>See <a class="el" href="class_o_n___mesh_vertex_face_map.html">ON_MeshVertexFaceMap</a> for details about making one. The only reason to pass one in is because you need it for other reasons or you already have one.</li>
<li>If true is returned, then the information in this vertex_face_map will be invalid because vertices will be removed. ngon_index0 - [in] ngon_index1 - [in] ngons with indices ni satisfying ngon_index0 &lt;= ni &lt; ngon_index1 will be separated. To separate every ngon in a mesh, pass ngon_index0 = 0 and ngon_index1 = mesh-&gt;<a class="el" href="class_o_n___mesh.html#a4351c0a15e835215552431473ab84fb4">NgonCount()</a>. <br  />
 Returns: true one or more vertices were removed and one or more ngons were triangluated. This changes the mesh's vertex and face information and invalidates any input vertex_face_map. false The mesh was not modified. Remarks: If true is returned and you are finished modify the mesh, then call <a class="el" href="class_o_n___mesh.html#aef1590fcf5ed72349c51fc2da3c5a5e6">ON_Mesh::Compact()</a> or <a class="el" href="class_o_n___mesh.html#a2a28c1db5796622470a0d8cd4c8d4f7c" title="returns number of culled vertices">ON_Mesh::CullUnusedVertices()</a> to remove the unreferenced interior vertices. </li>
</ul>

</div>
</div>
<a id="a6373b244204508e3539b71df54ae7b28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6373b244204508e3539b71df54ae7b28">&#9670;&nbsp;</a></span>RemoveNgonMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::RemoveNgonMap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user function to delete n-gon map information but leave n-gon definition information unchanged. Description: Removes any existing n-gon map. Does not remove other n-gon information. </p>

</div>
</div>
<a id="ab0cb1db4aa87239e5a288688458c8e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cb1db4aa87239e5a288688458c8e3a">&#9670;&nbsp;</a></span>RemoveNgons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::RemoveNgons </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int *&#160;</td>
          <td class="paramname"><em>ngon_index_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a384ec8eed2f6a7316750618c393c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a384ec8eed2f6a7316750618c393c42">&#9670;&nbsp;</a></span>RequireIterativeCleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_Mesh::RequireIterativeCleanup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Determines if meshes require an iterative cleanup based on a tolerance value. All available cleanup steps are used. Currently available cleanup steps are:</p>
<ul>
<li>mending of single precision coincidence even though double precision vertices differ.</li>
<li>union of nearly identical vertices, irrespectively of their origin.</li>
<li>removal of t-joints along edges. Parameters: meshes - [in] A group of meshes that are worked on together. A single mesh is also OK. tolerance - [in] A 3d distance. This is usually a value of about 10e-7 magnitude. Returns: true if the step is required for mesh booleans, intersections, etc, false otherwise. </li>
</ul>

</div>
</div>
<a id="a79dfcb5a43667ddda303516881b9c132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79dfcb5a43667ddda303516881b9c132">&#9670;&nbsp;</a></span>ReserveVertexCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ReserveVertexCapacity </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_vertex_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Increases the capactiy of arrays used to hold vertex information. Parameters: new_vertex_capacity - [in] desired capacity Returns: true if successful. Remarks: This function is useful if you are getting ready to add a known number of vertices and want to increase the dynamic array capacities before you begin adding vertices. </p>

</div>
</div>
<a id="a3472d68ce671f6a65a57c033836b4a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3472d68ce671f6a65a57c033836b4a07">&#9670;&nbsp;</a></span>ReverseSurfaceParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ReverseSurfaceParameters </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40f5d250500fd7eabc434db8950eb973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f5d250500fd7eabc434db8950eb973">&#9670;&nbsp;</a></span>ReverseTextureCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::ReverseTextureCoordinates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Reverse one coordinate direction of the texture coordinates, within texture domain m_tex_domain Parameters: dir -[in] - dir=0 first texture coordinate is reversed dir=1 second texture coordinate is reversed Returns true - success </p>

</div>
</div>
<a id="ae11133fd5bae412081e6eaf21769c86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11133fd5bae412081e6eaf21769c86f">&#9670;&nbsp;</a></span>SeparateNgons()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SeparateNgons </td>
          <td>(</td>
          <td class="paramtype">unsigned int **&#160;</td>
          <td class="paramname"><em>vertex_face_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: For each ngon with index in the specified range, duplicate vertices as needed so that the ngon does not share any vertices with faces that do not belong to the ngon. Parameters: vertex_face_map - [in]</p><ul>
<li>Pass null if you don't have one.</li>
<li>See <a class="el" href="class_o_n___mesh_vertex_face_map.html">ON_MeshVertexFaceMap</a> for details about making one. The only reason to pass one in is because you need it for other reasons or you already have one.</li>
<li>Note that if true is returned, then the information in this vertex_face_map will be changed and no information will be added for the new vertices. ngon_index0 - [in] ngon_index1 - [in] ngons with indices ni satisfying ngon_index0 &lt;= ni &lt; ngon_index1 will be separated. To separate every ngon in a mesh, pass ngon_index0 = 0 and ngon_index1 = mesh-&gt;<a class="el" href="class_o_n___mesh.html#a4351c0a15e835215552431473ab84fb4">NgonCount()</a>. <br  />
 Returns: true one or more vertices were duplicated to separate an ngon from it's neighboring faces. This changes the mesh's vertex and face information and invalidates any input vertex_face_map. false The mesh was not modified. </li>
</ul>

</div>
</div>
<a id="aecf36e17605dc94bf12c7eb0de2e82c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf36e17605dc94bf12c7eb0de2e82c4">&#9670;&nbsp;</a></span>SetCachedTextureCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___texture_coordinates.html">ON_TextureCoordinates</a>* ON_Mesh::SetCachedTextureCoordinates </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *&#160;</td>
          <td class="paramname"><em>mesh_xform</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLazy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82f7f797aea84ffd659211c8eab42f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82f7f797aea84ffd659211c8eab42f87">&#9670;&nbsp;</a></span>SetCachedTextureCoordinatesEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___texture_coordinates.html">ON_TextureCoordinates</a>* ON_Mesh::SetCachedTextureCoordinatesEx </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *&#160;</td>
          <td class="paramname"><em>mesh_xform</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLazy</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSeamCheck</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5929a47378ca44d6703e59b32afd5e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5929a47378ca44d6703e59b32afd5e5">&#9670;&nbsp;</a></span>SetClosed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::SetClosed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>closed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user function to set m_is_closed member. <br  />
 Setting this value correctly after a mesh is constructed can save time when <a class="el" href="class_o_n___mesh.html#a028ab06bfe084fb116e101f91f82fa7e">IsClosed()</a> is called. This function sets the private member variable m_is_closed. Paramters: closed - [in] 0: The mesh is not closed. There is at least one face with an edge that is geometrically distinct (as an unoriented line segment) from all other edges. 1: The mesh is closed. Every geometrically distict edge is used by two or more faces. </p>

</div>
</div>
<a id="a734a124c91c1a3d3b36b0c85e6924e79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734a124c91c1a3d3b36b0c85e6924e79">&#9670;&nbsp;</a></span>SetMeshParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::SetMeshParameters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___mesh_parameters.html">ON_MeshParameters</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae0b8319c20e21c5951a756cf0487dcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0b8319c20e21c5951a756cf0487dcaf">&#9670;&nbsp;</a></span>SetNgonCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::SetNgonCount </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set the n-gon count. Null n-gons are be appended when ngon_count &gt; current count. Existing n-gons are removed when ngon_count &lt; current count. Parameters: ngon_count - [in] Number of n-gons to have. 0: removes all ngons. Remarks: The mesh triangles that make up any removed n-gons are not deleted. </p>

</div>
</div>
<a id="a856a3af6a33cda2fc94e9706afc103b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a856a3af6a33cda2fc94e9706afc103b4">&#9670;&nbsp;</a></span>SetNgonVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetNgonVertexNormals </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>ngon_index1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: For each ngon with index in the specified range, all vertices in the ngon will have their vertex normal set to the normal of the first face in the ngon. Parameters: ngon_index0 - [in] ngon_index1 - [in] ngons with indices ni satisfying ngon_index0 &lt;= ni &lt; ngon_index1 will be separated. To separate every ngon in a mesh, pass ngon_index0 = 0 and ngon_index1 = mesh-&gt;<a class="el" href="class_o_n___mesh.html#a4351c0a15e835215552431473ab84fb4">NgonCount()</a>. <br  />
 Returns: true one or more vertices were duplicated to separate an ngon from it's neighboring faces. This changes the mesh's vertex and face information and invalidates any input vertex_face_map. false The mesh was not modified. </p>

</div>
</div>
<a id="ab515fbc0a7c92619da7701024dc4c2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab515fbc0a7c92619da7701024dc4c2b7">&#9670;&nbsp;</a></span>SetQuad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetQuad </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3be0087786c0ecb82965bb30e890a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3be0087786c0ecb82965bb30e890a74">&#9670;&nbsp;</a></span>SetSolidOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::SetSolidOrientation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>solid_orientation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user function to set m_is_solid member. <br  />
 Setting this value correctly after a mesh is constructed can save time when <a class="el" href="class_o_n___mesh.html#a064f4ce98ffdba6c40d6eec8daf8cf1d">IsSolid()</a> is called. This function sets the private member variable m_is_solid. If solid is nonzero, it will set m_is_closed to 1. Paramters: solid - [in] 0: The mesh is not an oriented manifold solid mesh. Either the mesh is not closed, not manifold, or the faces are not oriented compatibly. 1: The mesh is an oriented manifold solid whose face normals point outwards. -1: The mesh is an oriented manifold solid whose face normals point inwards. </p>

</div>
</div>
<a id="ae8f3ae98710815f6b9dda28e1649e634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f3ae98710815f6b9dda28e1649e634">&#9670;&nbsp;</a></span>SetSurfaceParamtersFromTextureCoodinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetSurfaceParamtersFromTextureCoodinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If the mesh does not have surface evaulation parameters, has texture coordinates, and the surface parameters can be set in a way so the existing texture coordinates can be computed from the surface parameters, then this function sets the surface parameters. This is useful when meshes that have texture coordinates and do not have surface parameters want ot set the surface parameters in a way so that the texture mapping <a class="el" href="class_o_n___texture_mapping.html#acc07e2903b5440b2a2c3303c21c297d9">ON_TextureMapping::SurfaceParameterTextureMapping</a> will restore the texture coordinates. Returns: true - successful false - failure - no changes made to the mesh. </p>

</div>
</div>
<a id="ad8afa3775940a5bc48600d5f4d205a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8afa3775940a5bc48600d5f4d205a5a">&#9670;&nbsp;</a></span>SetTextureCoord()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetTextureCoord </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac63b1a95fe549071b2500ba9ea2c8319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63b1a95fe549071b2500ba9ea2c8319">&#9670;&nbsp;</a></span>SetTextureCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetTextureCoordinates </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *&#160;</td>
          <td class="paramname"><em>mesh_xform</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLazy</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Use a texture mapping function to set the m_T[] values. Parameters: mapping - [in] mesh_xform - [in] If not nullptr, the mapping calculation is performed as if the mesh were transformed by mesh_xform; the location of the mesh is not changed. bLazy - [in] If true and the m_T[] values were set using the same mapping parameters, then no calculation is performed. Returns: True if successful. See Also: <a class="el" href="class_o_n___texture_mapping.html#a8465fda24c41092aec22bbf01172e4a0">ON_TextureMapping::GetTextureCoordinates</a> </p>

</div>
</div>
<a id="a2b3e29046b35bb62806d6b50c3c9da57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3e29046b35bb62806d6b50c3c9da57">&#9670;&nbsp;</a></span>SetTextureCoordinatesEx()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetTextureCoordinatesEx </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *&#160;</td>
          <td class="paramname"><em>mesh_xform</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLazy</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSeamCheck</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Use a texture mapping function to set the m_T[] values. Parameters: mapping - [in] mesh_xform - [in] If not nullptr, the mapping calculation is performed as if the mesh were transformed by mesh_xform; the location of the mesh is not changed. bLazy - [in] If true and the m_T[] values were set using the same mapping parameters, then no calculation is performed. bSeamCheck - [in] If true then some mesh edges might be unwelded to better represent UV discontinuities in the texture mapping. This only happens for the following mappings: Box, Sphere, Cylinder. Returns: True if successful. See Also: <a class="el" href="class_o_n___texture_mapping.html#a8465fda24c41092aec22bbf01172e4a0">ON_TextureMapping::GetTextureCoordinates</a> </p>

</div>
</div>
<a id="a12c59eade1b16f97315c819a6cdb050a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c59eade1b16f97315c819a6cdb050a">&#9670;&nbsp;</a></span>SetTriangle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetTriangle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af734006dba8a02b93a63362f79b33687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af734006dba8a02b93a63362f79b33687">&#9670;&nbsp;</a></span>SetVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>creation </p>

</div>
</div>
<a id="ac3fc61ee539ef1f675eb21f1e3280564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fc61ee539ef1f675eb21f1e3280564">&#9670;&nbsp;</a></span>SetVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetVertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3f_point.html">ON_3fPoint</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2465f42f9a69bc215f54190781d2e606"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2465f42f9a69bc215f54190781d2e606">&#9670;&nbsp;</a></span>SetVertexHiddenFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::SetVertexHiddenFlag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshvi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bHidden</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set the runtime vertex hidden flag. Parameters: meshvi - [in] mesh vertex index bHidden - [in] true to hide vertex </p>

</div>
</div>
<a id="a23b25135257b2ab8e82576df04c1944f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b25135257b2ab8e82576df04c1944f">&#9670;&nbsp;</a></span>SetVertexNormal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetVertexNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac90a3568093e3fa55250a83f5e8a2611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90a3568093e3fa55250a83f5e8a2611">&#9670;&nbsp;</a></span>SetVertexNormal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SetVertexNormal </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3f_vector.html">ON_3fVector</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a795963e1da89ea2d8aed31fe5f79365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a795963e1da89ea2d8aed31fe5f79365c">&#9670;&nbsp;</a></span>SizeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::SizeOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___object.html">ON_Object</a> overrides. </p>
<p>virtual <a class="el" href="class_o_n___object.html#a0299df21bfed90d7b5bfb24cdcf5e6c1">ON_Object::SizeOf</a> override </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a0299df21bfed90d7b5bfb24cdcf5e6c1">ON_Object</a>.</p>

</div>
</div>
<a id="a59e152a0038bf5a96071b5c6ff3a2ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e152a0038bf5a96071b5c6ff3a2ef4">&#9670;&nbsp;</a></span>SolidOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::SolidOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Determine orientation of a mesh. Returns: +1 mesh is a solid with outward facing normals -1 mesh is a solid with inward facing normals 0 mesh is not a solid See Also: <a class="el" href="class_o_n___mesh.html#a064f4ce98ffdba6c40d6eec8daf8cf1d">ON_Mesh::IsSolid</a> </p>

</div>
</div>
<a id="aac1b6eec5e11ecc564037ddd342af32e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac1b6eec5e11ecc564037ddd342af32e">&#9670;&nbsp;</a></span>Split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::Split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshesThatSplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitAtCoplanar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createNgons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>somethingHappened</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *&#160;</td>
          <td class="paramname"><em>cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *&#160;</td>
          <td class="paramname"><em>reporter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Splits the current mesh and returns the split result. If nothing happened, the current mesh is not copied. Instead, somethingHappened is set to false. Parameters: meshesThatSplit - [in] The mesh splitters. nullptr entries are tolerated. tolerance - [in] A 3d-distance tolerance value. If tolerance is:</p><ul>
<li>negative: the positive value will be used.</li>
<li>0.0: no tolerance will be used. This is rarely useful, and only in cases where perforations intersections happen inside faces, and/or there is coplanarity parallel to one of the three fundamental axes.</li>
<li>ON_DBL_QNAN, ON_UNSET_VALUE and ON_UNSET_POSITIVE_VALUE: the function picks a suitable, or default, tolerance value. WARNING! Generally, good tolerance values for objects drawn near the origin are in the magnitude of 10^-7, or ON_SQRT_EPSILON * 10. Often, the document absolute tolerance is not a good tolerance value. You might use a fractional coeffiecient to scale the document tolerance to a suitable value, while accepting a user-provided value. This function expects that each mesh conforms to the tolerance that is provided, and that means that features in the mesh are always larger than the mentioned tolerance. Coplanar gaps between meshes that are smaller than tolerance are overlaps. somethingHappened - [out] If not nullptr, informs the caller if the mesh was actually hit by anything. results - [out] This array will be filled with the split result. If nothing happened, the current mesh is not copied. log - [out] If not nullptr, intersection warnings and errors are printed here. If the intersection runs smoothly, nothing will be printed. cancel - [out] If not nullptr, a trigger to request termination. When cancellation is requested, the return value will often be false. You are responsible to delete new objects that were returned, even if you requested cancellation. reporter - [out] If not nullptr, an indicative progress is reported. Returns: true if the computation finished successfully, false otherwise. </li>
</ul>

</div>
</div>
<a id="a787131c36a85439f7a15cbff46a81b73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787131c36a85439f7a15cbff46a81b73">&#9670;&nbsp;</a></span>SplitArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_Mesh::SplitArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshesToSplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>meshesThatSplit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>splitAtCoplanar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createNgons</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>somethingHappened</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>log</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___terminator.html">ON_Terminator</a> *&#160;</td>
          <td class="paramname"><em>cancel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___progress_reporter.html">ON_ProgressReporter</a> *&#160;</td>
          <td class="paramname"><em>reporter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Splits a list of meshes. See the parameter description two methods above. Additional parameter: createNgons - If true, ngons are created along the splitting ridge to preserve the boundary look. </p>

</div>
</div>
<a id="ab7a137c9bd26335e1ba37d285ca88169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a137c9bd26335e1ba37d285ca88169">&#9670;&nbsp;</a></span>SwapCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SwapCoordinates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Swaps object coordinate values with indices i and j.</p>
<p>Parameters: i - [in] coordinate index j - [in] coordinate index</p>
<p>Remarks: The default implementation uses the virtual <a class="el" href="class_o_n___mesh.html#ad115dd0a3ad64cda398bbe90e08c8bf6">Transform()</a> function to calculate the result. If you are creating an object where <a class="el" href="class_o_n___mesh.html#ad115dd0a3ad64cda398bbe90e08c8bf6">Transform()</a> is slow, coordinate swapping will be frequently used, and coordinate swapping can be quickly accomplished, then override this function.</p>
<p>Example: </p><pre class="fragment">     ON_Point point(7,8,9);
     point.SwapCoordinates(0,2);
     ///&lt; point = (9,8,7) 
</pre> 
<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#a737d7b1433104a39298629931e899cd4">ON_Geometry</a>.</p>

</div>
</div>
<a id="a14ed95524bdd6ce006fc9943e3f6543b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14ed95524bdd6ce006fc9943e3f6543b">&#9670;&nbsp;</a></span>SwapEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::SwapEdge </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>topei</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If the edge is shared by two triangular face, then the edge is "swapped". Parameters: topei - [in] index of edge in MeshTopology().m_tope[] array Returns: true if successful See Also: <a class="el" href="class_o_n___mesh.html#a45266824480cc73f6ff520c480a86ed4">ON_Mesh::IsSwappableEdge</a> </p>

</div>
</div>
<a id="af24a886d37eb19d3525530480e1f18e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af24a886d37eb19d3525530480e1f18e7">&#9670;&nbsp;</a></span>Topology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___mesh_topology.html">ON_MeshTopology</a>&amp; ON_Mesh::Topology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mesh topology</p>
<p>In order to keep the mesh facet definition simple and make the mesh definition easily used in common rendering application, if two facets share a vertex location but have different normals, curvatures, textures, etc., at that common vertex location, then the vertex is duplicated. When the topology of the mesh needs to be known, use <a class="el" href="class_o_n___mesh.html#af24a886d37eb19d3525530480e1f18e7">Topology()</a> to get a class that provides complete topological information about the mesh. </p>

</div>
</div>
<a id="ad0112c37f50a593ea418e7b98a83697e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0112c37f50a593ea418e7b98a83697e">&#9670;&nbsp;</a></span>TopologyExists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::TopologyExists </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: This is an expert user function that returns true if the topology information is already calculated and cached. It can be used to to avoid calling the <a class="el" href="class_o_n___mesh.html#af24a886d37eb19d3525530480e1f18e7">Topology()</a> function when the expensive creation step will be performed. obsolete - used <a class="el" href="class_o_n___mesh.html#ad4e263be3e64bcf04bcf6151d1f93f75">HasMeshTopology()</a> </p>

</div>
</div>
<a id="ad115dd0a3ad64cda398bbe90e08c8bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad115dd0a3ad64cda398bbe90e08c8bf6">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Transforms the object.</p>
<p>Parameters: xform - [in] transformation to apply to object. If xform.IsSimilarity() is zero, then you may want to call MakeSquishy() before calling Transform.</p>
<p>Remarks: When overriding this function, be sure to include a call to <a class="el" href="class_o_n___object.html#a881bd2f0d8515adba1c42c578bcb7052">ON_Object::TransformUserData()</a> which takes care of transforming any <a class="el" href="class_o_n___user_data.html">ON_UserData</a> that may be attached to the object.</p>
<p>See Also: <a class="el" href="class_o_n___geometry.html#af156cd098b9e68fab5f32e76b1e274e2">ON_Geometry::IsDeformable()</a>;</p>
<p>Remarks: Classes derived from <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> should call <a class="el" href="class_o_n___geometry.html#add710872e89bc29e1ed1321b3e70b1b1">ON_Geometry::Transform()</a> to handle user data transformations and then transform their definition. </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#add710872e89bc29e1ed1321b3e70b1b1">ON_Geometry</a>.</p>

</div>
</div>
<a id="a34af8bca8ce0fa49869631284b3550af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34af8bca8ce0fa49869631284b3550af">&#9670;&nbsp;</a></span>TransposeSurfaceParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::TransposeSurfaceParameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2961b83326bdb975bda84840e20b6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2961b83326bdb975bda84840e20b6d6">&#9670;&nbsp;</a></span>TransposeTextureCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::TransposeTextureCoordinates </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Transposes the texture coordinates Returns true - success </p>

</div>
</div>
<a id="a598a283bddc566a549f1aeb60dc058a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598a283bddc566a549f1aeb60dc058a9">&#9670;&nbsp;</a></span>TriangleCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::TriangleCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of faces that are triangles </p>

</div>
</div>
<a id="a1fb9371d4e542fe67912f877f6984d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb9371d4e542fe67912f877f6984d44">&#9670;&nbsp;</a></span>UnitizeFaceNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::UnitizeFaceNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50356fc532f6dcdd258468df333d6e01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50356fc532f6dcdd258468df333d6e01">&#9670;&nbsp;</a></span>UnitizeVertexNormals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::UnitizeVertexNormals </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab94df03536804d2573b383699db4c57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab94df03536804d2573b383699db4c57">&#9670;&nbsp;</a></span>UpdateDoublePrecisionVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::UpdateDoublePrecisionVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If you modify the values of the single precision vertices in m_V[], then you must call <a class="el" href="class_o_n___mesh.html#aab94df03536804d2573b383699db4c57">UpdateDoublePrecisionVertices()</a>. Remarks: If double precision vertices are not present, this function creates them. </p>

</div>
</div>
<a id="ac78c5b48affca5a6218278c7037a2776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78c5b48affca5a6218278c7037a2776">&#9670;&nbsp;</a></span>UpdateSinglePrecisionVertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::UpdateSinglePrecisionVertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If you modify the values of double precision vertices, then you must call UpdateSinglePrecisonVertices(). Remarks: If double precision vertices are not present, this function does nothing. </p>

</div>
</div>
<a id="a75b42b3e7a203c6844c3be9d1b434fbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b42b3e7a203c6844c3be9d1b434fbf">&#9670;&nbsp;</a></span>V4V5_DestroyNgonList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_Mesh::V4V5_DestroyNgonList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Destroy any existing N-gon list. </p>

</div>
</div>
<a id="a7c3cc6fbfda985824bc42c5f462cd7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3cc6fbfda985824bc42c5f462cd7b7">&#9670;&nbsp;</a></span>V4V5_ModifyNgonList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class ON_V4V5_MeshNgonList* ON_Mesh::V4V5_ModifyNgonList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If an N-gon list exists, it is returned and can be modified. If no N-gon list exists, a new empty list is returned and it can be modified. Returns: A pointer to the N-gon list that can be modified. </p>

</div>
</div>
<a id="a62c8242a99bb4f8f173558675f9a1eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62c8242a99bb4f8f173558675f9a1eb7">&#9670;&nbsp;</a></span>V4V5_NgonList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class ON_V4V5_MeshNgonList* ON_Mesh::V4V5_NgonList </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>mesh N-gon lists. <br  />
 <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> objects support faces that are triangle or quads. When a mesh is created from a format that supports N-gons for N larger than 4, an optional N-gon list can be added that specifies the vertices and faces that make up the N-gon. Description: If the mesh has an N-gon list, return a pointer to it. Returns: A pointer to the current N-gon list or nullptr. </p>

</div>
</div>
<a id="a176b42a1a76666bff52ed72e77007006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176b42a1a76666bff52ed72e77007006">&#9670;&nbsp;</a></span>Vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_Mesh::Vertex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>vertex_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Location of the vertex. If double precision vertices are present, the double precision vertex location is returned. If vertex_index is out of range, ON_UNSET_VALUE is returned. </p>

</div>
</div>
<a id="a96f6f2497feca5e9ba8a038f260c07e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f6f2497feca5e9ba8a038f260c07e5">&#9670;&nbsp;</a></span>VertexCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::VertexCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>query </p>

</div>
</div>
<a id="a30d559932d255011e1c3389e4d0dd29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d559932d255011e1c3389e4d0dd29e">&#9670;&nbsp;</a></span>VertexIsHidden()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::VertexIsHidden </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>meshvi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Returns true if the mesh vertex is hidden. This is a runtime setting that is not saved in 3dm files. Parameters: meshvi - [in] mesh vertex index. Returns: True if mesh vertex is hidden. </p>

</div>
</div>
<a id="a570150a61ae34746d3ef1ef02c8d7612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570150a61ae34746d3ef1ef02c8d7612">&#9670;&nbsp;</a></span>VertexUnsignedCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_Mesh::VertexUnsignedCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7c016b38cda75a98a1648c1001c1d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c016b38cda75a98a1648c1001c1d6c">&#9670;&nbsp;</a></span>Volume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_Mesh::Volume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>base_point</em> = <code><a class="el" href="class_o_n__3d_point.html#ae5dcca5dde698b25a7ec98b3868285b5">ON_3dPoint::Origin</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>error_estimate</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Compute volume of the mesh. Parameters: base_point - [in] optional base point When computing the volume of solid defined by several meshes, pass the same base_point to each call to volume. When computing the volume of a solid defined by a single mesh, the center of the bounding box is a good choice for base_point. error_estimate - [out] if not nullptr, an upper bound on the error in the volume calculation is returned. Returns: volume of the mesh. Example:</p>
<p>/ Assume a solid is enclosed by 3 meshes, mesh1, mesh2, and mesh3. / The volume of the solid can be computed as follows. <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> mesh1=..., mesh2=..., mesh3=...; / use the center of the solid's bounding box as a common base point. <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> bbox = mesh1.BoundingBox(); mesh2.GetBoundingBox(bbox,true); mesh3.GetBoundingBox(bbox,true); <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> base_point = bbox.Center() double vol1_err, vol2_err, vol3_err; double vol1 = mesh1.Volume(base_point,&amp;vol1_err); double vol2 = mesh2.Volume(base_point,&amp;vol2_err); double vol3 = mesh3.Volume(base_point,&amp;vol3_err); double volume = vol1 + vol2 + vol3; double error_estimate = vol1_err + vol2_err + vol3_err; printf("mesh volumd = %g (+/- %g)\n",volume,error_estimate); </p>

</div>
</div>
<a id="aa607ea044e3e95c8404019416e5dfdfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa607ea044e3e95c8404019416e5dfdfe">&#9670;&nbsp;</a></span>VolumeCentroid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_Mesh::VolumeCentroid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>base_point</em> = <code><a class="el" href="class_o_n__3d_point.html#ae5dcca5dde698b25a7ec98b3868285b5">ON_3dPoint::Origin</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>volume</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Compute volume centroid of the mesh. Parameters: base_point - [in] When computing the centroid of a solid volume defined by several meshes, pass the same base_point to each call to GetVolumeCentroid() and add the answers. When computing the centroid of a solid defined by a single mesh, the center of the bounding box is a good choice for base_point. volume - [out] it not nullptr, Volume of the mesh Returns: Location of the volume centroid. </p>

</div>
</div>
<a id="aa6a1b4435044cb9bd612ca013faed17b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a1b4435044cb9bd612ca013faed17b">&#9670;&nbsp;</a></span>VolumeMassProperties()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::VolumeMassProperties </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___mass_properties.html">ON_MassProperties</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVolume</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFirstMoments</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSecondMoments</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bProductMoments</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>base_point</em> = <code><a class="el" href="class_o_n__3d_point.html#aa68906e3e7650b01ce88c527f6088d7d">ON_3dPoint::UnsetPoint</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Calculate volume mass properties of the mesh. Parameters: base_point - [in] When computing the volume mass properties of a solid volume defined by several meshes, pass the same base_point to each call to <a class="el" href="class_o_n___mesh.html#aa6a1b4435044cb9bd612ca013faed17b">VolumeMassProperties()</a> and add the answers. When computing the volume mass properties of a solid defined by a single mesh, the center of the bounding box is a good choice for base_point. If the mesh is closed, you can pass <a class="el" href="class_o_n__3d_point.html#aa68906e3e7650b01ce88c527f6088d7d" title="(ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)">ON_3dPoint::UnsetPoint</a> and the center of the bounding box will be used. mp - [out] bVolume - [in] true to calculate volume bFirstMoments - [in] true to calculate volume first moments, volume, and volume centroid. bSecondMoments - [in] true to calculate volume second moments. bProductMoments - [in] true to calculate volume product moments. base_point - [in] If the surface is closed, then pass ON_UNSET_VALUE.</p>
<p>This parameter is for expert users who are computing a volume whose boundary is defined by several non-closed breps, surfaces, and meshes.</p>
<p>When computing the volume, volume centroid, or volume first moments of a volume whose boundary is defined by several breps, surfaces, and meshes, pass the same base_point to each call to VolumeMassProperties. <br  />
</p>
<p>When computing the volume second moments or volume product moments of a volume whose boundary is defined by several breps, surfaces, and meshes, you MUST pass the entire volume's centroid as the base_point and the input mp parameter must contain the results of a previous call to VolumeMassProperties(mp,true,true,false,false,base_point). In particular, in this case, you need to make two sets of calls; use first set to calculate the volume centroid and the second set calculate the second moments and product moments. Returns: True if successful. </p>

</div>
</div>
<a id="ad4d8ee57465bcf4458dc5fbb55628423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d8ee57465bcf4458dc5fbb55628423">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>binary_archive</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Low level archive writing tool used by <a class="el" href="class_o_n___binary_archive.html#a33187abe5d04ac52c41d7a798e664f3b" title="writes object definition">ON_BinaryArchive::WriteObject()</a>. Parameters: binary_archive - archive to write to Returns: Returns true if the write is successful. Remarks: Use <a class="el" href="class_o_n___binary_archive.html#a33187abe5d04ac52c41d7a798e664f3b" title="writes object definition">ON_BinaryArchive::WriteObject()</a> to write objects. This <a class="el" href="class_o_n___mesh.html#ad4d8ee57465bcf4458dc5fbb55628423">Write()</a> function should just write the specific definition of this object. It should not write and any chunk typecode or length information. <br  />
</p>
<p>The default implementation of this virtual function returns false and does nothing. </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a16eb9ab6bf0d0a614655cf9cd055871a">ON_Object</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a210bd7d627ff486ac874ab4c226ab6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210bd7d627ff486ac874ab4c226ab6c8">&#9670;&nbsp;</a></span>Empty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> ON_Mesh::Empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3eaa9b3a794729ab14d9c610e485d01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eaa9b3a794729ab14d9c610e485d01e">&#9670;&nbsp;</a></span>m_C</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;<a class="el" href="class_o_n___color.html">ON_Color</a>&gt; ON_Mesh::m_C</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>OPTIONAL vertex color Either m_C[] has zero count or it has the same count as m_V[], in which case m_C[j] reports the color assigned to m_V[j]. </p>

</div>
</div>
<a id="a9caa1b55e23568cd492840c0290f56f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9caa1b55e23568cd492840c0290f56f3">&#9670;&nbsp;</a></span>m_Ctag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> ON_Mesh::m_Ctag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation - false color. </p>
<p>OPTIONAL tag for values in m_C[] </p>

</div>
</div>
<a id="a7496a0e3ba5f171adb216a482ce057ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7496a0e3ba5f171adb216a482ce057ae">&#9670;&nbsp;</a></span>m_dV</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a> ON_Mesh::m_dV</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: m_dV[] double precision vertices. m_V[] single precision vertices.</p>
<p>If m_dV[] is not empty, then m_V and m_dV should have the same length and <a class="el" href="class_o_n___mesh.html#a6caf4d03d31476b0b09763023d44e8a9">HasSynchronizedDoubleAndSinglePrecisionVertices()</a> should be true.</p>
<p>Otherwise a bug incorrectly modified vertex location information.</p>
<p>If m_dV[] and m_V[] are in use and you modify vertex locations or count, then your calculation should insure both are properly updated. </p>

</div>
</div>
<a id="a005e7e4b0f04014c289264e06e496450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005e7e4b0f04014c289264e06e496450">&#9670;&nbsp;</a></span>m_F</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;<a class="el" href="class_o_n___mesh_face.html">ON_MeshFace</a>&gt; ON_Mesh::m_F</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>m_F[] facets (triangles or quads) </p>

</div>
</div>
<a id="a61b4408beb9cd28c90ddb4ec8492f499"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b4408beb9cd28c90ddb4ec8492f499">&#9670;&nbsp;</a></span>m_FN</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3f_vector_array.html">ON_3fVectorArray</a> ON_Mesh::m_FN</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>m_FN[] OPTIONAL face unit normals If m_FN[] is empty or m_FN.Count() != m_F.Count(), then m_FN is ignored. Otherwise m_FN[j] is the unit normal for the facet m_F[j]. </p>

</div>
</div>
<a id="a2a166eabbd9f7f0e141e30325f6783f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a166eabbd9f7f0e141e30325f6783f8">&#9670;&nbsp;</a></span>m_H</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;bool&gt; ON_Mesh::m_H</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation - runtime vertex visibility - not saved in 3dm files. </p>
<p>OPTIONAL vertex visibility. If m_H.Count() = m_V.Count(), then m_H[vi] is true if the vertex m_V[vi] is hidden. Otherwise, all vertices are visible. </p>

</div>
</div>
<a id="a532418e6af843813ecc81246a8da7eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532418e6af843813ecc81246a8da7eef">&#9670;&nbsp;</a></span>m_hidden_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::m_hidden_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>number of vertices that are hidden = number of true values in m_H[] array. </p>

</div>
</div>
<a id="a283e17b42b01749486e447a56acd5f60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283e17b42b01749486e447a56acd5f60">&#9670;&nbsp;</a></span>m_invalid_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::m_invalid_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f353770ff5fcc259d21e8a162d3e9d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f353770ff5fcc259d21e8a162d3e9d8">&#9670;&nbsp;</a></span>m_K</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;<a class="el" href="class_o_n___surface_curvature.html">ON_SurfaceCurvature</a>&gt; ON_Mesh::m_K</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation - curvature. </p>
<p>OPTIONAL surface curvatures Either m_K[] has zero count or it has the same count as m_V[], in which case m_K[j] reports the surface curvatures at m_V[j]. </p>

</div>
</div>
<a id="a14d1b43c587734c9c34ee58324fd88b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d1b43c587734c9c34ee58324fd88b4">&#9670;&nbsp;</a></span>m_kstat</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh_curvature_stats.html">ON_MeshCurvatureStats</a>* ON_Mesh::m_kstat[4]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>gaussian,mean,min,max,sectionx,sectiony,sectionz </p>

</div>
</div>
<a id="aaf44985cbb5e3d74e80d342226cc259e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf44985cbb5e3d74e80d342226cc259e">&#9670;&nbsp;</a></span>m_mesh_parameters</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh_parameters.html">ON_MeshParameters</a>* ON_Mesh::m_mesh_parameters</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If mesh was created from a parametric surface, these parameters were used to create the mesh. </p>

</div>
</div>
<a id="af5c95b35080197efd6f43ab5830efe9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c95b35080197efd6f43ab5830efe9f">&#9670;&nbsp;</a></span>m_N</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3f_vector_array.html">ON_3fVectorArray</a> ON_Mesh::m_N</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Vertex and Face normal implementation m_N[] OPTIONAL vertex unit normals If m_N[] is empty or m_N.Count() != m_V.Count(), Either m_N[] has zero count or it m_N[j] is the the unit vertex normal at m_V[j]. </p>

</div>
</div>
<a id="aa60c942b6427718bf0ea8e0b398a61fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60c942b6427718bf0ea8e0b398a61fa">&#9670;&nbsp;</a></span>m_nbox</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ON_Mesh::m_nbox[2][3]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>3d bounding box of all referenced unit normals (for estimation of Gauss map bounds) </p>

</div>
</div>
<a id="ab91153bed501502cd587b18884c48d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91153bed501502cd587b18884c48d22">&#9670;&nbsp;</a></span>m_Ngon</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;<a class="el" href="class_o_n___mesh_ngon.html">ON_MeshNgon</a>*&gt; ON_Mesh::m_Ngon</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f60e99fe72ecdd5edea702c7ec73363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f60e99fe72ecdd5edea702c7ec73363">&#9670;&nbsp;</a></span>m_NgonAllocator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh_ngon_allocator.html">ON_MeshNgonAllocator</a> ON_Mesh::m_NgonAllocator</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use this to allocate elements added to m_Ngon; </p>

</div>
</div>
<a id="ab992dbdbd1b3202ce27b6aed0eb15827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab992dbdbd1b3202ce27b6aed0eb15827">&#9670;&nbsp;</a></span>m_NgonMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;unsigned int&gt; ON_Mesh::m_NgonMap</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>invalid if m_NgonMap.Count() != m_F.Count() </p>
<p>N-gon implementation If <a class="el" href="class_o_n___mesh.html#a669b054bd1a6ec07a73ed983c226176c">ON_Mesh::HasNgons()</a> is true, then the mesh has n-gons. When a mesh has ngons, m_NgonMap[] is used to determine when a face belongs to an n-gon. If m_NgonMap[fi] &lt; m_Ngon.UnsignedCount(), then it is the index of the N-gon in m_Ngon[] that m_F[] belongs to. Otherwise, m_NgonMap[fi] is ON_UNSET_UINT_INDEX. </p>

</div>
</div>
<a id="abe46dd344baf3956432762bb2f69d90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe46dd344baf3956432762bb2f69d90b">&#9670;&nbsp;</a></span>m_packed_tex_domain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___interval.html">ON_Interval</a> ON_Mesh::m_packed_tex_domain[2]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Packed texture information.</p>
<p>If either of the m_packed_tex_domain[] intervals is a proper subinterval of (0,1), then a texture packing calculation assigned this subrectangle to this mesh. </p>

</div>
</div>
<a id="a859cbfcfa130e9a7433d012064554938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859cbfcfa130e9a7433d012064554938">&#9670;&nbsp;</a></span>m_packed_tex_rotate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_Mesh::m_packed_tex_rotate</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The m_packed_tex_rotate setting is valid only when m_S, m_srf_domain, m_packed_scale[] and m_packed_tex_domain[] are all valid and the texture coordinates are based on surface evaluation parameters. In this special situation, this boolean records the correspondence between the the surface parameters, (u,v), and the packed texture coordinates, (s,t),</p>
<p>m_packed_tex_rotate = false: a = m_srf_domain[0].NormalizedParameterAt(u); b = m_srf_domain[1].NormalizedParameterAt(v); s = m_packed_tex_domain[0].ParameterAt(a); t = m_packed_tex_domain[1].ParameterAt(b);</p>
<p>x = m_packed_tex_domain[0].NormalizedParameterAt(s); y = m_packed_tex_domain[1].NormalizedParameterAt(t); u = m_srf_domain[0].ParameterAt(x); v = m_srf_domain[1].ParameterAt(y);</p>
<p>m_packed_tex_rotate = true: a = m_srf_domain[0].NormalizedParameterAt(u); b = m_srf_domain[1].NormalizedParameterAt(v); s = m_packed_tex_domain[0].ParameterAt(a); t = m_packed_tex_domain[1].ParameterAt(1.0-b);</p>
<p>x = m_packed_tex_domain[0].NormalizedParameterAt(s); y = m_packed_tex_domain[1].NormalizedParameterAt(t); u = m_srf_domain[0].ParameterAt(y); v = m_srf_domain[1].ParameterAt(1.0 - x); </p>

</div>
</div>
<a id="a77c5f065e1c3ae6a160e6931601ccdc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c5f065e1c3ae6a160e6931601ccdc8">&#9670;&nbsp;</a></span>m_parent</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___object.html">ON_Object</a>* ON_Mesh::m_parent</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation - runtime UI information. </p>
<p>runtime parent geometry (use ...::Cast() to get it) </p>

</div>
</div>
<a id="a64decd77fe7b70c0fab3a910844667e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64decd77fe7b70c0fab3a910844667e4">&#9670;&nbsp;</a></span>m_partition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh_partition.html">ON_MeshPartition</a>* ON_Mesh::m_partition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sub-mesh information rendering large meshes </p>

</div>
</div>
<a id="a0e88e56788c06e475b27d239f78c7656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e88e56788c06e475b27d239f78c7656">&#9670;&nbsp;</a></span>m_quad_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::m_quad_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acbf195fbe55da435006a2ba9c66e71e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf195fbe55da435006a2ba9c66e71e4">&#9670;&nbsp;</a></span>m_S</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__2d_point_array.html">ON_2dPointArray</a> ON_Mesh::m_S</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If m_T.Count() == m_V.Count(), then the mesh has texture coordinates and m_T[j] is the texture coordinate for vertex m_V[j].</p>
<p>When opennurbs or Rhino meshes an <a class="el" href="class_o_n___surface.html">ON_Surface</a> or <a class="el" href="class_o_n___brep.html">ON_Brep</a>, the texture coordinates have a "canonical" linear relationship with the surface parameters that is described in the next section. However, various mappings, spherical, planar, cylindrical, etc., can be applied that change the values of the texture coordinates.</p>
<p>If a texture mapping function was used to set the m_T[] values, then the id and serial number of the mapping function is saved in m_mapping_id and m_mapping_sn. The intended use of these fields is to make it easy to avoid unnecessary recalculation. <br  />
 If a mesh is modified, then m_mapping_id should be set to nil and m_mapping_crc should be set to 0. Implementation - surface parameters and packed texture information</p>
<p>If m_S.Count() == m_V.Count(), then the mesh is a tesselation of a parameteric surface and m_S[j] is the surface parameter at m_V[j]. Storing values in m_S[] is OPTIONAL.</p>
<p>If m_srf_scale[] has positive values, then they report the world coordinate size of a rectangle that would minimize texture distortion if it were mapped to the mesh using normalized surface evaluation parameters. This information is used to calculate high quality packed texture coordinates. <br  />
 </p>

</div>
</div>
<a id="a48d982115e07a7a0209d7b35b83a96bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d982115e07a7a0209d7b35b83a96bb">&#9670;&nbsp;</a></span>m_srf_domain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___interval.html">ON_Interval</a> ON_Mesh::m_srf_domain[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>surface evaluation domain. </p>

</div>
</div>
<a id="abfec38c9115fc2045b8d2105dd634ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfec38c9115fc2045b8d2105dd634ff2">&#9670;&nbsp;</a></span>m_srf_scale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_Mesh::m_srf_scale[2]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8813d0559c1834e30af2b86da7d64c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8813d0559c1834e30af2b86da7d64c9">&#9670;&nbsp;</a></span>m_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__2f_point_array.html">ON_2fPointArray</a> ON_Mesh::m_T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OPTIONAL texture coordinates for each vertex. </p>

</div>
</div>
<a id="a26c5690c95d3f26fc86438061f131759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c5690c95d3f26fc86438061f131759">&#9670;&nbsp;</a></span>m_tbox</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float ON_Mesh::m_tbox[2][2]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>2d bounding box of all referenced texture coordinates </p>

</div>
</div>
<a id="a28e3c1473d1817f3606ebc30c7b05bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e3c1473d1817f3606ebc30c7b05bf0">&#9670;&nbsp;</a></span>m_TC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt;<a class="el" href="class_o_n___texture_coordinates.html">ON_TextureCoordinates</a>&gt; ON_Mesh::m_TC</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>RUNTIME ONLY This array is used to cache texture coordinates used by rendering applications that require 1d texture coordinates, 3d texture coordinates, or multiple sets of texture coordinates (e.g. blended textures with different mappings). Users are responsible for verifying m_TC[i].m_T.Count() = m_V.Count() </p>

</div>
</div>
<a id="a72a9c0b4169a22209bc923d7450d3fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72a9c0b4169a22209bc923d7450d3fae">&#9670;&nbsp;</a></span>m_top</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mesh_topology.html">ON_MeshTopology</a> ON_Mesh::m_top</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation - mesh topology. </p>

</div>
</div>
<a id="a093d11d8fa0cc22dee2f284cbc3790e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093d11d8fa0cc22dee2f284cbc3790e0">&#9670;&nbsp;</a></span>m_triangle_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ON_Mesh::m_triangle_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a5f8175918c06ea9b632113e29786b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5f8175918c06ea9b632113e29786b9">&#9670;&nbsp;</a></span>m_Ttag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> ON_Mesh::m_Ttag</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>OPTIONAL tag for values in m_T[]. </p>
<p>Implementation - texture coordinates</p>
<p>OPTIONAL texture coordinates for each vertex It would be nice if this were an <a class="el" href="class_o_n___texture_coordinates.html">ON_TextureCoordinates</a>, but that breaks lots of checked out code that assumes m_T is an array of ON_2fPoints. </p>

</div>
</div>
<a id="a6cc720e646b5fb26e5285b1838f71c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc720e646b5fb26e5285b1838f71c7d">&#9670;&nbsp;</a></span>m_V</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3f_point_array.html">ON_3fPointArray</a> ON_Mesh::m_V</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Apr 21 2022 05:50:03 for Rhino C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
