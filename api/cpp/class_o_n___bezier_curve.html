<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_BezierCurve Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API
   &#160;<span id="projectnumber">7.22</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_o_n___bezier_curve-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_BezierCurve Class Reference<div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_bezier.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ON_BezierCurve:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_n___bezier_curve.png" usemap="#ON_5FBezierCurve_map" alt=""/>
  <map id="ON_5FBezierCurve_map" name="ON_5FBezierCurve_map">
<area href="class_c_rhino_inferred_curve.html" title="9-17-03 LW added in conjunction with inferred curve osnap testing" alt="CRhinoInferredCurve" shape="rect" coords="0,56,135,80"/>
<area href="class_o_n___curve_tree_bezier.html" alt="ON_CurveTreeBezier" shape="rect" coords="145,56,280,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a30890306c8d1a833f8afdb800359c9bd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a30890306c8d1a833f8afdb800359c9bd">ON_BezierCurve</a> ()</td></tr>
<tr class="separator:a30890306c8d1a833f8afdb800359c9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ce0c7eeb20c7f2da68534d79e35498"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ad2ce0c7eeb20c7f2da68534d79e35498">ON_BezierCurve</a> (const <a class="el" href="class_o_n__2d_point_array.html">ON_2dPointArray</a> &amp;)</td></tr>
<tr class="memdesc:ad2ce0c7eeb20c7f2da68534d79e35498"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets control points  <a href="class_o_n___bezier_curve.html#ad2ce0c7eeb20c7f2da68534d79e35498">More...</a><br /></td></tr>
<tr class="separator:ad2ce0c7eeb20c7f2da68534d79e35498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd77f8ce43d1c9420da6ee34c4978179"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#acd77f8ce43d1c9420da6ee34c4978179">ON_BezierCurve</a> (const <a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a> &amp;)</td></tr>
<tr class="memdesc:acd77f8ce43d1c9420da6ee34c4978179"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets control points  <a href="class_o_n___bezier_curve.html#acd77f8ce43d1c9420da6ee34c4978179">More...</a><br /></td></tr>
<tr class="separator:acd77f8ce43d1c9420da6ee34c4978179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1e90bfba67a3aa2f0a60c5279a564dd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ab1e90bfba67a3aa2f0a60c5279a564dd">ON_BezierCurve</a> (const <a class="el" href="class_o_n__4d_point_array.html">ON_4dPointArray</a> &amp;)</td></tr>
<tr class="memdesc:ab1e90bfba67a3aa2f0a60c5279a564dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets control points  <a href="class_o_n___bezier_curve.html#ab1e90bfba67a3aa2f0a60c5279a564dd">More...</a><br /></td></tr>
<tr class="separator:ab1e90bfba67a3aa2f0a60c5279a564dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e2641a404cdea65f9d8379d60258d4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a34e2641a404cdea65f9d8379d60258d4">ON_BezierCurve</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;)</td></tr>
<tr class="separator:a34e2641a404cdea65f9d8379d60258d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa71f8f362638525a861f35d499e5df56"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#aa71f8f362638525a861f35d499e5df56">ON_BezierCurve</a> (const <a class="el" href="class_o_n___polynomial_curve.html">ON_PolynomialCurve</a> &amp;)</td></tr>
<tr class="separator:aa71f8f362638525a861f35d499e5df56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3777383747d6c7f8077feb4288b241"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a2c3777383747d6c7f8077feb4288b241">ON_BezierCurve</a> (int dim, bool bIsRational, int order)</td></tr>
<tr class="separator:a2c3777383747d6c7f8077feb4288b241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29fcd57cd6f27f9384fde7dd97099357"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a29fcd57cd6f27f9384fde7dd97099357">~ON_BezierCurve</a> ()</td></tr>
<tr class="separator:a29fcd57cd6f27f9384fde7dd97099357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a997f4da75f6c101e8ee9203ce4a939"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a9a997f4da75f6c101e8ee9203ce4a939">BoundingBox</a> () const</td></tr>
<tr class="separator:a9a997f4da75f6c101e8ee9203ce4a939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2e636a15d4db9a6848c9fd38812abb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a1e2e636a15d4db9a6848c9fd38812abb">ChangeDimension</a> (int desired_dimension)</td></tr>
<tr class="separator:a1e2e636a15d4db9a6848c9fd38812abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ac3e622db3334bad8043ea6a06eb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a630ac3e622db3334bad8043ea6a06eb3">ChangeWeights</a> (int i0, double w0, int i1, double w1)</td></tr>
<tr class="separator:a630ac3e622db3334bad8043ea6a06eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491702ee8fae3e2c3d08fd3b43197eb4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__4d_point.html">ON_4dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a491702ee8fae3e2c3d08fd3b43197eb4">ControlPoint</a> (int cv_index) const</td></tr>
<tr class="separator:a491702ee8fae3e2c3d08fd3b43197eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6d8d148c6110614a6c341b0b9f3607"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#acc6d8d148c6110614a6c341b0b9f3607">ControlPolygonLength</a> () const</td></tr>
<tr class="separator:acc6d8d148c6110614a6c341b0b9f3607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076efeba8280521673d23dea134f169d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a076efeba8280521673d23dea134f169d">Create</a> (int dim, bool bIsRational, int order)</td></tr>
<tr class="separator:a076efeba8280521673d23dea134f169d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8292eaf36e69f37c1e64785edf9c5f4c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a8292eaf36e69f37c1e64785edf9c5f4c">CurvatureAt</a> (double t) const</td></tr>
<tr class="separator:a8292eaf36e69f37c1e64785edf9c5f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3ed73e3b7e47c132724ed26d96882f"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#adf3ed73e3b7e47c132724ed26d96882f">CV</a> (int cv_index) const</td></tr>
<tr class="separator:adf3ed73e3b7e47c132724ed26d96882f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefdaed25e9aa0b7fde2c4209d0bdbfd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#adefdaed25e9aa0b7fde2c4209d0bdbfd">CVCount</a> () const</td></tr>
<tr class="separator:adefdaed25e9aa0b7fde2c4209d0bdbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8826c25a65fd46596c11ed6981e50108"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a8826c25a65fd46596c11ed6981e50108">CVSize</a> () const</td></tr>
<tr class="separator:a8826c25a65fd46596c11ed6981e50108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59cc73d69a29cd166b04be42c7f15f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56">ON::point_style</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a59cc73d69a29cd166b04be42c7f15f17">CVStyle</a> () const</td></tr>
<tr class="separator:a59cc73d69a29cd166b04be42c7f15f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fe8d5eaf3cb076a52a2fed82dd88478"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a4fe8d5eaf3cb076a52a2fed82dd88478">Degree</a> () const</td></tr>
<tr class="separator:a4fe8d5eaf3cb076a52a2fed82dd88478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ff88ca1a4e42f05b4ed32411f206a0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ad2ff88ca1a4e42f05b4ed32411f206a0">DerivativeAt</a> (double t) const</td></tr>
<tr class="separator:ad2ff88ca1a4e42f05b4ed32411f206a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585a866af061203c5b2d46ee2b9aa2a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a585a866af061203c5b2d46ee2b9aa2a7">Destroy</a> ()</td></tr>
<tr class="separator:a585a866af061203c5b2d46ee2b9aa2a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0dcef0e68a44f5b0d7e8c67022a7fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a6b0dcef0e68a44f5b0d7e8c67022a7fe">Dimension</a> () const</td></tr>
<tr class="separator:a6b0dcef0e68a44f5b0d7e8c67022a7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b41eb9a733ebc52e59fe11a62bd0104"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___interval.html">ON_Interval</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a1b41eb9a733ebc52e59fe11a62bd0104">Domain</a> () const</td></tr>
<tr class="separator:a1b41eb9a733ebc52e59fe11a62bd0104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc9591499cfe8a045cbd2a09486592f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#afbc9591499cfe8a045cbd2a09486592f">Dump</a> (<a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;) const</td></tr>
<tr class="memdesc:afbc9591499cfe8a045cbd2a09486592f"><td class="mdescLeft">&#160;</td><td class="mdescRight">for debugging  <a href="class_o_n___bezier_curve.html#afbc9591499cfe8a045cbd2a09486592f">More...</a><br /></td></tr>
<tr class="separator:afbc9591499cfe8a045cbd2a09486592f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28db34743881ef2377284a0356388aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a28db34743881ef2377284a0356388aa9">EmergencyDestroy</a> ()</td></tr>
<tr class="memdesc:a28db34743881ef2377284a0356388aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">call if memory used by <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> becomes invalid  <a href="class_o_n___bezier_curve.html#a28db34743881ef2377284a0356388aa9">More...</a><br /></td></tr>
<tr class="separator:a28db34743881ef2377284a0356388aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba587a0b21ef9581bc5c003cc57553f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a3ba587a0b21ef9581bc5c003cc57553f">Ev1Der</a> (double t, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;point, <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;first_derivative) const</td></tr>
<tr class="separator:a3ba587a0b21ef9581bc5c003cc57553f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc29c51047bc606a8afce9f530ff8e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a0fc29c51047bc606a8afce9f530ff8e7">Ev2Der</a> (double t, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;point, <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;first_derivative, <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;second_derivative) const</td></tr>
<tr class="separator:a0fc29c51047bc606a8afce9f530ff8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506fe2ae579c1bb2dfb7ee9fdac96eae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a506fe2ae579c1bb2dfb7ee9fdac96eae">Evaluate</a> (double t, int der_count, int v_stride, double *v) const</td></tr>
<tr class="separator:a506fe2ae579c1bb2dfb7ee9fdac96eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1704492fbab1935dc514e07e62e7bf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ae1704492fbab1935dc514e07e62e7bf3">EvCurvature</a> (double t, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;point, <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;tangent, <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;kappa) const</td></tr>
<tr class="separator:ae1704492fbab1935dc514e07e62e7bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f9c7141aba78552ad63ba19189dc7e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a7f9c7141aba78552ad63ba19189dc7e8">EvPoint</a> (double t, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;point) const</td></tr>
<tr class="separator:a7f9c7141aba78552ad63ba19189dc7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6efa0d2e9ef8812701bd6cefdaf880"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a6b6efa0d2e9ef8812701bd6cefdaf880">EvTangent</a> (double t, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;point, <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;tangent) const</td></tr>
<tr class="separator:a6b6efa0d2e9ef8812701bd6cefdaf880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840b8758b0cc94bb8d98f48251405525"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a840b8758b0cc94bb8d98f48251405525">FindRoots</a> (double *root, double tol=<a class="el" href="group__open_n_u_r_b_s.html#ga384d9713cff6f46d203437be118aab80">ON_ZERO_TOLERANCE</a>) const</td></tr>
<tr class="separator:a840b8758b0cc94bb8d98f48251405525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8889fb447e769a16294957388951aa32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a8889fb447e769a16294957388951aa32">GetBBox</a> (double *box_min, double *box_max, bool bGrowBox=false) const</td></tr>
<tr class="separator:a8889fb447e769a16294957388951aa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7333494a5d1069a9a413617449c273b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a7333494a5d1069a9a413617449c273b3">GetBoundingBox</a> (<a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;bbox, int bGrowBox=false) const</td></tr>
<tr class="separator:a7333494a5d1069a9a413617449c273b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9cce40566d77c208e181a20aaf1589"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a0e9cce40566d77c208e181a20aaf1589">GetClosestPoint</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> P, double *t, double maximum_distance=0.0, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *sub_domain=0) const</td></tr>
<tr class="separator:a0e9cce40566d77c208e181a20aaf1589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d647951d5711ca8e832dcbc90c7792"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a38d647951d5711ca8e832dcbc90c7792">GetCV</a> (int cv_index, <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56">ON::point_style</a> pointstyle, double *cv) const</td></tr>
<tr class="separator:a38d647951d5711ca8e832dcbc90c7792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274cb0b63da5ab4da7bd136806034242"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a274cb0b63da5ab4da7bd136806034242">GetCV</a> (int cv_index, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;point) const</td></tr>
<tr class="separator:a274cb0b63da5ab4da7bd136806034242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa75b2a645c3506e88892e1a745a701e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#aaa75b2a645c3506e88892e1a745a701e">GetCV</a> (int cv_index, <a class="el" href="class_o_n__4d_point.html">ON_4dPoint</a> &amp;point) const</td></tr>
<tr class="separator:aaa75b2a645c3506e88892e1a745a701e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70751fdcb7c69b6d7c3a214f6403ef75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a70751fdcb7c69b6d7c3a214f6403ef75">GetLocalClosestPoint</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> P, double seed_parameter, double *t, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *sub_domain=0) const</td></tr>
<tr class="separator:a70751fdcb7c69b6d7c3a214f6403ef75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e15aebdb8695206e16854932022913"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ab3e15aebdb8695206e16854932022913">GetLocalCurveIntersection</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> *other_bezcrv, double this_seed_t, double other_seed_t, double *this_t, double *other_t, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *this_domain=0, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *other_domain=0) const</td></tr>
<tr class="separator:ab3e15aebdb8695206e16854932022913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bd6489f53780116c5cb0ed4c58620e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ae2bd6489f53780116c5cb0ed4c58620e">GetLocalSurfaceIntersection</a> (const <a class="el" href="class_o_n___bezier_surface.html">ON_BezierSurface</a> *bezsrf, double seed_t, double seed_u, double seed_v, double *t, double *u, double *v, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *tdomain=0, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *udomain=0, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *vdomain=0) const</td></tr>
<tr class="separator:ae2bd6489f53780116c5cb0ed4c58620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96dc2bc03c72815c7453f9b2d3e1cda"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ae96dc2bc03c72815c7453f9b2d3e1cda">GetNurbForm</a> (<a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &amp;nurbs_curve) const</td></tr>
<tr class="separator:ae96dc2bc03c72815c7453f9b2d3e1cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3854ed0083cd4ef0eb0e0662a913bf23"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a3854ed0083cd4ef0eb0e0662a913bf23">GetTightBoundingBox</a> (<a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;tight_bbox, bool bGrowBox=false, const <a class="el" href="class_o_n___xform.html">ON_Xform</a> *xform=nullptr) const</td></tr>
<tr class="separator:a3854ed0083cd4ef0eb0e0662a913bf23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8e7efcb8ed6663bba389cd9edf7b89"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a5e8e7efcb8ed6663bba389cd9edf7b89">IncreaseDegree</a> (int desired_degree)</td></tr>
<tr class="separator:a5e8e7efcb8ed6663bba389cd9edf7b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1f70124b4036fe8f3f18b31101ad46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a4a1f70124b4036fe8f3f18b31101ad46">IntersectCurve</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> *bezierB, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___x___e_v_e_n_t.html">ON_X_EVENT</a> &gt; &amp;x, double intersection_tolerance=0.0, double overlap_tolerance=0.0, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *bezierA_domain=0, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *bezierB_domain=0) const</td></tr>
<tr class="separator:a4a1f70124b4036fe8f3f18b31101ad46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5a8b60d31d0dc173abca58ec73609d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a8c5a8b60d31d0dc173abca58ec73609d">IntersectSelf</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___x___e_v_e_n_t.html">ON_X_EVENT</a> &gt; &amp;x, double intersection_tolerance=0.0) const</td></tr>
<tr class="separator:a8c5a8b60d31d0dc173abca58ec73609d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a914fd841d7452a9b15d6f35bbb697cab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a914fd841d7452a9b15d6f35bbb697cab">IntersectSurface</a> (const <a class="el" href="class_o_n___bezier_surface.html">ON_BezierSurface</a> *bezsrfB, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___x___e_v_e_n_t.html">ON_X_EVENT</a> &gt; &amp;x, double intersection_tolerance=0.0, double overlap_tolerance=0.0, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *bezierA_domain=0, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *bezsrfB_udomain=0, const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *bezsrfB_vdomain=0) const</td></tr>
<tr class="separator:a914fd841d7452a9b15d6f35bbb697cab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc17ead6f3198cc96001ea0bc60852a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#adc17ead6f3198cc96001ea0bc60852a3">IsRational</a> () const</td></tr>
<tr class="separator:adc17ead6f3198cc96001ea0bc60852a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3816923c2564c61fc7a5822c2523dee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ae3816923c2564c61fc7a5822c2523dee">IsValid</a> () const</td></tr>
<tr class="separator:ae3816923c2564c61fc7a5822c2523dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a786c2cf254f997a0a701b16db79da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a60a786c2cf254f997a0a701b16db79da">Loft</a> (const <a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a> &amp;points)</td></tr>
<tr class="separator:a60a786c2cf254f997a0a701b16db79da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f952cc483b85fd093b7ff31d35db52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ac6f952cc483b85fd093b7ff31d35db52">Loft</a> (int pt_dim, int pt_count, int pt_stride, const double *pt, int t_stride, const double *t)</td></tr>
<tr class="separator:ac6f952cc483b85fd093b7ff31d35db52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10eaf62c02829172277d53885848251b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a10eaf62c02829172277d53885848251b">MakeNonRational</a> ()</td></tr>
<tr class="separator:a10eaf62c02829172277d53885848251b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1511bd913d07d30640d4e2c9819e78c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a1511bd913d07d30640d4e2c9819e78c0">MakeRational</a> ()</td></tr>
<tr class="separator:a1511bd913d07d30640d4e2c9819e78c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871b55fa52eb8954120d1b101d98b630"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a871b55fa52eb8954120d1b101d98b630">Morph</a> (const <a class="el" href="class_o_n___space_morph.html">ON_SpaceMorph</a> &amp;morph)</td></tr>
<tr class="separator:a871b55fa52eb8954120d1b101d98b630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e349ce0fe37226959a2d4ab641cb151"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a4e349ce0fe37226959a2d4ab641cb151">operator*</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;B) const</td></tr>
<tr class="separator:a4e349ce0fe37226959a2d4ab641cb151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afb4ddf270f60cb42dbd43224ddd5c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a3afb4ddf270f60cb42dbd43224ddd5c4">operator*</a> (double a) const</td></tr>
<tr class="separator:a3afb4ddf270f60cb42dbd43224ddd5c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446cbce10b8c531f6396f4243fa3e614"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a446cbce10b8c531f6396f4243fa3e614">operator+</a> (const double *v) const</td></tr>
<tr class="separator:a446cbce10b8c531f6396f4243fa3e614"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d723881e841dcf33522f4cedb4d8f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a03d723881e841dcf33522f4cedb4d8f9">operator+</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;B) const</td></tr>
<tr class="separator:a03d723881e841dcf33522f4cedb4d8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce879e42b40ade4e777f401abe452c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a3ce879e42b40ade4e777f401abe452c2">operator+</a> (<a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> v) const</td></tr>
<tr class="memdesc:a3ce879e42b40ade4e777f401abe452c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arithmetic operations.  <a href="class_o_n___bezier_curve.html#a3ce879e42b40ade4e777f401abe452c2">More...</a><br /></td></tr>
<tr class="separator:a3ce879e42b40ade4e777f401abe452c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cb53a04cd5129adeda1df9eb2a54c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a63cb53a04cd5129adeda1df9eb2a54c2">operator-</a> (const double *v) const</td></tr>
<tr class="separator:a63cb53a04cd5129adeda1df9eb2a54c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07db1ce42b2823f4f3dc661172f90bf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a07db1ce42b2823f4f3dc661172f90bf1">operator-</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;crv) const</td></tr>
<tr class="separator:a07db1ce42b2823f4f3dc661172f90bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc495e256105f4b2454ce218801e911e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#abc495e256105f4b2454ce218801e911e">operator-</a> (<a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> v) const</td></tr>
<tr class="separator:abc495e256105f4b2454ce218801e911e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba606a6656f6cac42e14eecfeef7f15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a9ba606a6656f6cac42e14eecfeef7f15">operator=</a> (const <a class="el" href="class_o_n__2d_point_array.html">ON_2dPointArray</a> &amp;)</td></tr>
<tr class="memdesc:a9ba606a6656f6cac42e14eecfeef7f15"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets control points  <a href="class_o_n___bezier_curve.html#a9ba606a6656f6cac42e14eecfeef7f15">More...</a><br /></td></tr>
<tr class="separator:a9ba606a6656f6cac42e14eecfeef7f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9665af5e5a20c5d385b93ee529097ad5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a9665af5e5a20c5d385b93ee529097ad5">operator=</a> (const <a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a> &amp;)</td></tr>
<tr class="memdesc:a9665af5e5a20c5d385b93ee529097ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets control points  <a href="class_o_n___bezier_curve.html#a9665af5e5a20c5d385b93ee529097ad5">More...</a><br /></td></tr>
<tr class="separator:a9665af5e5a20c5d385b93ee529097ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41ab797eef67cc94e41b1bfd1951af9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#aa41ab797eef67cc94e41b1bfd1951af9">operator=</a> (const <a class="el" href="class_o_n__4d_point_array.html">ON_4dPointArray</a> &amp;)</td></tr>
<tr class="memdesc:aa41ab797eef67cc94e41b1bfd1951af9"><td class="mdescLeft">&#160;</td><td class="mdescRight">sets control points  <a href="class_o_n___bezier_curve.html#aa41ab797eef67cc94e41b1bfd1951af9">More...</a><br /></td></tr>
<tr class="separator:aa41ab797eef67cc94e41b1bfd1951af9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a656285f922e3291ad4d13833fffbba64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a656285f922e3291ad4d13833fffbba64">operator=</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;)</td></tr>
<tr class="separator:a656285f922e3291ad4d13833fffbba64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191ee9a7d327ed8d20e90e9bc178398f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a191ee9a7d327ed8d20e90e9bc178398f">operator=</a> (const <a class="el" href="class_o_n___polynomial_curve.html">ON_PolynomialCurve</a> &amp;)</td></tr>
<tr class="separator:a191ee9a7d327ed8d20e90e9bc178398f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27f43e091fcf46b0dc62c4ea4d220a34"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a27f43e091fcf46b0dc62c4ea4d220a34">Order</a> () const</td></tr>
<tr class="memdesc:a27f43e091fcf46b0dc62c4ea4d220a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">order = degree + 1  <a href="class_o_n___bezier_curve.html#a27f43e091fcf46b0dc62c4ea4d220a34">More...</a><br /></td></tr>
<tr class="separator:a27f43e091fcf46b0dc62c4ea4d220a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6c84f8927d05e34f809f62e36c9311"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#abb6c84f8927d05e34f809f62e36c9311">PointAt</a> (double t) const</td></tr>
<tr class="separator:abb6c84f8927d05e34f809f62e36c9311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794bf1683770bb767ef4d95a835ab926"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a794bf1683770bb767ef4d95a835ab926">Reparameterize</a> (double c)</td></tr>
<tr class="separator:a794bf1683770bb767ef4d95a835ab926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9677861f670b922db042e8494802e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a3f9677861f670b922db042e8494802e4">Reparametrize</a> (double)</td></tr>
<tr class="separator:a3f9677861f670b922db042e8494802e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6f6b3b63e96c718ca94748308a8b42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a8c6f6b3b63e96c718ca94748308a8b42">ReserveCVCapacity</a> (int desired_cv_capacity)</td></tr>
<tr class="memdesc:a8c6f6b3b63e96c718ca94748308a8b42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tools for managing CV and knot memory.  <a href="class_o_n___bezier_curve.html#a8c6f6b3b63e96c718ca94748308a8b42">More...</a><br /></td></tr>
<tr class="separator:a8c6f6b3b63e96c718ca94748308a8b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a045711ab41e5fa4136f32bdd2ce7f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a1a045711ab41e5fa4136f32bdd2ce7f1">Reverse</a> ()</td></tr>
<tr class="separator:a1a045711ab41e5fa4136f32bdd2ce7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55e645d31770aa341c818a79fb2e3736"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a55e645d31770aa341c818a79fb2e3736">Rotate</a> (double rotation_angle, const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;rotation_axis, const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;rotation_center)</td></tr>
<tr class="separator:a55e645d31770aa341c818a79fb2e3736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4811cd3bd1387c344a4f47275f7082c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a4811cd3bd1387c344a4f47275f7082c7">Rotate</a> (double sin_angle, double cos_angle, const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;rotation_axis, const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;rotation_center)</td></tr>
<tr class="separator:a4811cd3bd1387c344a4f47275f7082c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab498533a619bae4a28d9bfc9222a6798"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ab498533a619bae4a28d9bfc9222a6798">Scale</a> (double scale_factor)</td></tr>
<tr class="separator:ab498533a619bae4a28d9bfc9222a6798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01d2f24a8ff758e8289b3498fe0b47a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#af01d2f24a8ff758e8289b3498fe0b47a">ScaleConrolPoints</a> (int i, double w)</td></tr>
<tr class="separator:af01d2f24a8ff758e8289b3498fe0b47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418584ac8f35633553c0e0faeb57cc04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a418584ac8f35633553c0e0faeb57cc04">SetCV</a> (int cv_index, const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;point)</td></tr>
<tr class="separator:a418584ac8f35633553c0e0faeb57cc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d84efc04b801b0d5c3c87368d42f64f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a9d84efc04b801b0d5c3c87368d42f64f">SetCV</a> (int cv_index, const <a class="el" href="class_o_n__4d_point.html">ON_4dPoint</a> &amp;point)</td></tr>
<tr class="separator:a9d84efc04b801b0d5c3c87368d42f64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e7f759538be4bb476e4b24a76a216d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a37e7f759538be4bb476e4b24a76a216d">SetCV</a> (int cv_index, <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56">ON::point_style</a> pointstyle, const double *cv)</td></tr>
<tr class="separator:a37e7f759538be4bb476e4b24a76a216d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b12855581ab2fa7fccaddb605207fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a63b12855581ab2fa7fccaddb605207fe">SetWeight</a> (int cv_index, double weight)</td></tr>
<tr class="separator:a63b12855581ab2fa7fccaddb605207fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d6ce22e7838a408cadcdeb24c27093"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a57d6ce22e7838a408cadcdeb24c27093">Split</a> (double t, <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;left_side, <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;right_side) const</td></tr>
<tr class="separator:a57d6ce22e7838a408cadcdeb24c27093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7350035dd2b6e7f8b2d10973095e28fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a7350035dd2b6e7f8b2d10973095e28fd">TangentAt</a> (double t) const</td></tr>
<tr class="separator:a7350035dd2b6e7f8b2d10973095e28fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303c5e51344dd2375c44661e415f460f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a303c5e51344dd2375c44661e415f460f">Transform</a> (const <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform)</td></tr>
<tr class="separator:a303c5e51344dd2375c44661e415f460f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a239661b33a5d44f200fe75dadb3b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ab6a239661b33a5d44f200fe75dadb3b5">Translate</a> (const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;translation_vector)</td></tr>
<tr class="separator:ab6a239661b33a5d44f200fe75dadb3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e29f8c926d7099a1763d52c640b82a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ac2e29f8c926d7099a1763d52c640b82a">Trim</a> (const <a class="el" href="class_o_n___interval.html">ON_Interval</a> &amp;interval)</td></tr>
<tr class="separator:ac2e29f8c926d7099a1763d52c640b82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677e2628da411e8bb88b2e9215d4c608"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a677e2628da411e8bb88b2e9215d4c608">Weight</a> (int cv_index) const</td></tr>
<tr class="separator:a677e2628da411e8bb88b2e9215d4c608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ea11a014c2213a5d99b2d62c29092e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a79ea11a014c2213a5d99b2d62c29092e">ZeroCVs</a> ()</td></tr>
<tr class="separator:a79ea11a014c2213a5d99b2d62c29092e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:afdae122b6dde5c9da54ca996ced9ff79"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#afdae122b6dde5c9da54ca996ced9ff79">CrossProduct</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;<a class="el" href="class_i_rh_rdk_sel_change_1_1_a.html">A</a>, <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> V)</td></tr>
<tr class="separator:afdae122b6dde5c9da54ca996ced9ff79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1dde88b76a61f058300ae228eac1101"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ac1dde88b76a61f058300ae228eac1101">Derivative</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;<a class="el" href="class_i_rh_rdk_sel_change_1_1_a.html">A</a>)</td></tr>
<tr class="separator:ac1dde88b76a61f058300ae228eac1101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca27c2fbc80ef2a6a56dc4906a9806c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a6ca27c2fbc80ef2a6a56dc4906a9806c">Derivative</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;<a class="el" href="class_i_rh_rdk_sel_change_1_1_a.html">A</a>, <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;derivativeA)</td></tr>
<tr class="separator:a6ca27c2fbc80ef2a6a56dc4906a9806c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11239f9518dd606e47703c182a1a318f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a11239f9518dd606e47703c182a1a318f">DotProduct</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;<a class="el" href="class_i_rh_rdk_sel_change_1_1_a.html">A</a>, const double *B)</td></tr>
<tr class="separator:a11239f9518dd606e47703c182a1a318f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a5f493f9df99b217fc4117111b1e7d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ae2a5f493f9df99b217fc4117111b1e7d">DotProduct</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;<a class="el" href="class_i_rh_rdk_sel_change_1_1_a.html">A</a>, const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;B)</td></tr>
<tr class="separator:ae2a5f493f9df99b217fc4117111b1e7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f595aabb9466b10ee3eb1a2f1789be"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a52f595aabb9466b10ee3eb1a2f1789be">DotProduct</a> (const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;<a class="el" href="class_i_rh_rdk_sel_change_1_1_a.html">A</a>, <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> B)</td></tr>
<tr class="separator:a52f595aabb9466b10ee3eb1a2f1789be"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac7232e4c49c237539c487b94d7871d5a"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ac7232e4c49c237539c487b94d7871d5a">m_cv</a></td></tr>
<tr class="memdesc:ac7232e4c49c237539c487b94d7871d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The i-th cv begins at cv[i*m_cv_stride].  <a href="class_o_n___bezier_curve.html#ac7232e4c49c237539c487b94d7871d5a">More...</a><br /></td></tr>
<tr class="separator:ac7232e4c49c237539c487b94d7871d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7b699da1da038e8f397101cd869c9b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#aad7b699da1da038e8f397101cd869c9b">m_cv_capacity</a></td></tr>
<tr class="separator:aad7b699da1da038e8f397101cd869c9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03ddace3cf79ec060a149a698b9a350"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#ab03ddace3cf79ec060a149a698b9a350">m_cv_stride</a></td></tr>
<tr class="memdesc:ab03ddace3cf79ec060a149a698b9a350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of doubles per cv ( &gt;= ((m_is_rat)?m_dim+1:m_dim) )  <a href="class_o_n___bezier_curve.html#ab03ddace3cf79ec060a149a698b9a350">More...</a><br /></td></tr>
<tr class="separator:ab03ddace3cf79ec060a149a698b9a350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af642d39ca0ace27d454f58c683b65452"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#af642d39ca0ace27d454f58c683b65452">m_dim</a></td></tr>
<tr class="memdesc:af642d39ca0ace27d454f58c683b65452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation.  <a href="class_o_n___bezier_curve.html#af642d39ca0ace27d454f58c683b65452">More...</a><br /></td></tr>
<tr class="separator:af642d39ca0ace27d454f58c683b65452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a987b8c9b7eeefa9332c4af5d4eb040e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#a987b8c9b7eeefa9332c4af5d4eb040e6">m_is_rat</a></td></tr>
<tr class="memdesc:a987b8c9b7eeefa9332c4af5d4eb040e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">1 if bezier is rational, 0 if bezier is not rational  <a href="class_o_n___bezier_curve.html#a987b8c9b7eeefa9332c4af5d4eb040e6">More...</a><br /></td></tr>
<tr class="separator:a987b8c9b7eeefa9332c4af5d4eb040e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3a891b29b89395cbe4282ef984a277"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___bezier_curve.html#aea3a891b29b89395cbe4282ef984a277">m_order</a></td></tr>
<tr class="memdesc:aea3a891b29b89395cbe4282ef984a277"><td class="mdescLeft">&#160;</td><td class="mdescRight">order = degree+1  <a href="class_o_n___bezier_curve.html#aea3a891b29b89395cbe4282ef984a277">More...</a><br /></td></tr>
<tr class="separator:aea3a891b29b89395cbe4282ef984a277"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a30890306c8d1a833f8afdb800359c9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30890306c8d1a833f8afdb800359c9bd">&#9670;&nbsp;</a></span>ON_BezierCurve() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_BezierCurve::ON_BezierCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c3777383747d6c7f8077feb4288b241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3777383747d6c7f8077feb4288b241">&#9670;&nbsp;</a></span>ON_BezierCurve() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_BezierCurve::ON_BezierCurve </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsRational</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Creates a bezier with cv memory allocated. Parameters: dim - [in] (&gt;0) dimension of bezier curve bIsRational - [in] true for a rational bezier order - [in] (&gt;=2) order (=degree+1) of bezier curve </p>

</div>
</div>
<a id="a29fcd57cd6f27f9384fde7dd97099357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29fcd57cd6f27f9384fde7dd97099357">&#9670;&nbsp;</a></span>~ON_BezierCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_BezierCurve::~ON_BezierCurve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34e2641a404cdea65f9d8379d60258d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e2641a404cdea65f9d8379d60258d4">&#9670;&nbsp;</a></span>ON_BezierCurve() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_BezierCurve::ON_BezierCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa71f8f362638525a861f35d499e5df56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa71f8f362638525a861f35d499e5df56">&#9670;&nbsp;</a></span>ON_BezierCurve() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_BezierCurve::ON_BezierCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___polynomial_curve.html">ON_PolynomialCurve</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2ce0c7eeb20c7f2da68534d79e35498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ce0c7eeb20c7f2da68534d79e35498">&#9670;&nbsp;</a></span>ON_BezierCurve() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_BezierCurve::ON_BezierCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n__2d_point_array.html">ON_2dPointArray</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets control points </p>

</div>
</div>
<a id="acd77f8ce43d1c9420da6ee34c4978179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd77f8ce43d1c9420da6ee34c4978179">&#9670;&nbsp;</a></span>ON_BezierCurve() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_BezierCurve::ON_BezierCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets control points </p>

</div>
</div>
<a id="ab1e90bfba67a3aa2f0a60c5279a564dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e90bfba67a3aa2f0a60c5279a564dd">&#9670;&nbsp;</a></span>ON_BezierCurve() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_BezierCurve::ON_BezierCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n__4d_point_array.html">ON_4dPointArray</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets control points </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a997f4da75f6c101e8ee9203ce4a939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a997f4da75f6c101e8ee9203ce4a939">&#9670;&nbsp;</a></span>BoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> ON_BezierCurve::BoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Gets bounding box. Returns: Axis aligned bounding box. </p>

</div>
</div>
<a id="a1e2e636a15d4db9a6848c9fd38812abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2e636a15d4db9a6848c9fd38812abb">&#9670;&nbsp;</a></span>ChangeDimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::ChangeDimension </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>desired_dimension</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Change dimension of bezier. Parameters: desired_dimension - [in] Returns: true if successful. false if desired_dimension &lt; 1 </p>

</div>
</div>
<a id="a630ac3e622db3334bad8043ea6a06eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ac3e622db3334bad8043ea6a06eb3">&#9670;&nbsp;</a></span>ChangeWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::ChangeWeights </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Use a combination of scaling and reparameterization to set two rational Bezier weights to specified values. Parameters: i0 - [in] control point index (0 &lt;= i0 &lt; order, i0 != i1) w0 - [in] Desired weight for i0-th control point i1 - [in] control point index (0 &lt;= i1 &lt; order, i0 != i1) w1 - [in] Desired weight for i1-th control point Returns: True if successful. The returned bezier has the same locus but probably has a different parameterization. Remarks: The i0-th cv will have weight w0 and the i1-rst cv will have weight w1. If v0 and v1 are the cv's input weights, then v0, v1, w0 and w1 must all be nonzero, and w0*v0 and w1*v1 must have the same sign.</p>
<p>The equations </p><pre class="fragment">  s * r^i0 = w0/v0
  s * r^i1 = w1/v1
</pre><p>determine the scaling and reparameterization necessary to change v0,v1 to w0,w1.</p>
<p>If the input Bezier has control vertices </p><pre class="fragment">  (B_0, ..., B_d),
</pre><p>then the output Bezier has control vertices </p><pre class="fragment">  (s*B_0, ... s*r^i * B_i, ..., s*r^d * B_d).
</pre><p> See Also: ON_Bezier::Reparameterize ON_Bezier::ScaleConrolPoints </p>

</div>
</div>
<a id="a491702ee8fae3e2c3d08fd3b43197eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491702ee8fae3e2c3d08fd3b43197eb4">&#9670;&nbsp;</a></span>ControlPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__4d_point.html">ON_4dPoint</a> ON_BezierCurve::ControlPoint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: cv_index - [in] zero based control point index Returns: Control point as an <a class="el" href="class_o_n__4d_point.html">ON_4dPoint</a>. Remarks: If cv_index or the bezier is not valid, then <a class="el" href="class_o_n__4d_point.html#a83f0c10fc5a0eb0d8929a66c5131e150" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_4dPoint::Nan</a> is returned. If dim &lt; 3, unused coordinates are zero. If dim &gt;= 4, the first three coordinates are returned. If is_rat is false, the weight is 1. </p>

</div>
</div>
<a id="acc6d8d148c6110614a6c341b0b9f3607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc6d8d148c6110614a6c341b0b9f3607">&#9670;&nbsp;</a></span>ControlPolygonLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_BezierCurve::ControlPolygonLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: returns the length of the control polygon </p>

</div>
</div>
<a id="a076efeba8280521673d23dea134f169d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a076efeba8280521673d23dea134f169d">&#9670;&nbsp;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIsRational</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Creates a bezier with cv memory allocated. Parameters: dim - [in] (&gt;0) dimension of bezier curve bIsRational - [in] true for a rational bezier order - [in] (&gt;=2) order (=degree+1) of bezier curve Returns: true if successful. </p>

</div>
</div>
<a id="afdae122b6dde5c9da54ca996ced9ff79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdae122b6dde5c9da54ca996ced9ff79">&#9670;&nbsp;</a></span>CrossProduct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::CrossProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: A X V Remarks: A.m_dim must be 3. </p>

</div>
</div>
<a id="a8292eaf36e69f37c1e64785edf9c5f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8292eaf36e69f37c1e64785edf9c5f4c">&#9670;&nbsp;</a></span>CurvatureAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> ON_BezierCurve::CurvatureAt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate the curvature vector at a parameter. Parameters: t - [in] evaluation parameter Returns: curvature vector of the curve at the parameter t. Remarks: No error handling. See Also: <a class="el" href="class_o_n___curve.html#affcb2a2551d248110c8e0dc610e6a9b1">ON_Curve::EvCurvature</a> </p>

</div>
</div>
<a id="adf3ed73e3b7e47c132724ed26d96882f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3ed73e3b7e47c132724ed26d96882f">&#9670;&nbsp;</a></span>CV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* ON_BezierCurve::CV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user function to get a pointer to control vertex memory. If you are not an expert user, please use ON_BezierCurve::GetCV( ON_3dPoint&amp; ) or ON_BezierCurve::GetCV( ON_4dPoint&amp; ). Parameters: cv_index - [in] (0 &lt;= cv_index &lt; m_order) Returns: Pointer to control vertex. Remarks: If the Bezier curve is rational, the format of the returned array is a homogeneos rational point with length m_dim+1. If the Bezier curve is not rational, the format of the returned array is a nonrational euclidean point with length m_dim. See Also <a class="el" href="class_o_n___bezier_curve.html#a59cc73d69a29cd166b04be42c7f15f17">ON_BezierCurve::CVStyle</a> <a class="el" href="class_o_n___bezier_curve.html#a38d647951d5711ca8e832dcbc90c7792">ON_BezierCurve::GetCV</a> <a class="el" href="class_o_n___bezier_curve.html#a677e2628da411e8bb88b2e9215d4c608">ON_BezierCurve::Weight</a> </p>

</div>
</div>
<a id="adefdaed25e9aa0b7fde2c4209d0bdbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefdaed25e9aa0b7fde2c4209d0bdbfd">&#9670;&nbsp;</a></span>CVCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::CVCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Number of control vertices in the bezier. This is always the same as the order of the bezier. </p>

</div>
</div>
<a id="a8826c25a65fd46596c11ed6981e50108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8826c25a65fd46596c11ed6981e50108">&#9670;&nbsp;</a></span>CVSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::CVSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Number of doubles per control vertex. (= <a class="el" href="class_o_n___bezier_curve.html#adc17ead6f3198cc96001ea0bc60852a3">IsRational()</a> ? Dim()+1 : Dim()) </p>

</div>
</div>
<a id="a59cc73d69a29cd166b04be42c7f15f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59cc73d69a29cd166b04be42c7f15f17">&#9670;&nbsp;</a></span>CVStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56">ON::point_style</a> ON_BezierCurve::CVStyle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Returns the style of control vertices in the m_cv array. Returns: @untitled table <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56aa0dd72e122224b91c7b1b4de79fbd129">ON::not_rational</a> m_is_rat is false <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56a64a1b3f7fa363121c1894d0d4507b96b">ON::homogeneous_rational</a> m_is_rat is true </p>

</div>
</div>
<a id="a4fe8d5eaf3cb076a52a2fed82dd88478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fe8d5eaf3cb076a52a2fed82dd88478">&#9670;&nbsp;</a></span>Degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::Degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Degree of the bezier. (degree=order-1) </p>

</div>
</div>
<a id="ac1dde88b76a61f058300ae228eac1101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1dde88b76a61f058300ae228eac1101">&#9670;&nbsp;</a></span>Derivative() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::Derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: First derivative of A. </p>

</div>
</div>
<a id="a6ca27c2fbc80ef2a6a56dc4906a9806c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca27c2fbc80ef2a6a56dc4906a9806c">&#9670;&nbsp;</a></span>Derivative() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_BezierCurve::Derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>derivativeA</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: TL_Derivative( const ON_BezierCurve&amp; Crv, ON_BezierCurve&amp; Cdot) Computes the bezier representing the derivative of Crv . Returns true if the result is the derivative. Details: For non-rational Crv the order of the result is 2*Crv.<a class="el" href="class_o_n___bezier_curve.html#a27f43e091fcf46b0dc62c4ea4d220a34" title="order = degree + 1">Order()</a>-1</p>
<p>Remarks For optimal performance use this version with derivativeA allocated to the proper size, instead of using <a class="el" href="class_o_n___bezier_curve.html#ac1dde88b76a61f058300ae228eac1101">ON_BezierCurve::Derivative</a>. <br  />
 This will avoid allocating and copying of temporary objects. Parameters: A - [in] A.Order() must be &gt;= 2.</p>
<p>derivativeA - [out] For a non-rational A with degree &gt; 1, the result is non-rational of degree A.Degree()-1. For non-rational A with degree 1, the result is degree 1. For rational A, the degee of derivativeA is 2*A.<a class="el" href="class_o_n___bezier_curve.html#a4fe8d5eaf3cb076a52a2fed82dd88478">Degree()</a> (quotient rule). Returns: <br  />
 True if A is valid and derivative is returned </p>

</div>
</div>
<a id="ad2ff88ca1a4e42f05b4ed32411f206a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ff88ca1a4e42f05b4ed32411f206a0">&#9670;&nbsp;</a></span>DerivativeAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> ON_BezierCurve::DerivativeAt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate first derivative at a parameter. Parameters: t - [in] evaluation parameter Returns: First derivative of the curve at the parameter t. Remarks: No error handling. See Also: <a class="el" href="class_o_n___curve.html#a37944a7a4d1c3d7e28afcbc9184ef799">ON_Curve::Ev1Der</a> </p>

</div>
</div>
<a id="a585a866af061203c5b2d46ee2b9aa2a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585a866af061203c5b2d46ee2b9aa2a7">&#9670;&nbsp;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_BezierCurve::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Deallocates m_cv memory. </p>

</div>
</div>
<a id="a6b0dcef0e68a44f5b0d7e8c67022a7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0dcef0e68a44f5b0d7e8c67022a7fe">&#9670;&nbsp;</a></span>Dimension()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::Dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Dimension of bezier. </p>

</div>
</div>
<a id="a1b41eb9a733ebc52e59fe11a62bd0104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b41eb9a733ebc52e59fe11a62bd0104">&#9670;&nbsp;</a></span>Domain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___interval.html">ON_Interval</a> ON_BezierCurve::Domain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Domain of bezier (always [0,1]). </p>

</div>
</div>
<a id="a11239f9518dd606e47703c182a1a318f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11239f9518dd606e47703c182a1a318f">&#9670;&nbsp;</a></span>DotProduct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::DotProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: A o B (scalar dot product) Remarks: A.m_dim and B's dimension must be equal </p>

</div>
</div>
<a id="ae2a5f493f9df99b217fc4117111b1e7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a5f493f9df99b217fc4117111b1e7d">&#9670;&nbsp;</a></span>DotProduct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::DotProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: A o B (scalar dot product) Remarks: A.m_dim and B.m_dim must be qeual </p>

</div>
</div>
<a id="a52f595aabb9466b10ee3eb1a2f1789be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f595aabb9466b10ee3eb1a2f1789be">&#9670;&nbsp;</a></span>DotProduct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::DotProduct </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: A o B (scalar dot product) Remarks: A.m_dim must be 3. </p>

</div>
</div>
<a id="afbc9591499cfe8a045cbd2a09486592f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbc9591499cfe8a045cbd2a09486592f">&#9670;&nbsp;</a></span>Dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_BezierCurve::Dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>for debugging </p>

</div>
</div>
<a id="a28db34743881ef2377284a0356388aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28db34743881ef2377284a0356388aa9">&#9670;&nbsp;</a></span>EmergencyDestroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_BezierCurve::EmergencyDestroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call if memory used by <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> becomes invalid </p>

</div>
</div>
<a id="a3ba587a0b21ef9581bc5c003cc57553f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba587a0b21ef9581bc5c003cc57553f">&#9670;&nbsp;</a></span>Ev1Der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Ev1Der </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>first_derivative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate first derivative at a parameter with error checking. Parameters: t - [in] evaluation parameter point - [out] value of curve at t first_derivative - [out] value of first derivative at t Returns: false if unable to evaluate. </p>

</div>
</div>
<a id="a0fc29c51047bc606a8afce9f530ff8e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc29c51047bc606a8afce9f530ff8e7">&#9670;&nbsp;</a></span>Ev2Der()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Ev2Der </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>first_derivative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>second_derivative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate second derivative at a parameter with error checking. Parameters: t - [in] evaluation parameter point - [out] value of curve at t first_derivative - [out] value of first derivative at t second_derivative - [out] value of second derivative at t Returns: false if unable to evaluate. </p>

</div>
</div>
<a id="a506fe2ae579c1bb2dfb7ee9fdac96eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a506fe2ae579c1bb2dfb7ee9fdac96eae">&#9670;&nbsp;</a></span>Evaluate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Evaluate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>der_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate a bezier. Parameters: t - [in] evaluation parameter (usually 0 &lt;= t &lt;= 1) der_count - [in] (&gt;=0) number of derivatives to evaluate v_stride - [in] (&gt;=m_dim) stride to use for the v[] array v - [out] array of length (der_count+1)*v_stride bez(t) is returned in (v[0],...,v[m_dim-1]), bez'(t) is retuned in (v[v_stride],...,v[v_stride+m_dim-1]), bez"(t) is retuned in (v[2*v_stride],...,v[2*v_stride+m_dim-1]), etc. Returns: true if successful </p>

</div>
</div>
<a id="ae1704492fbab1935dc514e07e62e7bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1704492fbab1935dc514e07e62e7bf3">&#9670;&nbsp;</a></span>EvCurvature()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::EvCurvature </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>tangent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>kappa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate unit tangent and curvature at a parameter with error checking. Parameters: t - [in] evaluation parameter point - [out] value of curve at t tangent - [out] value of unit tangent kappa - [out] value of curvature vector Returns: false if unable to evaluate. </p>

</div>
</div>
<a id="a7f9c7141aba78552ad63ba19189dc7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f9c7141aba78552ad63ba19189dc7e8">&#9670;&nbsp;</a></span>EvPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::EvPoint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate point at a parameter with error checking. Parameters: t - [in] evaluation parameter point - [out] value of curve at t Returns: false if unable to evaluate. </p>

</div>
</div>
<a id="a6b6efa0d2e9ef8812701bd6cefdaf880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b6efa0d2e9ef8812701bd6cefdaf880">&#9670;&nbsp;</a></span>EvTangent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::EvTangent </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>tangent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate unit tangent at a parameter with error checking. Parameters: t - [in] evaluation parameter point - [out] value of curve at t tangent - [out] value of unit tangent Returns: false if unable to evaluate. See Also: <a class="el" href="class_o_n___curve.html#a8de2247b5bb20d1b67d40c274c17697a">ON_Curve::TangentAt</a> <a class="el" href="class_o_n___curve.html#a37944a7a4d1c3d7e28afcbc9184ef799">ON_Curve::Ev1Der</a> </p>

</div>
</div>
<a id="a840b8758b0cc94bb8d98f48251405525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840b8758b0cc94bb8d98f48251405525">&#9670;&nbsp;</a></span>FindRoots()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::FindRoots </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tol</em> = <code><a class="el" href="group__open_n_u_r_b_s.html#ga384d9713cff6f46d203437be118aab80">ON_ZERO_TOLERANCE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Find all the zeros of the first coordinate of a bezier in the domain [0,1]. <br  />
 Roots are reported only once regardless of multiplicity. Parameters root [out] An array of degree many doubles. Roots are returned here in increasing order tol [in] tolerance &gt;0 used for detecting roots of even multiplicity</p>
<p>Details: All roots are computed to full machine precision. <br  />
 As an example of how tol is used (x-.123)^2 + tol/2 will have a root at .123 where as (x-.123)^2 + 2*tol has no roots</p>
<p>Returns: Number of roots found. </p>

</div>
</div>
<a id="a8889fb447e769a16294957388951aa32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8889fb447e769a16294957388951aa32">&#9670;&nbsp;</a></span>GetBBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetBBox </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>box_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>box_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGrowBox</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Gets bounding box. Parameters: box_min - [out] minimum corner of axis aligned bounding box The box_min[] array must have size m_dim. box_max - [out] maximum corner of axis aligned bounding box The box_max[] array must have size m_dim. bGrowBox - [in] if true, input box_min/box_max must be set to valid bounding box corners and this box is enlarged to be the union of the input box and the bezier's bounding box. Returns: true if successful. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">box_min</td><td>returns true if successful </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7333494a5d1069a9a413617449c273b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7333494a5d1069a9a413617449c273b3">&#9670;&nbsp;</a></span>GetBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bGrowBox</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Gets bounding box. Parameters: bbox - [out] axis aligned bounding box returned here. bGrowBox - [in] if true, input bbox must be a valid bounding box and this box is enlarged to be the union of the input box and the bezier's bounding box. Returns: true if successful. </p>

</div>
</div>
<a id="a0e9cce40566d77c208e181a20aaf1589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9cce40566d77c208e181a20aaf1589">&#9670;&nbsp;</a></span>GetClosestPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetClosestPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maximum_distance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>sub_domain</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the parameter of the point on the bezier curve that is closest to the point P. Parameters: P - [in] t - [out] Closest point parameter. maximum_distance - [in] If maximum_distance &gt; 0.0, then an answer is returned only if the distance from the bezier curve to P is &lt;= maximum_distance. If maximum_distance &lt;= 0.0, then maximum_distance is ignored. sub_domain - [in] If not nullptr, the search is confined to the intersection of the sub_domain interval and (0,1). Returns: True if a point is found. See Also: <a class="el" href="class_o_n___curve_tree_node.html#a966eefdfdd5d849caf48915c8effb4ce">ON_CurveTreeNode::GetClosestPoint</a> Remarks: This function is not efficient if you will be finding multiple closest points to the same bezier. To efficiently find multiple closest points, make a curve tree and use it. See the <a class="el" href="class_o_n___bezier_curve.html#a0e9cce40566d77c208e181a20aaf1589">ON_BezierCurve::GetClosestPoint</a> code for an example. </p>

</div>
</div>
<a id="a38d647951d5711ca8e832dcbc90c7792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d647951d5711ca8e832dcbc90c7792">&#9670;&nbsp;</a></span>GetCV() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetCV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56">ON::point_style</a>&#160;</td>
          <td class="paramname"><em>pointstyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get location of a control vertex. Parameters: cv_index - [in] control vertex index (0 &lt;= cv_index &lt; m_order) pointstyle - [in] specifes what kind of values to get <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56aa0dd72e122224b91c7b1b4de79fbd129">ON::not_rational</a> cv[] is an array of length m_dim that defines a euclidean (world coordinate) point <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56a64a1b3f7fa363121c1894d0d4507b96b">ON::homogeneous_rational</a> cv[] is an array of length (m_dim+1) that defines a rational homogeneous point. <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56abcf7e52d75658b5fd7644ad8c269087a">ON::euclidean_rational</a> cv[] is an array of length (m_dim+1). The first m_dim values define the euclidean (world coordinate) location of the point. cv[m_dim] is the weight <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56af4d8e7d79dc7ce69f39636714b52900f" title="point format used in definition">ON::intrinsic_point_style</a> If m_is_rat is true, cv[] has <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56a64a1b3f7fa363121c1894d0d4507b96b">ON::homogeneous_rational</a> point style. If m_is_rat is false, cv[] has <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56aa0dd72e122224b91c7b1b4de79fbd129">ON::not_rational</a> point style. cv - [out] array with control vertex value. Returns: true if successful. false if cv_index is invalid. </p>

</div>
</div>
<a id="a274cb0b63da5ab4da7bd136806034242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274cb0b63da5ab4da7bd136806034242">&#9670;&nbsp;</a></span>GetCV() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetCV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get location of a control vertex. Parameters: cv_index - [in] control vertex index (0 &lt;= cv_index &lt; m_order) point - [out] Location of control vertex. If the bezier is rational, the euclidean location is returned. Returns: true if successful. </p>

</div>
</div>
<a id="aaa75b2a645c3506e88892e1a745a701e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa75b2a645c3506e88892e1a745a701e">&#9670;&nbsp;</a></span>GetCV() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetCV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__4d_point.html">ON_4dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get value of a control vertex. Parameters: cv_index - [in] control vertex index (0 &lt;= cv_index &lt; m_order) point - [out] Homogenous value of control vertex. If the bezier is not rational, the weight is 1. Returns: true if successful. </p>

</div>
</div>
<a id="a70751fdcb7c69b6d7c3a214f6403ef75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70751fdcb7c69b6d7c3a214f6403ef75">&#9670;&nbsp;</a></span>GetLocalClosestPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetLocalClosestPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seed_parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>sub_domain</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the parameter of the point on the bezier curve that is locally closest to the point P when the search begins at seed_parameter. Parameters: P - [in] seed_parameter - [in] Parameter where the search begins. t - [out] Closest point parameter. sub_domain - [in] If not nullptr, the search is confined to the intersection of the sub_domain interval and (0,1). Returns: True if a point is found. </p>

</div>
</div>
<a id="ab3e15aebdb8695206e16854932022913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e15aebdb8695206e16854932022913">&#9670;&nbsp;</a></span>GetLocalCurveIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetLocalCurveIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> *&#160;</td>
          <td class="paramname"><em>other_bezcrv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>this_seed_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>other_seed_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>this_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>other_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>this_domain</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>other_domain</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a local curve-curve intersection point. Parameters: other_bezcrv - [in] other curve this_seed_t - [in] this curve seed paramter other_seed_t - [in] other curve seed paramter this_t - [out] this curve paramter other_t - [out] other curve paramter this_domain - [in] optional this curve domain restriction other_domain - [in] optional other curve domain restriction Returns: True if something is returned in (t,u,v). Check answer. </p>

</div>
</div>
<a id="ae2bd6489f53780116c5cb0ed4c58620e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bd6489f53780116c5cb0ed4c58620e">&#9670;&nbsp;</a></span>GetLocalSurfaceIntersection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetLocalSurfaceIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_surface.html">ON_BezierSurface</a> *&#160;</td>
          <td class="paramname"><em>bezsrf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seed_t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seed_u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>seed_v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>tdomain</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>udomain</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>vdomain</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a local curve-surface intersection point. Parameters: bezsrf - [in] seed_t - [in] curve paramter seed_u - [in] surface parameter seed_v - [in] surface parameter t - [out] curve paramter u - [out] surface parameter v - [out] surface parameter tdomain - [in] optional curve domain restriction udomain - [in] optional surface domain restriction vdomain - [in] optional surface domain restriction Returns: True if something is returned in (t,u,v). Check answer. </p>

</div>
</div>
<a id="ae96dc2bc03c72815c7453f9b2d3e1cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96dc2bc03c72815c7453f9b2d3e1cda">&#9670;&nbsp;</a></span>GetNurbForm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::GetNurbForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>nurbs_curve</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> form of a bezier. Parameters: nurbs_curve - [out] NURBS curve form of a bezier. The domain is [0,1]. Returns: 0 = failure 1 = success </p>

</div>
</div>
<a id="a3854ed0083cd4ef0eb0e0662a913bf23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3854ed0083cd4ef0eb0e0662a913bf23">&#9670;&nbsp;</a></span>GetTightBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::GetTightBoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>tight_bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGrowBox</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___xform.html">ON_Xform</a> *&#160;</td>
          <td class="paramname"><em>xform</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get tight bounding box of the bezier. Parameters: tight_bbox - [in/out] tight bounding box bGrowBox -[in] (default=false) <br  />
 If true and the input tight_bbox is valid, then returned tight_bbox is the union of the input tight_bbox and the tight bounding box of the bezier curve. xform -[in] (default=nullptr) If not nullptr, the tight bounding box of the transformed bezier is calculated. The bezier curve is not modified. Returns: True if the returned tight_bbox is set to a valid bounding box. </p>

</div>
</div>
<a id="a5e8e7efcb8ed6663bba389cd9edf7b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8e7efcb8ed6663bba389cd9edf7b89">&#9670;&nbsp;</a></span>IncreaseDegree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::IncreaseDegree </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>desired_degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Increase degree of bezier. Parameters: desired_degree - [in] Returns: true if successful. false if desired_degree &lt; current degree. </p>

</div>
</div>
<a id="a4a1f70124b4036fe8f3f18b31101ad46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1f70124b4036fe8f3f18b31101ad46">&#9670;&nbsp;</a></span>IntersectCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::IntersectCurve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> *&#160;</td>
          <td class="paramname"><em>bezierB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___x___e_v_e_n_t.html">ON_X_EVENT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>intersection_tolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>overlap_tolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>bezierA_domain</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>bezierB_domain</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Intersect this bezier with bezierB. Parameters: curveB - [in] x - [out] Intersection events are appended to this array. intersection_tolerance - [in] If the distance from a point on this curve to curveB is &lt;= intersection tolerance, then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0, then 0.001 is used. overlap_tolerance - [in] If t1 and t2 are parameters of this curve's intersection events and the distance from curve(t) to curveB is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used. curveA_domain - [in] optional restriction on this bezier's domain curveB_domain - [in] optional restriction on bezierB domain Returns: Number of intersection events appended to x. Remarks: If you are performing more than one intersection, you should create curve trees and intersect them. See the IntersectBezierCurve code for an example. </p>

</div>
</div>
<a id="a8c5a8b60d31d0dc173abca58ec73609d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5a8b60d31d0dc173abca58ec73609d">&#9670;&nbsp;</a></span>IntersectSelf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::IntersectSelf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___x___e_v_e_n_t.html">ON_X_EVENT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>intersection_tolerance</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Find bezier self intersection points. Parameters: x - [out] Intersection events are appended to this array. intersection_tolerance - [in] Returns: Number of intersection events appended to x. </p>

</div>
</div>
<a id="a914fd841d7452a9b15d6f35bbb697cab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a914fd841d7452a9b15d6f35bbb697cab">&#9670;&nbsp;</a></span>IntersectSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::IntersectSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_surface.html">ON_BezierSurface</a> *&#160;</td>
          <td class="paramname"><em>bezsrfB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___x___e_v_e_n_t.html">ON_X_EVENT</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>intersection_tolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>overlap_tolerance</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>bezierA_domain</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>bezsrfB_udomain</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> *&#160;</td>
          <td class="paramname"><em>bezsrfB_vdomain</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Intersect this bezier curve with bezsrfB. Parameters: bezsrfB - [in] x - [out] Intersection events are appended to this array. intersection_tolerance - [in] If the distance from a point on this curve to the surface is &lt;= intersection tolerance, then the point will be part of an intersection event. If the input intersection_tolerance &lt;= 0.0, then 0.001 is used. overlap_tolerance - [in] If t1 and t2 are curve parameters of intersection events and the distance from curve(t) to the surface is &lt;= overlap_tolerance for every t1 &lt;= t &lt;= t2, then the event will be returened as an overlap event. If the input overlap_tolerance &lt;= 0.0, then intersection_tolerance*2.0 is used. curveA_domain - [in] optional restriction on this curve's domain surfaceB_udomain - [in] optional restriction on surfaceB u domain surfaceB_vdomain - [in] optional restriction on surfaceB v domain Returns: Number of intersection events appended to x. Remarks: If you are performing more than one intersection, you should create curve and surface trees and intersect them. See the IntersectBezierSurface code for an example. </p>

</div>
</div>
<a id="adc17ead6f3198cc96001ea0bc60852a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc17ead6f3198cc96001ea0bc60852a3">&#9670;&nbsp;</a></span>IsRational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::IsRational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: true if bezier is rational. </p>

</div>
</div>
<a id="ae3816923c2564c61fc7a5822c2523dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3816923c2564c61fc7a5822c2523dee">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a60a786c2cf254f997a0a701b16db79da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60a786c2cf254f997a0a701b16db79da">&#9670;&nbsp;</a></span>Loft() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Loft </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a> &amp;&#160;</td>
          <td class="paramname"><em>points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Loft a bezier curve through a list of points. Parameters: points - [in] an array of 2 or more points to interpolate Returns: true if successful Remarks: The result has order = points.Count() and the loft uses the uniform parameterizaton curve( i/(points.Count()-1) ) = points[i]. </p>

</div>
</div>
<a id="ac6f952cc483b85fd093b7ff31d35db52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6f952cc483b85fd093b7ff31d35db52">&#9670;&nbsp;</a></span>Loft() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Loft </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pt_dim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pt_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pt_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>pt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>t_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Loft a bezier curve through a list of points. Parameters: pt_dim - [in] dimension of points to interpolate pt_count - [in] number of points (&gt;=2) pt_stride - [in] (&gt;=pt_dim) pt[] array stride pt - [in] array of points t_stride - [in] (&gt;=1) t[] array stride t - [in] strictly increasing array of interpolation parameters Returns: true if successful Remarks: The result has order = points.Count() and the loft uses the parameterizaton curve( t[i] ) = points[i]. </p>

</div>
</div>
<a id="a10eaf62c02829172277d53885848251b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10eaf62c02829172277d53885848251b">&#9670;&nbsp;</a></span>MakeNonRational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::MakeNonRational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Make beizer not rational by setting all control vertices to their euclidean locations and setting m_is_rat to false. See Also: ON_Bezier::MakeRational </p>

</div>
</div>
<a id="a1511bd913d07d30640d4e2c9819e78c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1511bd913d07d30640d4e2c9819e78c0">&#9670;&nbsp;</a></span>MakeRational()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::MakeRational </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Make beizer rational. Returns: true if successful. See Also: ON_Bezier::MakeNonRational </p>

</div>
</div>
<a id="a871b55fa52eb8954120d1b101d98b630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871b55fa52eb8954120d1b101d98b630">&#9670;&nbsp;</a></span>Morph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Morph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___space_morph.html">ON_SpaceMorph</a> &amp;&#160;</td>
          <td class="paramname"><em>morph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e349ce0fe37226959a2d4ab641cb151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e349ce0fe37226959a2d4ab641cb151">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: this * B (scalar multiplication) </p>

</div>
</div>
<a id="a3afb4ddf270f60cb42dbd43224ddd5c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3afb4ddf270f60cb42dbd43224ddd5c4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::operator* </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: a * this </p>

</div>
</div>
<a id="a446cbce10b8c531f6396f4243fa3e614"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446cbce10b8c531f6396f4243fa3e614">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::operator+ </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: v - [in] A vector with dimension = m_dim. Returns: this + v Remarks: Ignores coordinates after the first three. </p>

</div>
</div>
<a id="a03d723881e841dcf33522f4cedb4d8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d723881e841dcf33522f4cedb4d8f9">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: v - [in] A vector with dimension = m_dim. Returns: this + B Remarks: m_dim and B.m_dim must be equal. </p>

</div>
</div>
<a id="a3ce879e42b40ade4e777f401abe452c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce879e42b40ade4e777f401abe452c2">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::operator+ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Arithmetic operations. </p>
<p>Returns: this + v Remarks: Ignores coordinates after the first three. </p>

</div>
</div>
<a id="a63cb53a04cd5129adeda1df9eb2a54c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63cb53a04cd5129adeda1df9eb2a54c2">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::operator- </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: v - [in] A vector with dimension = m_dim. Returns: this - v Remarks: Ignores coordinates after the first three. </p>

</div>
</div>
<a id="a07db1ce42b2823f4f3dc661172f90bf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07db1ce42b2823f4f3dc661172f90bf1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>crv</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: v - [in] A vector with dimension = m_dim. Returns: this - crv Remarks: this and crv must have the same dimension. </p>

</div>
</div>
<a id="abc495e256105f4b2454ce218801e911e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc495e256105f4b2454ce218801e911e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> ON_BezierCurve::operator- </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: this - v Remarks: Ignores coordinates after the first three. </p>

</div>
</div>
<a id="a9ba606a6656f6cac42e14eecfeef7f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba606a6656f6cac42e14eecfeef7f15">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&amp; ON_BezierCurve::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n__2d_point_array.html">ON_2dPointArray</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets control points </p>

</div>
</div>
<a id="a9665af5e5a20c5d385b93ee529097ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9665af5e5a20c5d385b93ee529097ad5">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&amp; ON_BezierCurve::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_point_array.html">ON_3dPointArray</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets control points </p>

</div>
</div>
<a id="aa41ab797eef67cc94e41b1bfd1951af9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa41ab797eef67cc94e41b1bfd1951af9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&amp; ON_BezierCurve::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n__4d_point_array.html">ON_4dPointArray</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>sets control points </p>

</div>
</div>
<a id="a656285f922e3291ad4d13833fffbba64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a656285f922e3291ad4d13833fffbba64">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&amp; ON_BezierCurve::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a191ee9a7d327ed8d20e90e9bc178398f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191ee9a7d327ed8d20e90e9bc178398f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a>&amp; ON_BezierCurve::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___polynomial_curve.html">ON_PolynomialCurve</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27f43e091fcf46b0dc62c4ea4d220a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27f43e091fcf46b0dc62c4ea4d220a34">&#9670;&nbsp;</a></span>Order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::Order </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>order = degree + 1 </p>
<p>Returns: Order of the bezier. (order=degree+1) </p>

</div>
</div>
<a id="abb6c84f8927d05e34f809f62e36c9311"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6c84f8927d05e34f809f62e36c9311">&#9670;&nbsp;</a></span>PointAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_BezierCurve::PointAt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate point at a parameter. Parameters: t - [in] evaluation parameter Returns: Point (location of curve at the parameter t). </p>

</div>
</div>
<a id="a794bf1683770bb767ef4d95a835ab926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794bf1683770bb767ef4d95a835ab926">&#9670;&nbsp;</a></span>Reparameterize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Reparameterize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Use a linear fractional tranformation for [0,1] to reparameterize the bezier. The locus of the curve is not changed, but the parameterization is changed. Parameters: c - [in] reparameterization constant (generally speaking, c should be &gt; 0). If c != 1, then the returned bezier will be rational. Returns: true if successful. Remarks: The reparameterization is performed by composing the input Bezier with the function lambda: [0,1] -&gt; [0,1] given by </p><pre class="fragment">  t -&gt;  c*t / ( (c-1)*t + 1 )
</pre><p>Note that lambda(0) = 0, lambda(1) = 1, lambda'(t) &gt; 0, lambda'(0) = c and lambda'(1) = 1/c.</p>
<p>If the input Bezier has control vertices {B_0, ..., B_d}, then the output Bezier has control vertices </p><pre class="fragment">  (B_0, ... c^i * B_i, ..., c^d * B_d).
</pre><p>To derive this formula, simply compute the i-th Bernstein polynomial composed with lambda().</p>
<p>The inverse parameterization is given by 1/c. That is, the cumulative effect of the two calls </p><pre class="fragment">  Reparameterize(c)
  Reparameterize(1.0/c)
</pre><p>is to leave the bezier unchanged. See Also: ON_Bezier::ScaleConrolPoints </p>

</div>
</div>
<a id="a3f9677861f670b922db042e8494802e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9677861f670b922db042e8494802e4">&#9670;&nbsp;</a></span>Reparametrize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Reparametrize </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>misspelled function name is obsolete </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000014">Deprecated:</a></b></dt><dd>misspelled - use Reparameterize </dd></dl>

</div>
</div>
<a id="a8c6f6b3b63e96c718ca94748308a8b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6f6b3b63e96c718ca94748308a8b42">&#9670;&nbsp;</a></span>ReserveCVCapacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::ReserveCVCapacity </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>desired_cv_capacity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tools for managing CV and knot memory. </p>
<p>Description: Make sure m_cv array has a certain length. Parameters: desired_cv_capacity - [in] minimum length of m_cv array. Returns: true if successful. </p>

</div>
</div>
<a id="a1a045711ab41e5fa4136f32bdd2ce7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a045711ab41e5fa4136f32bdd2ce7f1">&#9670;&nbsp;</a></span>Reverse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Reverse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Reverses bezier by reversing the order of the control points. </p>

</div>
</div>
<a id="a55e645d31770aa341c818a79fb2e3736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55e645d31770aa341c818a79fb2e3736">&#9670;&nbsp;</a></span>Rotate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Rotate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rotation_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation_center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Rotates the bezier curve about the specified axis. A positive rotation angle results in a counter-clockwise rotation about the axis (right hand rule). Parameters: rotation_angle - [in] angle of rotation in radians rotation_axis - [in] direction of the axis of rotation rotation_center - [in] point on the axis of rotation Returns: true if bezier curve successfully rotated Remarks: Uses <a class="el" href="class_o_n___bezier_curve.html#a303c5e51344dd2375c44661e415f460f">ON_BezierCurve::Transform()</a> function to calculate the result. </p>

</div>
</div>
<a id="a4811cd3bd1387c344a4f47275f7082c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4811cd3bd1387c344a4f47275f7082c7">&#9670;&nbsp;</a></span>Rotate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Rotate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sin_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cos_angle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>rotation_center</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Rotates the bezier curve about the specified axis. A positive rotation angle results in a counter-clockwise rotation about the axis (right hand rule). Parameters: sin_angle - [in] sine of rotation angle cos_angle - [in] sine of rotation angle rotation_axis - [in] direction of the axis of rotation rotation_center - [in] point on the axis of rotation Returns: true if bezier curve successfully rotated Remarks: Uses <a class="el" href="class_o_n___bezier_curve.html#a303c5e51344dd2375c44661e415f460f">ON_BezierCurve::Transform()</a> function to calculate the result. </p>

</div>
</div>
<a id="ab498533a619bae4a28d9bfc9222a6798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab498533a619bae4a28d9bfc9222a6798">&#9670;&nbsp;</a></span>Scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Scale </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale_factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Scales the bezier curve by the specified facotor. The scale is centered at the origin. Parameters: scale_factor - [in] scale factor Returns: true if bezier curve successfully scaled Remarks: Uses <a class="el" href="class_o_n___bezier_curve.html#a303c5e51344dd2375c44661e415f460f">ON_BezierCurve::Transform()</a> function to calculate the result. </p>

</div>
</div>
<a id="af01d2f24a8ff758e8289b3498fe0b47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01d2f24a8ff758e8289b3498fe0b47a">&#9670;&nbsp;</a></span>ScaleConrolPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::ScaleConrolPoints </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Scale a rational Bezier's control vertices to set a weight to a specified value. Parameters: i - [in] (0 &lt;= i &lt; order) w - [in] w != 0.0 Returns: True if successful. The i-th control vertex will have weight w. Remarks: Each control point is multiplied by w/w0, where w0 is the input value of Weight(i). See Also: ON_Bezier::Reparameterize ON_Bezier::ChangeWeights </p>

</div>
</div>
<a id="a418584ac8f35633553c0e0faeb57cc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418584ac8f35633553c0e0faeb57cc04">&#9670;&nbsp;</a></span>SetCV() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::SetCV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set location of a control vertex. Parameters: cv_index - [in] control vertex index (0 &lt;= cv_index &lt; m_order) point - [in] control vertex location. If the bezier is rational, the weight will be set to 1. Returns: true if successful. See Also: <a class="el" href="class_o_n___bezier_curve.html#adf3ed73e3b7e47c132724ed26d96882f">ON_BezierCurve::CV</a>, <a class="el" href="class_o_n___bezier_curve.html#a37e7f759538be4bb476e4b24a76a216d">ON_BezierCurve::SetCV</a>, <a class="el" href="class_o_n___bezier_curve.html#a63b12855581ab2fa7fccaddb605207fe">ON_BezierCurve::SetWeight</a>, <a class="el" href="class_o_n___bezier_curve.html#a677e2628da411e8bb88b2e9215d4c608">ON_BezierCurve::Weight</a> </p>

</div>
</div>
<a id="a9d84efc04b801b0d5c3c87368d42f64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d84efc04b801b0d5c3c87368d42f64f">&#9670;&nbsp;</a></span>SetCV() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::SetCV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n__4d_point.html">ON_4dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set value of a control vertex. Parameters: cv_index - [in] control vertex index (0 &lt;= cv_index &lt; m_order) point - [in] control vertex value. If the bezier is not rational, the euclidean location of homogenoeous point will be used. Returns: true if successful. See Also: <a class="el" href="class_o_n___bezier_curve.html#adf3ed73e3b7e47c132724ed26d96882f">ON_BezierCurve::CV</a>, <a class="el" href="class_o_n___bezier_curve.html#a37e7f759538be4bb476e4b24a76a216d">ON_BezierCurve::SetCV</a>, <a class="el" href="class_o_n___bezier_curve.html#a63b12855581ab2fa7fccaddb605207fe">ON_BezierCurve::SetWeight</a>, <a class="el" href="class_o_n___bezier_curve.html#a677e2628da411e8bb88b2e9215d4c608">ON_BezierCurve::Weight</a> </p>

</div>
</div>
<a id="a37e7f759538be4bb476e4b24a76a216d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e7f759538be4bb476e4b24a76a216d">&#9670;&nbsp;</a></span>SetCV() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::SetCV </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56">ON::point_style</a>&#160;</td>
          <td class="paramname"><em>pointstyle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>cv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set control vertex Parameters: cv_index - [in] control vertex index (0 &lt;= cv_index &lt; m_order) pointstyle - [in] specifes what kind of values are passed in the cv array. <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56aa0dd72e122224b91c7b1b4de79fbd129">ON::not_rational</a> cv[] is an array of length m_dim that defines a euclidean (world coordinate) point <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56a64a1b3f7fa363121c1894d0d4507b96b">ON::homogeneous_rational</a> cv[] is an array of length (m_dim+1) that defines a rational homogeneous point. <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56abcf7e52d75658b5fd7644ad8c269087a">ON::euclidean_rational</a> cv[] is an array of length (m_dim+1). The first m_dim values define the euclidean (world coordinate) location of the point. cv[m_dim] is the weight <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56af4d8e7d79dc7ce69f39636714b52900f" title="point format used in definition">ON::intrinsic_point_style</a> If m_is_rat is true, cv[] has <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56a64a1b3f7fa363121c1894d0d4507b96b">ON::homogeneous_rational</a> point style. If m_is_rat is false, cv[] has <a class="el" href="class_o_n.html#a1af757a677e208531c0cae0d8a4f6a56aa0dd72e122224b91c7b1b4de79fbd129">ON::not_rational</a> point style. cv - [in] array with control vertex value. Returns: true if the point can be set. </p>

</div>
</div>
<a id="a63b12855581ab2fa7fccaddb605207fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b12855581ab2fa7fccaddb605207fe">&#9670;&nbsp;</a></span>SetWeight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::SetWeight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set weight of a control vertex. Parameters: cv_index - [in] control vertex index (0 &lt;= cv_index &lt; m_order) weight - [in] weight Returns: true if the weight can be set. If weight is not 1 and the bezier is not rational, then false is returned. Use <a class="el" href="class_o_n___bezier_curve.html#a1511bd913d07d30640d4e2c9819e78c0">ON_BezierCurve::MakeRational</a> to make a bezier curve rational. See Also: <a class="el" href="class_o_n___bezier_curve.html#a37e7f759538be4bb476e4b24a76a216d">ON_BezierCurve::SetCV</a>, <a class="el" href="class_o_n___bezier_curve.html#a1511bd913d07d30640d4e2c9819e78c0">ON_BezierCurve::MakeRational</a>, <a class="el" href="class_o_n___bezier_curve.html#adc17ead6f3198cc96001ea0bc60852a3">ON_BezierCurve::IsRational</a>, <a class="el" href="class_o_n___bezier_curve.html#a677e2628da411e8bb88b2e9215d4c608">ON_BezierCurve::Weight</a> </p>

</div>
</div>
<a id="a57d6ce22e7838a408cadcdeb24c27093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d6ce22e7838a408cadcdeb24c27093">&#9670;&nbsp;</a></span>Split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Split </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>left_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> &amp;&#160;</td>
          <td class="paramname"><em>right_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: <a class="el" href="class_o_n___bezier_curve.html#a57d6ce22e7838a408cadcdeb24c27093">Split()</a> divides the Bezier curve at the specified parameter. The parameter must satisfy 0 &lt; t &lt; 1. You may pass *this as one of the curves to be returned. Parameters: t - [in] (0 &lt; t &lt; 1 ) parameter to split at left_side - [out] right_side - [out] <br  />
 Example: <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> crv = ...; <a class="el" href="class_o_n___bezier_curve.html">ON_BezierCurve</a> right_side; crv.Split( 0.5, crv, right_side ); would split crv at the 1/2, put the left side in crv, and return the right side in right_side. </p>

</div>
</div>
<a id="a7350035dd2b6e7f8b2d10973095e28fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7350035dd2b6e7f8b2d10973095e28fd">&#9670;&nbsp;</a></span>TangentAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> ON_BezierCurve::TangentAt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluate unit tangent vector at a parameter. Parameters: t - [in] evaluation parameter Returns: Unit tangent vector of the curve at the parameter t. Remarks: No error handling. See Also: <a class="el" href="class_o_n___curve.html#a4e223877e0a89d31e0ed404625db70ef">ON_Curve::EvTangent</a> </p>

</div>
</div>
<a id="a303c5e51344dd2375c44661e415f460f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a303c5e51344dd2375c44661e415f460f">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Transform the bezier. Parameters: xform - [in] transformation to apply to bezier Returns: true if successful. false if bezier is invalid and cannot be transformed. </p>

</div>
</div>
<a id="ab6a239661b33a5d44f200fe75dadb3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a239661b33a5d44f200fe75dadb3b5">&#9670;&nbsp;</a></span>Translate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Translate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;&#160;</td>
          <td class="paramname"><em>translation_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Translates the bezier curve along the specified vector. Parameters: translation_vector - [in] translation vector Returns: true if bezier curve successfully translated Remarks: Uses <a class="el" href="class_o_n___bezier_curve.html#a303c5e51344dd2375c44661e415f460f">ON_BezierCurve::Transform()</a> function to calculate the result. </p>

</div>
</div>
<a id="ac2e29f8c926d7099a1763d52c640b82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e29f8c926d7099a1763d52c640b82a">&#9670;&nbsp;</a></span>Trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::Trim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___interval.html">ON_Interval</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Trims (or extends) the bezier so the bezier so that the result starts bezier(interval[0]) and ends at bezier(interval[1]) (Evaluation performed on input bezier.) Parameters: interval -[in] Example: An interval of [0,1] leaves the bezier unchanged. An interval of [0.5,1] would trim away the left half. An interval of [0.0,2.0] would extend the right end. </p>

</div>
</div>
<a id="a677e2628da411e8bb88b2e9215d4c608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677e2628da411e8bb88b2e9215d4c608">&#9670;&nbsp;</a></span>Weight()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_BezierCurve::Weight </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: cv_index - [in] control vertex index (0&lt;=i&lt;m_order) Returns: Weight of the i-th control vertex. </p>

</div>
</div>
<a id="a79ea11a014c2213a5d99b2d62c29092e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ea11a014c2213a5d99b2d62c29092e">&#9670;&nbsp;</a></span>ZeroCVs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_BezierCurve::ZeroCVs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Zeros control vertices and, if rational, sets weights to 1. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac7232e4c49c237539c487b94d7871d5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7232e4c49c237539c487b94d7871d5a">&#9670;&nbsp;</a></span>m_cv</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double* ON_BezierCurve::m_cv</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The i-th cv begins at cv[i*m_cv_stride]. </p>

</div>
</div>
<a id="aad7b699da1da038e8f397101cd869c9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7b699da1da038e8f397101cd869c9b">&#9670;&nbsp;</a></span>m_cv_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::m_cv_capacity</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of doubles in m_cv array. If m_cv_capacity is zero and m_cv is not nullptr, an expert user is managing the m_cv memory. ~ON_BezierCurve will not deallocate m_cv unless m_cv_capacity is greater than zero. </p>

</div>
</div>
<a id="ab03ddace3cf79ec060a149a698b9a350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03ddace3cf79ec060a149a698b9a350">&#9670;&nbsp;</a></span>m_cv_stride</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::m_cv_stride</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of doubles per cv ( &gt;= ((m_is_rat)?m_dim+1:m_dim) ) </p>

</div>
</div>
<a id="af642d39ca0ace27d454f58c683b65452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af642d39ca0ace27d454f58c683b65452">&#9670;&nbsp;</a></span>m_dim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::m_dim</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation. </p>
<p>NOTE: These members are left "public" so that expert users may efficiently create bezier curves using the default constructor and borrow the knot and CV arrays from their native NURBS representation. No technical support will be provided for users who access these members directly. If you can't get your stuff to work, then use the constructor with the arguments and the SetKnot() and <a class="el" href="class_o_n___bezier_curve.html#a37e7f759538be4bb476e4b24a76a216d">SetCV()</a> functions to fill in the arrays. dimension of bezier (&gt;=1) </p>

</div>
</div>
<a id="a987b8c9b7eeefa9332c4af5d4eb040e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a987b8c9b7eeefa9332c4af5d4eb040e6">&#9670;&nbsp;</a></span>m_is_rat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::m_is_rat</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>1 if bezier is rational, 0 if bezier is not rational </p>

</div>
</div>
<a id="aea3a891b29b89395cbe4282ef984a277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3a891b29b89395cbe4282ef984a277">&#9670;&nbsp;</a></span>m_order</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ON_BezierCurve::m_order</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>order = degree+1 </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Sep 13 2022 16:15:55 for Rhino C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
