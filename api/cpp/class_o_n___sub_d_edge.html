<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_SubDEdge Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API
   &#160;<span id="projectnumber">8.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_o_n___sub_d_edge-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_SubDEdge Class Reference<div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_subd.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ON_SubDEdge:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_n___sub_d_edge.png" usemap="#ON_5FSubDEdge_map" alt=""/>
  <map id="ON_5FSubDEdge_map" name="ON_5FSubDEdge_map">
<area href="class_o_n___sub_d_component_base.html" alt="ON_SubDComponentBase" shape="rect" coords="0,0,160,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4179adeaad9c0b1ae3f973fa5d23dad3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: unsigned int { <a class="el" href="class_o_n___sub_d_edge.html#a4179adeaad9c0b1ae3f973fa5d23dad3ab14a1da83370eeb51e6fec74230b4a74">MaximumFaceCount</a> = 0xFFF0U
 }</td></tr>
<tr class="separator:a4179adeaad9c0b1ae3f973fa5d23dad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aee0de290c463d6ee380921da8a3a1d4a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aee0de290c463d6ee380921da8a3a1d4a">ON_SubDEdge</a> ()=default</td></tr>
<tr class="separator:aee0de290c463d6ee380921da8a3a1d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdeb16e4735817b145d9cb2d666b3561"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#afdeb16e4735817b145d9cb2d666b3561">ON_SubDEdge</a> (const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> &amp;)=default</td></tr>
<tr class="separator:afdeb16e4735817b145d9cb2d666b3561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0431189189a2957cf30c8971235161f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aa0431189189a2957cf30c8971235161f">~ON_SubDEdge</a> ()=default</td></tr>
<tr class="separator:aa0431189189a2957cf30c8971235161f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8447cf57411e921f1292cbbafb00552f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a8447cf57411e921f1292cbbafb00552f">AddFaceToArray</a> (<a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> face_ptr)</td></tr>
<tr class="separator:a8447cf57411e921f1292cbbafb00552f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f8377e6483d96c801eaebf6163ebf2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aa9f8377e6483d96c801eaebf6163ebf2">AdjacentEdge</a> (unsigned int edge_vertex_index, unsigned int i) const</td></tr>
<tr class="separator:aa9f8377e6483d96c801eaebf6163ebf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8d814efc98e216a9a1e97d6c64446b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a2d8d814efc98e216a9a1e97d6c64446b">AdjacentEdgePtr</a> (unsigned int edge_vertex_index, unsigned int i) const</td></tr>
<tr class="separator:a2d8d814efc98e216a9a1e97d6c64446b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7f27e16a7bb967269dd6e471951b79"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#afe7f27e16a7bb967269dd6e471951b79">BoundingBox</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> subd_appearance, const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd) const</td></tr>
<tr class="separator:afe7f27e16a7bb967269dd6e471951b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ebe94ca385db6155685497eddda3d3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___plane.html">ON_Plane</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a44ebe94ca385db6155685497eddda3d3">CenterFrame</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> subd_appearance) const</td></tr>
<tr class="separator:a44ebe94ca385db6155685497eddda3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf1941a3eb36cb4835bda4073d9d1c6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#afaf1941a3eb36cb4835bda4073d9d1c6">CenterNormal</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> subd_appearance, unsigned int edge_face_index) const</td></tr>
<tr class="separator:afaf1941a3eb36cb4835bda4073d9d1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4987949f95233530b4897b381d2ff2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a4e4987949f95233530b4897b381d2ff2">CenterPoint</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> subd_appearance) const</td></tr>
<tr class="separator:a4e4987949f95233530b4897b381d2ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27954fd3351254ed5e23d3d8ba46b50d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a27954fd3351254ed5e23d3d8ba46b50d">ClearSavedSubdivisionPoints</a> () const</td></tr>
<tr class="separator:a27954fd3351254ed5e23d3d8ba46b50d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd716f13fb5df8811a8e6f2f91bda389"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#acd716f13fb5df8811a8e6f2f91bda389">ClearSavedSubdivisionPoints</a> (bool bClearNeighborhood) const</td></tr>
<tr class="separator:acd716f13fb5df8811a8e6f2f91bda389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ad91dd78a3c11b60ee4813308f4e319"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a9ad91dd78a3c11b60ee4813308f4e319">ClearSharpnessForExperts</a> ()</td></tr>
<tr class="memdesc:a9ad91dd78a3c11b60ee4813308f4e319"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tool is for expert users and internal use. Use <a class="el" href="class_o_n___sub_d.html#ae0c2e7c23abeda77ca022d6de68934ca" title="Converts all sharp edges to smooth edges. See ON_SubDEdge::IsSharp() for more information about sharp...">ON_SubD::ClearEdgeSharpness()</a> to remove all sharp edges from a SubD. Sets the edge sharpness to ON_EdgeSharpness::Zero.  <a href="class_o_n___sub_d_edge.html#a9ad91dd78a3c11b60ee4813308f4e319">More...</a><br /></td></tr>
<tr class="separator:a9ad91dd78a3c11b60ee4813308f4e319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3876cc3a94f2146b39ea16493daf1979"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a3876cc3a94f2146b39ea16493daf1979">ComponentIndex</a> () const</td></tr>
<tr class="separator:a3876cc3a94f2146b39ea16493daf1979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6852d9b91c7b5ae1f37d4d635cccc6"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#afc6852d9b91c7b5ae1f37d4d635cccc6">ComponentPtr</a> () const</td></tr>
<tr class="separator:afc6852d9b91c7b5ae1f37d4d635cccc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd3c0e0012d9e07f969a6c7071436e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aabd3c0e0012d9e07f969a6c7071436e5">ControlNetBoundingBox</a> () const</td></tr>
<tr class="separator:aabd3c0e0012d9e07f969a6c7071436e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5746d8f630ad97558d2891fa31b82bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ad5746d8f630ad97558d2891fa31b82bb">ControlNetCenterNormal</a> (unsigned int edge_face_index) const</td></tr>
<tr class="separator:ad5746d8f630ad97558d2891fa31b82bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad496d3ccc3b80eb19708481e1c09be03"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ad496d3ccc3b80eb19708481e1c09be03">ControlNetCenterPoint</a> () const</td></tr>
<tr class="separator:ad496d3ccc3b80eb19708481e1c09be03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e11bc91a0cb4d4779aaff1873a4471"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a30e11bc91a0cb4d4779aaff1873a4471">ControlNetDirection</a> () const</td></tr>
<tr class="separator:a30e11bc91a0cb4d4779aaff1873a4471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04d997c6c38dc894d9dd77ee7f1b5d2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a04d997c6c38dc894d9dd77ee7f1b5d2f">ControlNetDirectionFrom</a> (const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v) const</td></tr>
<tr class="separator:a04d997c6c38dc894d9dd77ee7f1b5d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3155f4b63bad0b5de402bb6151c43bbc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___line.html">ON_Line</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a3155f4b63bad0b5de402bb6151c43bbc">ControlNetLine</a> () const</td></tr>
<tr class="separator:a3155f4b63bad0b5de402bb6151c43bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458b89a882d495ce10a621a1d5f0d135"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a458b89a882d495ce10a621a1d5f0d135">ControlNetPoint</a> (unsigned int i) const</td></tr>
<tr class="separator:a458b89a882d495ce10a621a1d5f0d135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba136d3af02203a246bcbf2ab0bcce39"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aba136d3af02203a246bcbf2ab0bcce39">DartCount</a> () const</td></tr>
<tr class="separator:aba136d3af02203a246bcbf2ab0bcce39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d153a97fe785b87b2982bd875fd37c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#af6d153a97fe785b87b2982bd875fd37c">EdgeAttributes</a> () const</td></tr>
<tr class="separator:af6d153a97fe785b87b2982bd875fd37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3304ffb8bc48d4e196b8ab5f55351d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a4c3304ffb8bc48d4e196b8ab5f55351d">EdgeId</a> () const</td></tr>
<tr class="separator:a4c3304ffb8bc48d4e196b8ab5f55351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df975bb71b54f52db106263443cf123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a3df975bb71b54f52db106263443cf123">EdgeModifiedNofification</a> () const</td></tr>
<tr class="separator:a3df975bb71b54f52db106263443cf123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fe7d824d457425a65252d2acb7df26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a74fe7d824d457425a65252d2acb7df26">EdgeSurfaceCurve</a> (bool bClampEndKnots, <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve) const</td></tr>
<tr class="separator:a74fe7d824d457425a65252d2acb7df26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d6233797f42664d1573ca9e874526d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ad1d6233797f42664d1573ca9e874526d">EdgeSurfaceCurveIsSet</a> () const</td></tr>
<tr class="separator:ad1d6233797f42664d1573ca9e874526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4611bd6e993bf96c9c92acd9de4a2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga6ea2d14874ad3b20bbc8834ffeb8738e">ON_SubDEdgeType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aff4611bd6e993bf96c9c92acd9de4a2b">EdgeType</a> () const</td></tr>
<tr class="memdesc:aff4611bd6e993bf96c9c92acd9de4a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___sub_d_edge.html#aff4611bd6e993bf96c9c92acd9de4a2b" title="EdgeType() is typically used to generate text descriptions and in selection filtering....">EdgeType()</a> is typically used to generate text descriptions and in selection filtering. Do not confuse <a class="el" href="class_o_n___sub_d_edge.html#aff4611bd6e993bf96c9c92acd9de4a2b" title="EdgeType() is typically used to generate text descriptions and in selection filtering....">EdgeType()</a> and EdgeTag().  <a href="class_o_n___sub_d_edge.html#aff4611bd6e993bf96c9c92acd9de4a2b">More...</a><br /></td></tr>
<tr class="separator:aff4611bd6e993bf96c9c92acd9de4a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164177b3e2712c5377261e664993fb14"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a164177b3e2712c5377261e664993fb14">EndSharpness</a> (const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v) const</td></tr>
<tr class="memdesc:a164177b3e2712c5377261e664993fb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge's sharpness at the end with the specified vertex. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges.  <a href="class_o_n___sub_d_edge.html#a164177b3e2712c5377261e664993fb14">More...</a><br /></td></tr>
<tr class="separator:a164177b3e2712c5377261e664993fb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437fc8212b7967bf45bcc93c6e82a18e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a437fc8212b7967bf45bcc93c6e82a18e">EndSharpness</a> (unsigned evi) const</td></tr>
<tr class="memdesc:a437fc8212b7967bf45bcc93c6e82a18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge's sharpness at the end with the specified vertex. If the edge is a crease, <a class="el" href="class_o_n___sub_d_edge_sharpness.html#ac450c47da4dfa105cbb4d22654637da9" title="An edge sharpness with contant value 0.0.">ON_SubDEdgeSharpness::Smooth</a> is returned. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges.  <a href="class_o_n___sub_d_edge.html#a437fc8212b7967bf45bcc93c6e82a18e">More...</a><br /></td></tr>
<tr class="separator:a437fc8212b7967bf45bcc93c6e82a18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53571fd4f09f6a87ee103b1e6b5850fd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a53571fd4f09f6a87ee103b1e6b5850fd">EndSharpness</a> (unsigned evi, bool bUseCreaseSharpness) const</td></tr>
<tr class="memdesc:a53571fd4f09f6a87ee103b1e6b5850fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge's sharpness at the end with the specified vertex. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges.  <a href="class_o_n___sub_d_edge.html#a53571fd4f09f6a87ee103b1e6b5850fd">More...</a><br /></td></tr>
<tr class="separator:a53571fd4f09f6a87ee103b1e6b5850fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa43c7a986a5b849d2b1b94a8e3b29a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aefa43c7a986a5b849d2b1b94a8e3b29a">EvaluateCatmullClarkSubdivisionPoint</a> (double subdivision_point[3]) const</td></tr>
<tr class="separator:aefa43c7a986a5b849d2b1b94a8e3b29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8592d30879261a1160496d215323d2aa"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a8592d30879261a1160496d215323d2aa">Face</a> (unsigned int i) const</td></tr>
<tr class="separator:a8592d30879261a1160496d215323d2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12954b267fa3277a943307107ca60a99"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a12954b267fa3277a943307107ca60a99">FaceArrayIndex</a> (const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *f) const</td></tr>
<tr class="separator:a12954b267fa3277a943307107ca60a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891442a7bf771171857e0d42df559fe3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a891442a7bf771171857e0d42df559fe3">FaceCount</a> () const</td></tr>
<tr class="separator:a891442a7bf771171857e0d42df559fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473fbe9cf0b2d28be3be3cfd3bd19600"><td class="memItemLeft" align="right" valign="top">ON__UINT_PTR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a473fbe9cf0b2d28be3be3cfd3bd19600">FaceDirection</a> (unsigned int i) const</td></tr>
<tr class="separator:a473fbe9cf0b2d28be3be3cfd3bd19600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab01b69c9628c4a789706cb1f0b260cc3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ab01b69c9628c4a789706cb1f0b260cc3">FacePtr</a> (unsigned int i) const</td></tr>
<tr class="separator:ab01b69c9628c4a789706cb1f0b260cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca2724ec87f244161e085f509da10c5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#acca2724ec87f244161e085f509da10c5">FacePtrFromFace</a> (const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *f) const</td></tr>
<tr class="separator:acca2724ec87f244161e085f509da10c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c56b3e8ce2e309c49c89fd221e7924"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a58c56b3e8ce2e309c49c89fd221e7924">GetCenterPointAndNormal</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> subd_appearance, unsigned int edge_face_index, double *P, double *N) const</td></tr>
<tr class="separator:a58c56b3e8ce2e309c49c89fd221e7924"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af755a31081437967b8a968450880087a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#af755a31081437967b8a968450880087a">GetEdgeSurfaceCurveControlPoints</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *cvs, size_t cv_capacity) const</td></tr>
<tr class="separator:af755a31081437967b8a968450880087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afab31b6d7626a2353e28c330eaa56ae0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#afab31b6d7626a2353e28c330eaa56ae0">GetSectorBoundaryEdges</a> (unsigned int edge_vertex_index, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edge_ptr0, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edge_ptr1) const</td></tr>
<tr class="separator:afab31b6d7626a2353e28c330eaa56ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ca3e52bcdbfb9702ad062770e95562"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a73ca3e52bcdbfb9702ad062770e95562">GetSharpSubdivisionPoint</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;sharp_subdivision_point) const</td></tr>
<tr class="memdesc:a73ca3e52bcdbfb9702ad062770e95562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the edge's sharp subdivision point and returns the average of the edge's sharpnesses. The final subdivision point is (sharpness &gt;= 1.0) ? sharp_subdivision_point : (1.0-sharpness)(smooth subdivsion point)+sharpness*sharp_subdivision_point. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges.  <a href="class_o_n___sub_d_edge.html#a73ca3e52bcdbfb9702ad062770e95562">More...</a><br /></td></tr>
<tr class="separator:a73ca3e52bcdbfb9702ad062770e95562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea7baa19f274de7add6e8ee0b35f4a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a7ea7baa19f274de7add6e8ee0b35f4a0">GetSubdivisionPoint</a> (double subdivision_point[3]) const</td></tr>
<tr class="separator:a7ea7baa19f274de7add6e8ee0b35f4a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5bad0053b25b6633812aaed36bcbd3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#acf5bad0053b25b6633812aaed36bcbd3">GetSurfaceCenterPointAndNormal</a> (unsigned int edge_face_index, double *P, double *N) const</td></tr>
<tr class="separator:acf5bad0053b25b6633812aaed36bcbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fb817bd091611587df4d4473036d91"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a37fb817bd091611587df4d4473036d91">GetSurfaceMeshFragmentPoints</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *P, size_t P_capacity) const</td></tr>
<tr class="separator:a37fb817bd091611587df4d4473036d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb304f5fc1e43597c826e7e693e56b21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aeb304f5fc1e43597c826e7e693e56b21">HasBoundaryEdgeTopology</a> () const</td></tr>
<tr class="separator:aeb304f5fc1e43597c826e7e693e56b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d5cf1dfc9012c17e8ca187e4ae29d9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a57d5cf1dfc9012c17e8ca187e4ae29d9">HasInteriorEdgeTopology</a> (bool bRequireOppositeFaceDirections) const</td></tr>
<tr class="separator:a57d5cf1dfc9012c17e8ca187e4ae29d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad581f738f09075c57685627e332a6a15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ad581f738f09075c57685627e332a6a15">IsCrease</a> () const</td></tr>
<tr class="separator:ad581f738f09075c57685627e332a6a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7e8650e9641e43b29478ca97f329bac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#af7e8650e9641e43b29478ca97f329bac">IsCreaseOrSharp</a> () const</td></tr>
<tr class="memdesc:af7e8650e9641e43b29478ca97f329bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crease edges have tag = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>. Sharp edges have tag = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> or <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a> and have nonzero sharpness.  <a href="class_o_n___sub_d_edge.html#af7e8650e9641e43b29478ca97f329bac">More...</a><br /></td></tr>
<tr class="separator:af7e8650e9641e43b29478ca97f329bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e37ee86eb61bbb40bd8e7d9cffd75ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a8e37ee86eb61bbb40bd8e7d9cffd75ab">IsDartCrease</a> () const</td></tr>
<tr class="separator:a8e37ee86eb61bbb40bd8e7d9cffd75ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9c296a2fe8dfceb35a8767675971265"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#af9c296a2fe8dfceb35a8767675971265">IsHardCrease</a> () const</td></tr>
<tr class="separator:af9c296a2fe8dfceb35a8767675971265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e07c79ca0374a1f0d7dea35f79f7e93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93">IsSharp</a> () const</td></tr>
<tr class="memdesc:a8e07c79ca0374a1f0d7dea35f79f7e93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous normal along a sharp edge. A sharp edge has a smooth tag, has sharpness &gt; 0 at at least one end, and has sharpness &lt; <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a17dfa16a846971eee9f0646fc0005919" title="ON_SubDEdgeSharpness::MaximumValue = 4. SubD edge sharpness values are &lt;= ON_SubDEdgeSharpness::Maxim...">ON_SubDEdgeSharpness::MaximumValue</a> at at least one end. Sharpness has no meaning for edges with crease tags. Both sharpness values are zero for an ordinary smooth edge. Edge sharpness steadily decreases during subdivision and becomes zero after at most <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a17dfa16a846971eee9f0646fc0005919" title="ON_SubDEdgeSharpness::MaximumValue = 4. SubD edge sharpness values are &lt;= ON_SubDEdgeSharpness::Maxim...">ON_SubDEdgeSharpness::MaximumValue</a> subdivisions.  <a href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93">More...</a><br /></td></tr>
<tr class="separator:a8e07c79ca0374a1f0d7dea35f79f7e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf1f7d04647417e403311dd4972e07f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aacf1f7d04647417e403311dd4972e07f">IsSmooth</a> () const</td></tr>
<tr class="separator:aacf1f7d04647417e403311dd4972e07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c791230ec5f328b6919b185cf9c2069"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a6c791230ec5f328b6919b185cf9c2069">IsSmoothNotSharp</a> () const</td></tr>
<tr class="memdesc:a6c791230ec5f328b6919b185cf9c2069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if an edge is smooth and is not sharp.  <a href="class_o_n___sub_d_edge.html#a6c791230ec5f328b6919b185cf9c2069">More...</a><br /></td></tr>
<tr class="separator:a6c791230ec5f328b6919b185cf9c2069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb31978402e8b31c96cbaf84913f11a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a1fb31978402e8b31c96cbaf84913f11a">IsSmoothNotX</a> () const</td></tr>
<tr class="separator:a1fb31978402e8b31c96cbaf84913f11a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd244d774f43e3e21912ae4cb748bae5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#abd244d774f43e3e21912ae4cb748bae5">IsSmoothNotXNotSharp</a> () const</td></tr>
<tr class="memdesc:abd244d774f43e3e21912ae4cb748bae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">An expert user function to determine if an edge tag in <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> and is not sharp.  <a href="class_o_n___sub_d_edge.html#abd244d774f43e3e21912ae4cb748bae5">More...</a><br /></td></tr>
<tr class="separator:abd244d774f43e3e21912ae4cb748bae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922333803c8a1716d311167aeeb03bc7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a922333803c8a1716d311167aeeb03bc7">IsSmoothX</a> () const</td></tr>
<tr class="separator:a922333803c8a1716d311167aeeb03bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498de0efe96602adeaa29d67ba5b662f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a498de0efe96602adeaa29d67ba5b662f">MarkedFaceCount</a> () const</td></tr>
<tr class="separator:a498de0efe96602adeaa29d67ba5b662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec914ba987c62679972d5d2d4448f5b4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aec914ba987c62679972d5d2d4448f5b4">MarkedVertexCount</a> () const</td></tr>
<tr class="separator:aec914ba987c62679972d5d2d4448f5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14bd8d63d2866e5c3cd796ebffe8b8d4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a14bd8d63d2866e5c3cd796ebffe8b8d4">NeighborFace</a> (const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, bool bStopAtCrease) const</td></tr>
<tr class="separator:a14bd8d63d2866e5c3cd796ebffe8b8d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03aed478fccb34a0d1b0285e4cb97aa2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a03aed478fccb34a0d1b0285e4cb97aa2">NeighborFacePtr</a> (const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, bool bStopAtCrease) const</td></tr>
<tr class="separator:a03aed478fccb34a0d1b0285e4cb97aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e90a2ee7cac094d2d1376a8c9bb2b3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ac4e90a2ee7cac094d2d1376a8c9bb2b3">NeighborhoodStatusLogicalOr</a> (bool bIncludeVertices, bool bIncludeFaces) const</td></tr>
<tr class="separator:ac4e90a2ee7cac094d2d1376a8c9bb2b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab929540d1ceafc874111cb4b6046573"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aab929540d1ceafc874111cb4b6046573">operator=</a> (const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> &amp;)=default</td></tr>
<tr class="separator:aab929540d1ceafc874111cb4b6046573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5256f191e01725498f3641b652645a8"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ac5256f191e01725498f3641b652645a8">OtherEndVertex</a> (const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex) const</td></tr>
<tr class="separator:ac5256f191e01725498f3641b652645a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7fafe41b0fed7f544698d8aee234e2f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ae7fafe41b0fed7f544698d8aee234e2f">PointAt</a> (double normalized_edge_parameter, <a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> subd_appearance) const</td></tr>
<tr class="separator:ae7fafe41b0fed7f544698d8aee234e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb666f91f52f1b93d454a94ac223ec85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#adb666f91f52f1b93d454a94ac223ec85">RemoveFaceFromArray</a> (const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *f)</td></tr>
<tr class="separator:adb666f91f52f1b93d454a94ac223ec85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260640a13947a2a5ad900881b5605b15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a260640a13947a2a5ad900881b5605b15">RemoveFaceFromArray</a> (unsigned int i, <a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> &amp;removed_face)</td></tr>
<tr class="separator:a260640a13947a2a5ad900881b5605b15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07295fb1f7c855656c6ede2a5b7f431"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ac07295fb1f7c855656c6ede2a5b7f431">ReplaceFaceInArray</a> (const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *old_face, const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *new_face)</td></tr>
<tr class="separator:ac07295fb1f7c855656c6ede2a5b7f431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6cd7db533e32770cb0c1d7100a6fa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ace6cd7db533e32770cb0c1d7100a6fa2">SetSharpnessForExperts</a> (<a class="el" href="class_o_n___sub_d_edge_sharpness.html">ON_SubDEdgeSharpness</a> sharpness)</td></tr>
<tr class="memdesc:ace6cd7db533e32770cb0c1d7100a6fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This tool is for expert users and internal use. A collection of <a class="el" href="class_o_n___sub_d.html#a9c89462e3815d30c507e98b920b18f18" title="Set or change edge sharpness.">ON_SubD::SetEdgeSharpness()</a> functions provide the easiest way to set and change edge sharpness. Set the edge sharpness values to (sharpness[0],sharpness[1]). The interval values must be &gt;= 0 and &lt;= <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a17dfa16a846971eee9f0646fc0005919" title="ON_SubDEdgeSharpness::MaximumValue = 4. SubD edge sharpness values are &lt;= ON_SubDEdgeSharpness::Maxim...">ON_SubDEdgeSharpness::MaximumValue</a>. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges.  <a href="class_o_n___sub_d_edge.html#ace6cd7db533e32770cb0c1d7100a6fa2">More...</a><br /></td></tr>
<tr class="separator:ace6cd7db533e32770cb0c1d7100a6fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae960d5f6e322786e65212719c147b42b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge_sharpness.html">ON_SubDEdgeSharpness</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ae960d5f6e322786e65212719c147b42b">Sharpness</a> (bool bUseCreaseSharpness) const</td></tr>
<tr class="memdesc:ae960d5f6e322786e65212719c147b42b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge's sharpness. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges.  <a href="class_o_n___sub_d_edge.html#ae960d5f6e322786e65212719c147b42b">More...</a><br /></td></tr>
<tr class="separator:ae960d5f6e322786e65212719c147b42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4746461e384760dbf9aa2740e344c92"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge_sharpness.html">ON_SubDEdgeSharpness</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#af4746461e384760dbf9aa2740e344c92">SubdivideSharpness</a> (const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *end_vertex, bool bReverseSharpness) const</td></tr>
<tr class="memdesc:af4746461e384760dbf9aa2740e344c92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge sharpenss values for the subdivided edge at the specified end of this edge.  <a href="class_o_n___sub_d_edge.html#af4746461e384760dbf9aa2740e344c92">More...</a><br /></td></tr>
<tr class="separator:af4746461e384760dbf9aa2740e344c92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd34ae348ddb3c403b658bc8504426b4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___sub_d_edge_sharpness.html">ON_SubDEdgeSharpness</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#acd34ae348ddb3c403b658bc8504426b4">SubdivideSharpness</a> (unsigned evi, bool bReverseSharpness) const</td></tr>
<tr class="memdesc:acd34ae348ddb3c403b658bc8504426b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge sharpenss values for the subdivided edge at the specified end of this edge.  <a href="class_o_n___sub_d_edge.html#acd34ae348ddb3c403b658bc8504426b4">More...</a><br /></td></tr>
<tr class="separator:acd34ae348ddb3c403b658bc8504426b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed6d6b653ab5160c8f904fabe0eae4e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#afed6d6b653ab5160c8f904fabe0eae4e">SubdivisionPoint</a> () const</td></tr>
<tr class="memdesc:afed6d6b653ab5160c8f904fabe0eae4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the SubD edge Catmull-Clark subdivision point.  <a href="class_o_n___sub_d_edge.html#afed6d6b653ab5160c8f904fabe0eae4e">More...</a><br /></td></tr>
<tr class="separator:afed6d6b653ab5160c8f904fabe0eae4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d21d35f9472f5d978bab03757e5ce87"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a8d21d35f9472f5d978bab03757e5ce87">SurfaceBoundingBox</a> (const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd) const</td></tr>
<tr class="separator:a8d21d35f9472f5d978bab03757e5ce87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37f11787eac0b734b5bf1f1902dcbe0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ad37f11787eac0b734b5bf1f1902dcbe0">SurfaceCenterNormal</a> (unsigned int edge_face_index) const</td></tr>
<tr class="separator:ad37f11787eac0b734b5bf1f1902dcbe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8443a219d753d64822338aa92cf3a4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a5e8443a219d753d64822338aa92cf3a4">SurfaceCenterPoint</a> () const</td></tr>
<tr class="separator:a5e8443a219d753d64822338aa92cf3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac40157addc45a5da376c62f90ce6da71"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ac40157addc45a5da376c62f90ce6da71">TaggedEndIndex</a> () const</td></tr>
<tr class="separator:ac40157addc45a5da376c62f90ce6da71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b28c68850328ecacd21d85249ff2b0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga7bc5f55fc24151607737806fdb29668d">ON__UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a7b28c68850328ecacd21d85249ff2b0b">TopologyCRC32</a> (bool bIncludeSubdivisionProperties) const</td></tr>
<tr class="memdesc:a7b28c68850328ecacd21d85249ff2b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a 32 bit CRC that is useful in detecting when an edge's connections to attached vertices or faces have been changed.  <a href="class_o_n___sub_d_edge.html#a7b28c68850328ecacd21d85249ff2b0b">More...</a><br /></td></tr>
<tr class="separator:a7b28c68850328ecacd21d85249ff2b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e684e9ef1d695d21cb6aed8388b2bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a87e684e9ef1d695d21cb6aed8388b2bd">TopologyHash</a> (bool bIncludeSubdivisionProperties) const</td></tr>
<tr class="memdesc:a87e684e9ef1d695d21cb6aed8388b2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a SHA-1 hash that is useful in detecting when an edge's connections to attached vertices or faces have been changed. See also <a class="el" href="class_o_n___sub_d_edge.html#a7b28c68850328ecacd21d85249ff2b0b" title="Get a 32 bit CRC that is useful in detecting when an edge&#39;s connections to attached vertices or faces...">ON_SubDEdge::TopologyCRC32()</a> which, in practice, is just as reliable as the hash.  <a href="class_o_n___sub_d_edge.html#a87e684e9ef1d695d21cb6aed8388b2bd">More...</a><br /></td></tr>
<tr class="separator:a87e684e9ef1d695d21cb6aed8388b2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68f7b27426bee58638b3a63711933e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ad68f7b27426bee58638b3a63711933e7">Transform</a> (bool bTransformationSavedSubdivisionPoint, const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform)</td></tr>
<tr class="separator:ad68f7b27426bee58638b3a63711933e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739e7762a1d631e2a9802003352736ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a739e7762a1d631e2a9802003352736ac">UnsetSectorCoefficientsForExperts</a> () const</td></tr>
<tr class="separator:a739e7762a1d631e2a9802003352736ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02cf37ae4aaa2f0d679da0e3ad975d81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a02cf37ae4aaa2f0d679da0e3ad975d81">UpdateEdgeSectorCoefficientsForExperts</a> (bool bUnsetEdgeSectorCoefficientsOnly) const</td></tr>
<tr class="separator:a02cf37ae4aaa2f0d679da0e3ad975d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da052ac2aa20a285dea413819cedcba"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a7da052ac2aa20a285dea413819cedcba">Vertex</a> (unsigned evi) const</td></tr>
<tr class="separator:a7da052ac2aa20a285dea413819cedcba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3623c06a981519b19942944a593611e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ab3623c06a981519b19942944a593611e">VertexArrayIndex</a> (const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v) const</td></tr>
<tr class="separator:ab3623c06a981519b19942944a593611e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18506d55a9d8350ed317d96de9ff88b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#af18506d55a9d8350ed317d96de9ff88b">VertexCount</a> () const</td></tr>
<tr class="separator:af18506d55a9d8350ed317d96de9ff88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac95b0602eb28359b5eab984ff179cb20"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ac95b0602eb28359b5eab984ff179cb20">VertexId</a> (unsigned evi) const</td></tr>
<tr class="separator:ac95b0602eb28359b5eab984ff179cb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94917b6e0954cae0871e0168dce82185"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a94917b6e0954cae0871e0168dce82185">Write</a> (class <a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;archive) const</td></tr>
<tr class="separator:a94917b6e0954cae0871e0168dce82185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_o_n___sub_d_component_base"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_o_n___sub_d_component_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a></td></tr>
<tr class="memitem:a06cc444e595d6af5288362170da3f88a inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a06cc444e595d6af5288362170da3f88a">ON_SubDComponentBase</a> ()=default</td></tr>
<tr class="separator:a06cc444e595d6af5288362170da3f88a inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886ede5896b14d9db66f078ebe85572e inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a886ede5896b14d9db66f078ebe85572e">ON_SubDComponentBase</a> (const <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> &amp;)=default</td></tr>
<tr class="separator:a886ede5896b14d9db66f078ebe85572e inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda72ccf7ea55d48df282dee8861016f inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#adda72ccf7ea55d48df282dee8861016f">~ON_SubDComponentBase</a> ()=default</td></tr>
<tr class="separator:adda72ccf7ea55d48df282dee8861016f inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ed8428e5a2777b2194a642fe9b6448 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ae2ed8428e5a2777b2194a642fe9b6448">ArchiveId</a> () const</td></tr>
<tr class="separator:ae2ed8428e5a2777b2194a642fe9b6448 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aea9104ff07d0c388cd274ecb0aa29d inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a3aea9104ff07d0c388cd274ecb0aa29d">ClearMark</a> () const</td></tr>
<tr class="separator:a3aea9104ff07d0c388cd274ecb0aa29d inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a36b5b75fe7099b21da42f80a58361 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga5f8bfada72de9a3799c044d19407b44f">ON__UINT8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a86a36b5b75fe7099b21da42f80a58361">ClearMarkBits</a> () const</td></tr>
<tr class="separator:a86a36b5b75fe7099b21da42f80a58361 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0a05208cbc473593c00c9291e2556a inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#aef0a05208cbc473593c00c9291e2556a">ClearSavedSubdivisionPoint</a> () const</td></tr>
<tr class="separator:aef0a05208cbc473593c00c9291e2556a inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0ffb84ec1b6a34c56d86086ec08aac inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#aae0ffb84ec1b6a34c56d86086ec08aac">ClearSubdivisionDisplacement</a> () const</td></tr>
<tr class="separator:aae0ffb84ec1b6a34c56d86086ec08aac inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd8bced839579fed171ebefb2d1b5baa inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#afd8bced839579fed171ebefb2d1b5baa">GetSavedSubdivisionPoint</a> (double subdivision_point[3]) const</td></tr>
<tr class="separator:afd8bced839579fed171ebefb2d1b5baa inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280bffd504d23fbbcd342f3a51bbe76f inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a280bffd504d23fbbcd342f3a51bbe76f">GetSubdivisionDisplacement</a> (double *) const</td></tr>
<tr class="separator:a280bffd504d23fbbcd342f3a51bbe76f inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eefd8042463e89bea36874078966eda inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a5eefd8042463e89bea36874078966eda">InSymmetrySet</a> () const</td></tr>
<tr class="separator:a5eefd8042463e89bea36874078966eda inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e88157dad61d4b34f6f638159029853 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a6e88157dad61d4b34f6f638159029853">IsActive</a> () const</td></tr>
<tr class="separator:a6e88157dad61d4b34f6f638159029853 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb3e70b1d517b73f7d0cb87b6bc106c inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#aceb3e70b1d517b73f7d0cb87b6bc106c">IsSymmetrySetPrimaryMotif</a> () const</td></tr>
<tr class="separator:aceb3e70b1d517b73f7d0cb87b6bc106c inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4563bd61b50a8841f9837547a7b7fbe inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ab4563bd61b50a8841f9837547a7b7fbe">Mark</a> () const</td></tr>
<tr class="separator:ab4563bd61b50a8841f9837547a7b7fbe inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863f993d46e4c1f5b0085626d9d59c76 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga5f8bfada72de9a3799c044d19407b44f">ON__UINT8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a863f993d46e4c1f5b0085626d9d59c76">MarkBits</a> () const</td></tr>
<tr class="separator:a863f993d46e4c1f5b0085626d9d59c76 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6306c393a2d14c2aeb9f52f5539440e inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#af6306c393a2d14c2aeb9f52f5539440e">operator=</a> (const <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> &amp;)=default</td></tr>
<tr class="separator:af6306c393a2d14c2aeb9f52f5539440e inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61348dacbf25ce1673d67b1d119a824d inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a61348dacbf25ce1673d67b1d119a824d">SavedSubdivisionPoint</a> () const</td></tr>
<tr class="separator:a61348dacbf25ce1673d67b1d119a824d inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac43e8cb69dd9966708894829e4a2b7e4 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ac43e8cb69dd9966708894829e4a2b7e4">SavedSubdivisionPointIsSet</a> () const</td></tr>
<tr class="separator:ac43e8cb69dd9966708894829e4a2b7e4 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806843cb771a050678f43e6291dc0067 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a806843cb771a050678f43e6291dc0067">SetArchiveId</a> (unsigned int archive_id) const</td></tr>
<tr class="separator:a806843cb771a050678f43e6291dc0067 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e7153be394a2c339cdcab48f685e837 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a5e7153be394a2c339cdcab48f685e837">SetMark</a> () const</td></tr>
<tr class="separator:a5e7153be394a2c339cdcab48f685e837 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ce5234289ea8bf4eaf79c78f1e116d inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ae1ce5234289ea8bf4eaf79c78f1e116d">SetMark</a> (bool bMark) const</td></tr>
<tr class="separator:ae1ce5234289ea8bf4eaf79c78f1e116d inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8d39cf01868c9ecfa59b9d37525e58 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga5f8bfada72de9a3799c044d19407b44f">ON__UINT8</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#aad8d39cf01868c9ecfa59b9d37525e58">SetMarkBits</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga5f8bfada72de9a3799c044d19407b44f">ON__UINT8</a> mark_bits) const</td></tr>
<tr class="separator:aad8d39cf01868c9ecfa59b9d37525e58 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d7bef13ef562b14c321859d67e4fec inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a93d7bef13ef562b14c321859d67e4fec">SetSavedSubdivisionPoint</a> (const double subdivision_point[3]) const</td></tr>
<tr class="separator:a93d7bef13ef562b14c321859d67e4fec inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2181dbb74b61da3390151eeb907da21 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ac2181dbb74b61da3390151eeb907da21">SetSubdivisionDisplacement</a> (const double *)</td></tr>
<tr class="separator:ac2181dbb74b61da3390151eeb907da21 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c43c4b2665941a8a4728992c683447 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#aa9c43c4b2665941a8a4728992c683447">SetSubdivisionLevel</a> (unsigned level)</td></tr>
<tr class="separator:aa9c43c4b2665941a8a4728992c683447 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b9d765362542e4f45c5a98e4cc9ab8 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ab2b9d765362542e4f45c5a98e4cc9ab8">Status</a> () const</td></tr>
<tr class="separator:ab2b9d765362542e4f45c5a98e4cc9ab8 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe30910c9c53a51c8632577505ea66a inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a0fe30910c9c53a51c8632577505ea66a">SubdivisionDisplacement</a> () const</td></tr>
<tr class="separator:a0fe30910c9c53a51c8632577505ea66a inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9122e52eabd3a6303878cf91e9649799 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a9122e52eabd3a6303878cf91e9649799">SubdivisionDisplacementIsNonzero</a> () const</td></tr>
<tr class="separator:a9122e52eabd3a6303878cf91e9649799 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1839be2e01652f135d9b8ea884d08938 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">const unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a1839be2e01652f135d9b8ea884d08938">SubdivisionLevel</a> () const</td></tr>
<tr class="separator:a1839be2e01652f135d9b8ea884d08938 inherit pub_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a68b7ae6eaa743f2ee168974eeb4f6728"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a68b7ae6eaa743f2ee168974eeb4f6728">FromVertices</a> (const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex0, const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex1)</td></tr>
<tr class="separator:a68b7ae6eaa743f2ee168974eeb4f6728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a408853d5404b15cb741f0711d6990"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a45a408853d5404b15cb741f0711d6990">FromVertices</a> (const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex0, const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex1, bool bIgnoreOrientation)</td></tr>
<tr class="separator:a45a408853d5404b15cb741f0711d6990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3ecdc83cd8f5f815a8e496aeb2bb14"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a2f3ecdc83cd8f5f815a8e496aeb2bb14">Read</a> (class <a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;archive, class <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&amp;edge)</td></tr>
<tr class="separator:a2f3ecdc83cd8f5f815a8e496aeb2bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_o_n___sub_d_component_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_o_n___sub_d_component_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a></td></tr>
<tr class="memitem:ab09c10fc310ea9d8c7f9f5fa086d8dd0 inherit pub_static_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ab09c10fc310ea9d8c7f9f5fa086d8dd0">CompareId</a> (const <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> *lhs, const <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> *rhs)</td></tr>
<tr class="separator:ab09c10fc310ea9d8c7f9f5fa086d8dd0 inherit pub_static_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a1398e0a19c67627d7c9d0dac25c6da35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a1398e0a19c67627d7c9d0dac25c6da35">m_edge_tag</a> = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a></td></tr>
<tr class="separator:a1398e0a19c67627d7c9d0dac25c6da35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0278804e5eb3aeecd36fa3528037f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ad0278804e5eb3aeecd36fa3528037f96">m_face2</a> [2] = {}</td></tr>
<tr class="separator:ad0278804e5eb3aeecd36fa3528037f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5648ad718190be78e5b8d19a687b5a77"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a5648ad718190be78e5b8d19a687b5a77">m_face_count</a> = 0</td></tr>
<tr class="separator:a5648ad718190be78e5b8d19a687b5a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d39667e1772862c74e90b3603f76d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a86d39667e1772862c74e90b3603f76d8">m_facex</a> = nullptr</td></tr>
<tr class="separator:a86d39667e1772862c74e90b3603f76d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8bb93838516d8ebc184cf9f05340ef5"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ab8bb93838516d8ebc184cf9f05340ef5">m_facex_capacity</a> = 0</td></tr>
<tr class="separator:ab8bb93838516d8ebc184cf9f05340ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd2efb5803454c2376f1d37383334e0a"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#afd2efb5803454c2376f1d37383334e0a">m_next_edge</a> = nullptr</td></tr>
<tr class="memdesc:afd2efb5803454c2376f1d37383334e0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">linked list of edges on this level  <a href="class_o_n___sub_d_edge.html#afd2efb5803454c2376f1d37383334e0a">More...</a><br /></td></tr>
<tr class="separator:afd2efb5803454c2376f1d37383334e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eff580f9f83fcaeee98ba92afd8dab4"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a7eff580f9f83fcaeee98ba92afd8dab4">m_prev_edge</a> = nullptr</td></tr>
<tr class="memdesc:a7eff580f9f83fcaeee98ba92afd8dab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">m_prev_edge, m_next_edge must be the first data members of <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>  <a href="class_o_n___sub_d_edge.html#a7eff580f9f83fcaeee98ba92afd8dab4">More...</a><br /></td></tr>
<tr class="separator:a7eff580f9f83fcaeee98ba92afd8dab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0c9de427fb1f2eddb3fcabef63fb1a5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ad0c9de427fb1f2eddb3fcabef63fb1a5">m_sector_coefficient</a> [2] = {}</td></tr>
<tr class="separator:ad0c9de427fb1f2eddb3fcabef63fb1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6f4c8adb7579d436627ff40c33d6f43"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#ad6f4c8adb7579d436627ff40c33d6f43">m_vertex</a> [2] = {}</td></tr>
<tr class="separator:ad6f4c8adb7579d436627ff40c33d6f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_class_o_n___sub_d_component_base"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_class_o_n___sub_d_component_base')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a></td></tr>
<tr class="memitem:ab9a58d48e62de3d5cee831f89adedee0 inherit pub_attribs_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ab9a58d48e62de3d5cee831f89adedee0">m_group_id</a> = 0U</td></tr>
<tr class="separator:ab9a58d48e62de3d5cee831f89adedee0 inherit pub_attribs_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76231ac99ed5d5c17145ee16931dbe1c inherit pub_attribs_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a76231ac99ed5d5c17145ee16931dbe1c">m_id</a> = 0</td></tr>
<tr class="separator:a76231ac99ed5d5c17145ee16931dbe1c inherit pub_attribs_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7582e4013172e7a2c28c0f97a51ec4 inherit pub_attribs_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a3c7582e4013172e7a2c28c0f97a51ec4">m_status</a> = <a class="el" href="class_o_n___component_status.html#ae267cd5d4088c8a033fa348d30227223">ON_ComponentStatus::NoneSet</a></td></tr>
<tr class="separator:a3c7582e4013172e7a2c28c0f97a51ec4 inherit pub_attribs_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b30f23e53f402af8fc4b1f4035ea022 inherit pub_attribs_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a5b30f23e53f402af8fc4b1f4035ea022">m_subd_point1</a> = nullptr</td></tr>
<tr class="separator:a5b30f23e53f402af8fc4b1f4035ea022 inherit pub_attribs_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a0366b0f548345598c3ba49e75997bc53"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a0366b0f548345598c3ba49e75997bc53">Empty</a></td></tr>
<tr class="separator:a0366b0f548345598c3ba49e75997bc53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_o_n___sub_d_component_base"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_o_n___sub_d_component_base')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a></td></tr>
<tr class="memitem:ac09c5038c8570f24788f6a73fc8b1cce inherit pub_static_attribs_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ac09c5038c8570f24788f6a73fc8b1cce">Unset</a></td></tr>
<tr class="separator:ac09c5038c8570f24788f6a73fc8b1cce inherit pub_static_attribs_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a9a9e907686d639ecb6a4fa92d4fecc89"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a9a9e907686d639ecb6a4fa92d4fecc89">ON_Internal_SubDFaceMeshFragmentAccumulator</a></td></tr>
<tr class="separator:a9a9e907686d639ecb6a4fa92d4fecc89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662beea9e0e441b2ee0687d460fad204"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a662beea9e0e441b2ee0687d460fad204">ON_SubDArchiveIdMap</a></td></tr>
<tr class="separator:a662beea9e0e441b2ee0687d460fad204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5778abbf09c0ca77d0845ad5da4ea44f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a5778abbf09c0ca77d0845ad5da4ea44f">ON_SubDFace</a></td></tr>
<tr class="separator:a5778abbf09c0ca77d0845ad5da4ea44f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1bf700fda49776b4f7d456fe3b29ed"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#a4c1bf700fda49776b4f7d456fe3b29ed">ON_SubDHeap</a></td></tr>
<tr class="separator:a4c1bf700fda49776b4f7d456fe3b29ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf54cfdafac807e154137f737ccb4573"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_edge.html#aaf54cfdafac807e154137f737ccb4573">ON_SubDVertex</a></td></tr>
<tr class="separator:aaf54cfdafac807e154137f737ccb4573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_types_class_o_n___sub_d_component_base"><td colspan="2" onclick="javascript:toggleInherit('pro_types_class_o_n___sub_d_component_base')"><img src="closed.png" alt="-"/>&#160;Protected Types inherited from <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a></td></tr>
<tr class="memitem:a0089e447c1f74381d8c83c1029e06eb5 inherit pro_types_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a0089e447c1f74381d8c83c1029e06eb5">ModifiedFlags</a> : unsigned char { <a class="el" href="class_o_n___sub_d_component_base.html#a0089e447c1f74381d8c83c1029e06eb5a22a449581e0c51927f0ef2f1f71ee4b6">Modified1Bit</a> = 0x01, 
<a class="el" href="class_o_n___sub_d_component_base.html#a0089e447c1f74381d8c83c1029e06eb5ab246ba27cc521960508090a94c740a88">Modified2Bit</a> = 0x02, 
<a class="el" href="class_o_n___sub_d_component_base.html#a0089e447c1f74381d8c83c1029e06eb5aace03d384f0e602ba10baf8ae5bd96b2">ModifiedFlagsMask</a> = 0x03
 }</td></tr>
<tr class="separator:a0089e447c1f74381d8c83c1029e06eb5 inherit pro_types_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a114cee001ebc3ac1d6dc8d79f701affe inherit pro_types_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a114cee001ebc3ac1d6dc8d79f701affe">SavedPointsFlags</a> : unsigned char { <a class="el" href="class_o_n___sub_d_component_base.html#a114cee001ebc3ac1d6dc8d79f701affea0f51bde3500ef699c8df11ded628a20a">SubdivisionPointBit</a> = 0x40, 
<a class="el" href="class_o_n___sub_d_component_base.html#a114cee001ebc3ac1d6dc8d79f701affeab9b4553edf282e46f98854756c0fcc33">SurfacePointBit</a> = 0x80, 
<a class="el" href="class_o_n___sub_d_component_base.html#a114cee001ebc3ac1d6dc8d79f701affeaf8017903412d21cea96ebe81d5220560">CachedPointMask</a> = 0xC0
 }</td></tr>
<tr class="separator:a114cee001ebc3ac1d6dc8d79f701affe inherit pro_types_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_o_n___sub_d_component_base"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_class_o_n___sub_d_component_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a></td></tr>
<tr class="memitem:adf0913f785d24734590fbc361779915c inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#adf0913f785d24734590fbc361779915c">CopyBaseFrom</a> (const <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> *src, bool bCopySymmetrySetNext)</td></tr>
<tr class="separator:adf0913f785d24734590fbc361779915c inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f26500f5327a6c90e22328d00eed14 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a21f26500f5327a6c90e22328d00eed14">Internal_ClearModifiedFlags</a> () const</td></tr>
<tr class="separator:a21f26500f5327a6c90e22328d00eed14 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a323adc02858aa3292465fda0bbe24649 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a323adc02858aa3292465fda0bbe24649">Internal_ClearSubdivisionPointAndSurfacePointFlags</a> () const</td></tr>
<tr class="separator:a323adc02858aa3292465fda0bbe24649 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16595f29bcf70cac5b8e993efae1f36a inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a16595f29bcf70cac5b8e993efae1f36a">Internal_ClearSubdivisionPointFlag</a> () const</td></tr>
<tr class="separator:a16595f29bcf70cac5b8e993efae1f36a inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47f2cfec18b911ee06f22aa7c62124bf inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a47f2cfec18b911ee06f22aa7c62124bf">Internal_ClearSurfacePointFlag</a> () const</td></tr>
<tr class="separator:a47f2cfec18b911ee06f22aa7c62124bf inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5588f95a2bd84dc14bf678892a09c347 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a5588f95a2bd84dc14bf678892a09c347">Internal_Modified1IsSet</a> () const</td></tr>
<tr class="separator:a5588f95a2bd84dc14bf678892a09c347 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076ef7742bf9331ccbac7ad0bdf52aff inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a076ef7742bf9331ccbac7ad0bdf52aff">Internal_Modified1or2IsSet</a> () const</td></tr>
<tr class="separator:a076ef7742bf9331ccbac7ad0bdf52aff inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a804097b04d48e917ceeb983e4ed53bf4 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a804097b04d48e917ceeb983e4ed53bf4">Internal_SetModified1Flag</a> () const</td></tr>
<tr class="separator:a804097b04d48e917ceeb983e4ed53bf4 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d369d70618c27bdb735662486eea29 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#aa7d369d70618c27bdb735662486eea29">Internal_SetModified2Flag</a> () const</td></tr>
<tr class="separator:aa7d369d70618c27bdb735662486eea29 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e97bf8f1e88a7fd072b5badbb468588 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a5e97bf8f1e88a7fd072b5badbb468588">Internal_SetSavedSurfacePointFlag</a> (bool bSavedSurfacePointFlag) const</td></tr>
<tr class="separator:a5e97bf8f1e88a7fd072b5badbb468588 inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc541eec3647dbcbab2f055de73158d inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a3cc541eec3647dbcbab2f055de73158d">Internal_SubdivisionPointFlag</a> () const</td></tr>
<tr class="separator:a3cc541eec3647dbcbab2f055de73158d inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8f8edfaab3a3ced4da4e0c4abc6bfb inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a6e8f8edfaab3a3ced4da4e0c4abc6bfb">Internal_SurfacePointFlag</a> () const</td></tr>
<tr class="separator:a6e8f8edfaab3a3ced4da4e0c4abc6bfb inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2823694a58779d4d81fe35493ae05cfb inherit pro_methods_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a2823694a58779d4d81fe35493ae05cfb">Internal_TransformComponentBase</a> (bool bTransformationSavedSubdivisionPoint, const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform)</td></tr>
<tr class="separator:a2823694a58779d4d81fe35493ae05cfb inherit pro_methods_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_o_n___sub_d_component_base"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_o_n___sub_d_component_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a></td></tr>
<tr class="memitem:ae609568efd09af50564debc87010606d inherit pro_attribs_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#ae609568efd09af50564debc87010606d">m_level</a> = 0U</td></tr>
<tr class="separator:ae609568efd09af50564debc87010606d inherit pro_attribs_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5665f98f601c3a89ec1e789b0ef577f3 inherit pro_attribs_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a5665f98f601c3a89ec1e789b0ef577f3">m_saved_points_flags</a> = 0U</td></tr>
<tr class="separator:a5665f98f601c3a89ec1e789b0ef577f3 inherit pro_attribs_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0388f57c2f3b00bd7e19fa22297c942d inherit pro_attribs_class_o_n___sub_d_component_base"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_component_base.html#a0388f57c2f3b00bd7e19fa22297c942d">m_saved_subd_point1</a> [3]</td></tr>
<tr class="memdesc:a0388f57c2f3b00bd7e19fa22297c942d inherit pro_attribs_class_o_n___sub_d_component_base"><td class="mdescLeft">&#160;</td><td class="mdescRight">GetSubdivisionPoint( bUseSavedSubdivisionPoint=true ) can change the value of m_cache_subd_P.  <a href="class_o_n___sub_d_component_base.html#a0388f57c2f3b00bd7e19fa22297c942d">More...</a><br /></td></tr>
<tr class="separator:a0388f57c2f3b00bd7e19fa22297c942d inherit pro_attribs_class_o_n___sub_d_component_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a4179adeaad9c0b1ae3f973fa5d23dad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4179adeaad9c0b1ae3f973fa5d23dad3">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Array of m_face_count faces.</p>
<p>The first two are in m_face2[0] and m_face2[1]. When m_face_count &gt; 3, the third and additional faces are in m_facex[0], ..., m_facex[m_face_count-3];</p>
<p>The value of <a class="el" href="class_o_n___sub_d_face_ptr.html#ac6b466b3d9a31c95f507aea9eb7ded8c">ON_SubDFacePtr.FaceDirection()</a> is 0 if the edge's natural orientation from m_vertex[0] to m_vertex[1] agrees with the face's boundary orientation.</p>
<p>The value of <a class="el" href="class_o_n___sub_d_face_ptr.html#ac6b466b3d9a31c95f507aea9eb7ded8c">ON_SubDFacePtr.FaceDirection()</a> is 1 if the edge's natural orientation from m_vertex[0] to m_vertex[1] is opposited the face's boundary orientation. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a4179adeaad9c0b1ae3f973fa5d23dad3ab14a1da83370eeb51e6fec74230b4a74"></a>MaximumFaceCount&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aee0de290c463d6ee380921da8a3a1d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee0de290c463d6ee380921da8a3a1d4a">&#9670;&nbsp;</a></span>ON_SubDEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubDEdge::ON_SubDEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa0431189189a2957cf30c8971235161f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0431189189a2957cf30c8971235161f">&#9670;&nbsp;</a></span>~ON_SubDEdge()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubDEdge::~ON_SubDEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afdeb16e4735817b145d9cb2d666b3561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdeb16e4735817b145d9cb2d666b3561">&#9670;&nbsp;</a></span>ON_SubDEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubDEdge::ON_SubDEdge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8447cf57411e921f1292cbbafb00552f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8447cf57411e921f1292cbbafb00552f">&#9670;&nbsp;</a></span>AddFaceToArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::AddFaceToArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a>&#160;</td>
          <td class="paramname"><em>face_ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to add a face from the edges's face array. Remarks: Does not modify the face. If the edge is not referenced in the face's edge array, then the edge must be inserted in the correct location in the faces array. If you are creating a non-manifold SubD, you must first reserve m_facex[] capacity by calling <a class="el" href="class_o_n___sub_d.html#abd7af2b3015684e980b679351270f1af">ON_SubD::GrowEdgeFaceArray()</a>. </p>

</div>
</div>
<a id="aa9f8377e6483d96c801eaebf6163ebf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f8377e6483d96c801eaebf6163ebf2">&#9670;&nbsp;</a></span>AdjacentEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubDEdge::AdjacentEdge </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_vertex_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d8d814efc98e216a9a1e97d6c64446b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8d814efc98e216a9a1e97d6c64446b">&#9670;&nbsp;</a></span>AdjacentEdgePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubDEdge::AdjacentEdgePtr </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_vertex_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge_vertex_index - [in] 0 or 1 identifying which end of this edge to check. i - [in] Index of the face in this edge's face array. Returns: The edge adjacent to this edge in this-&gt;Face(i). The orientation is with respect to this-&gt;Face(i). </p>

</div>
</div>
<a id="afe7f27e16a7bb967269dd6e471951b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7f27e16a7bb967269dd6e471951b79">&#9670;&nbsp;</a></span>BoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> ON_SubDEdge::BoundingBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>subd_appearance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44ebe94ca385db6155685497eddda3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ebe94ca385db6155685497eddda3d3">&#9670;&nbsp;</a></span>CenterFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___plane.html">ON_Plane</a> ON_SubDEdge::CenterFrame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>subd_appearance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afaf1941a3eb36cb4835bda4073d9d1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf1941a3eb36cb4835bda4073d9d1c6">&#9670;&nbsp;</a></span>CenterNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> ON_SubDEdge::CenterNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>subd_appearance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_face_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e4987949f95233530b4897b381d2ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4987949f95233530b4897b381d2ff2">&#9670;&nbsp;</a></span>CenterPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_SubDEdge::CenterPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>subd_appearance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a27954fd3351254ed5e23d3d8ba46b50d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27954fd3351254ed5e23d3d8ba46b50d">&#9670;&nbsp;</a></span>ClearSavedSubdivisionPoints() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubDEdge::ClearSavedSubdivisionPoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Clears saved subdivision and limit surface information for this edge. Attached vertices and faces are not modified. </p>

</div>
</div>
<a id="acd716f13fb5df8811a8e6f2f91bda389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd716f13fb5df8811a8e6f2f91bda389">&#9670;&nbsp;</a></span>ClearSavedSubdivisionPoints() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubDEdge::ClearSavedSubdivisionPoints </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearNeighborhood</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Clears saved subdivision and limit surface information for this edge. Parameters: bClearNeighborhood - [in] If true, all vertices and faces attached to this edge are also cleared. </p>

</div>
</div>
<a id="a9ad91dd78a3c11b60ee4813308f4e319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad91dd78a3c11b60ee4813308f4e319">&#9670;&nbsp;</a></span>ClearSharpnessForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::ClearSharpnessForExperts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This tool is for expert users and internal use. Use <a class="el" href="class_o_n___sub_d.html#ae0c2e7c23abeda77ca022d6de68934ca" title="Converts all sharp edges to smooth edges. See ON_SubDEdge::IsSharp() for more information about sharp...">ON_SubD::ClearEdgeSharpness()</a> to remove all sharp edges from a SubD. Sets the edge sharpness to ON_EdgeSharpness::Zero. </p>
<dl class="section return"><dt>Returns</dt><dd>True if there were changes to the edge.</dd></dl>

</div>
</div>
<a id="a3876cc3a94f2146b39ea16493daf1979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3876cc3a94f2146b39ea16493daf1979">&#9670;&nbsp;</a></span>ComponentIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> ON_SubDEdge::ComponentIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc6852d9b91c7b5ae1f37d4d635cccc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6852d9b91c7b5ae1f37d4d635cccc6">&#9670;&nbsp;</a></span>ComponentPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> ON_SubDEdge::ComponentPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aabd3c0e0012d9e07f969a6c7071436e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd3c0e0012d9e07f969a6c7071436e5">&#9670;&nbsp;</a></span>ControlNetBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> ON_SubDEdge::ControlNetBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5746d8f630ad97558d2891fa31b82bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5746d8f630ad97558d2891fa31b82bb">&#9670;&nbsp;</a></span>ControlNetCenterNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> ON_SubDEdge::ControlNetCenterNormal </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_face_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad496d3ccc3b80eb19708481e1c09be03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad496d3ccc3b80eb19708481e1c09be03">&#9670;&nbsp;</a></span>ControlNetCenterPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_SubDEdge::ControlNetCenterPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30e11bc91a0cb4d4779aaff1873a4471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30e11bc91a0cb4d4779aaff1873a4471">&#9670;&nbsp;</a></span>ControlNetDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> ON_SubDEdge::ControlNetDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: If vertices are set, then the vector from m_vertex[0]-&gt;<a class="el" href="class_o_n___sub_d_edge.html#a458b89a882d495ce10a621a1d5f0d135">ControlNetPoint()</a> to m_vertex[1]-&gt;<a class="el" href="class_o_n___sub_d_edge.html#a458b89a882d495ce10a621a1d5f0d135">ControlNetPoint()</a> is returned. Otherwise <a class="el" href="class_o_n__3d_vector.html#a2bb705b5d7458947109344fe28460228" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_3dVector::NanVector</a> is returned. </p>

</div>
</div>
<a id="a04d997c6c38dc894d9dd77ee7f1b5d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04d997c6c38dc894d9dd77ee7f1b5d2f">&#9670;&nbsp;</a></span>ControlNetDirectionFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> ON_SubDEdge::ControlNetDirectionFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: If vertices are set and v is an end of the edge, then the vector from v to OtherEndVertex(v) is returned. Otherwise <a class="el" href="class_o_n__3d_vector.html#a2bb705b5d7458947109344fe28460228" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_3dVector::NanVector</a> is returned. </p>

</div>
</div>
<a id="a3155f4b63bad0b5de402bb6151c43bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3155f4b63bad0b5de402bb6151c43bbc">&#9670;&nbsp;</a></span>ControlNetLine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___line.html">ON_Line</a> ON_SubDEdge::ControlNetLine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a458b89a882d495ce10a621a1d5f0d135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458b89a882d495ce10a621a1d5f0d135">&#9670;&nbsp;</a></span>ControlNetPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_SubDEdge::ControlNetPoint </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: i - [in] 0 or 1. Returns: If i is 0 or 1 and vertex[i] is set, then vertex[i]-&gt;<a class="el" href="class_o_n___sub_d_edge.html#a458b89a882d495ce10a621a1d5f0d135">ControlNetPoint()</a> is returned. Otherwise <a class="el" href="class_o_n__3d_point.html#a431f63a983b61e62251c3ebb37d851ff" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_3dPoint::NanPoint</a> is returned. </p>

</div>
</div>
<a id="aba136d3af02203a246bcbf2ab0bcce39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba136d3af02203a246bcbf2ab0bcce39">&#9670;&nbsp;</a></span>DartCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::DartCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: 0: end vertices are not tagged as darts 1: one end vertex is tagged as a dart. 2: both end vertices are tagged as a darts. </p>

</div>
</div>
<a id="af6d153a97fe785b87b2982bd875fd37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d153a97fe785b87b2982bd875fd37c">&#9670;&nbsp;</a></span>EdgeAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::EdgeAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: bitwise or of applicable <a class="el" href="class_o_n___component_attributes.html#a2d29d48bc4024598cba93dc7903abd8a">ON_ComponentAttributes::EdgeAttributes</a> values. Remarks: <a class="el" href="class_o_n___component_attributes.html#a2d29d48bc4024598cba93dc7903abd8a">ON_ComponentAttributes::EdgeAttributes</a> has subsets of mutually exclusive edge attributes. If the edge is valid, then exactly one bit from each mutually exclusive set of properties will be set. If an edge is not valie, then all bits for a set may be clear. For example, if the edge has nullptr values in m_vertex[] or the vertex control point locations are unset or nan, then neither the ON_ComponentAttributes::EdgeAttributes::Open bit nor ON_ComponentAttributes::EdgeAttributes::Closed bit will be set. </p>

</div>
</div>
<a id="a4c3304ffb8bc48d4e196b8ab5f55351d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c3304ffb8bc48d4e196b8ab5f55351d">&#9670;&nbsp;</a></span>EdgeId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::EdgeId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3df975bb71b54f52db106263443cf123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df975bb71b54f52db106263443cf123">&#9670;&nbsp;</a></span>EdgeModifiedNofification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubDEdge::EdgeModifiedNofification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Call this function if the edge is modified and it will clear any cached subdivision information that needs to be recalculated. </p>

</div>
</div>
<a id="a74fe7d824d457425a65252d2acb7df26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fe7d824d457425a65252d2acb7df26">&#9670;&nbsp;</a></span>EdgeSurfaceCurve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubDEdge::EdgeSurfaceCurve </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClampEndKnots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1d6233797f42664d1573ca9e874526d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d6233797f42664d1573ca9e874526d">&#9670;&nbsp;</a></span>EdgeSurfaceCurveIsSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::EdgeSurfaceCurveIsSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff4611bd6e993bf96c9c92acd9de4a2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4611bd6e993bf96c9c92acd9de4a2b">&#9670;&nbsp;</a></span>EdgeType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga6ea2d14874ad3b20bbc8834ffeb8738e">ON_SubDEdgeType</a> ON_SubDEdge::EdgeType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___sub_d_edge.html#aff4611bd6e993bf96c9c92acd9de4a2b" title="EdgeType() is typically used to generate text descriptions and in selection filtering....">EdgeType()</a> is typically used to generate text descriptions and in selection filtering. Do not confuse <a class="el" href="class_o_n___sub_d_edge.html#aff4611bd6e993bf96c9c92acd9de4a2b" title="EdgeType() is typically used to generate text descriptions and in selection filtering....">EdgeType()</a> and EdgeTag(). </p>
<dl class="section return"><dt>Returns</dt><dd>If the edge has a valid combination of face count, tag, and sharpness properties, then the corresponding type is returned. Otherwise, <a class="el" href="group__open_n_u_r_b_s.html#gga6ea2d14874ad3b20bbc8834ffeb8738ea4bbb8f967da6d1a610596d7257179c2b">ON_SubDEdgeType::Invalid</a> is returned. </dd></dl>

</div>
</div>
<a id="a164177b3e2712c5377261e664993fb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164177b3e2712c5377261e664993fb14">&#9670;&nbsp;</a></span>EndSharpness() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDEdge::EndSharpness </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge's sharpness at the end with the specified vertex. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Vertex at an end of the edge</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">If the edge is sharp, the sharpness at the end with the specified vertex is returned. If the edge is smooth or a crease, 0 is returned. Otherwise, 0.0 is returned. </p>
<p class="enddd">The sharpness at the end of the edge with the specified vertex.</p>
</dd></dl>

</div>
</div>
<a id="a437fc8212b7967bf45bcc93c6e82a18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437fc8212b7967bf45bcc93c6e82a18e">&#9670;&nbsp;</a></span>EndSharpness() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDEdge::EndSharpness </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>evi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge's sharpness at the end with the specified vertex. If the edge is a crease, <a class="el" href="class_o_n___sub_d_edge_sharpness.html#ac450c47da4dfa105cbb4d22654637da9" title="An edge sharpness with contant value 0.0.">ON_SubDEdgeSharpness::Smooth</a> is returned. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evi</td><td>End index (0=start or 1=end).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">If the edge is sharp, the sharpness at the end with the specified by evi is returned. If the edge is smooth or a crease, 0 is returned. Otherwise, 0.0 is returned. </p>
<p class="enddd">The sharpness at the end of the edge specified by evi.</p>
</dd></dl>

</div>
</div>
<a id="a53571fd4f09f6a87ee103b1e6b5850fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53571fd4f09f6a87ee103b1e6b5850fd">&#9670;&nbsp;</a></span>EndSharpness() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDEdge::EndSharpness </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>evi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseCreaseSharpness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge's sharpness at the end with the specified vertex. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evi</td><td>End index (0=start or 1=end).</td></tr>
    <tr><td class="paramname">bUseCreaseSharpness</td><td>If the edge is a crease and bUseCreaseSharpness is false, then <a class="el" href="class_o_n___sub_d_edge_sharpness.html#ac450c47da4dfa105cbb4d22654637da9" title="An edge sharpness with contant value 0.0.">ON_SubDEdgeSharpness::Smooth</a> is returned. If the edge is a crease and bUseCreaseSharpness is true, then <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a16c5939cc1a9f6d6f579fa0199b9cc9a" title="An edge sharpness with both end values = ON_SubDEdgeSharpness::CreaseValue. This value is not a valid...">ON_SubDEdgeSharpness::Crease</a> is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">If the edge is sharp, the sharpness at the end with the specified by evi is returned. If the edge is smooth or a crease, 0 is returned. Otherwise, 0.0 is returned. </p>
<p class="enddd">The sharpness at the end of the edge specified by evi.</p>
</dd></dl>

</div>
</div>
<a id="aefa43c7a986a5b849d2b1b94a8e3b29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa43c7a986a5b849d2b1b94a8e3b29a">&#9670;&nbsp;</a></span>EvaluateCatmullClarkSubdivisionPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::EvaluateCatmullClarkSubdivisionPoint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>subdivision_point</em>[3]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Evaluates the Catmull-Clark subdivision point ignoring all cached information. This function is typically used in testing and debugging code and in ordinary cases, it is faster and better to call <a class="el" href="class_o_n___sub_d_edge.html#afed6d6b653ab5160c8f904fabe0eae4e" title="Get the SubD edge Catmull-Clark subdivision point.">SubdivisionPoint()</a> or <a class="el" href="class_o_n___sub_d_edge.html#a7ea7baa19f274de7add6e8ee0b35f4a0">GetSubdivisionPoint()</a>. Parameters: subdivision_point - [out] The edge Catmull-Clark subdivision point is returned here. </p>

</div>
</div>
<a id="a8592d30879261a1160496d215323d2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8592d30879261a1160496d215323d2aa">&#9670;&nbsp;</a></span>Face()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubDEdge::Face </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12954b267fa3277a943307107ca60a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12954b267fa3277a943307107ca60a99">&#9670;&nbsp;</a></span>FaceArrayIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::FaceArrayIndex </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a891442a7bf771171857e0d42df559fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891442a7bf771171857e0d42df559fe3">&#9670;&nbsp;</a></span>FaceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::FaceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a473fbe9cf0b2d28be3be3cfd3bd19600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473fbe9cf0b2d28be3be3cfd3bd19600">&#9670;&nbsp;</a></span>FaceDirection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON__UINT_PTR ON_SubDEdge::FaceDirection </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab01b69c9628c4a789706cb1f0b260cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab01b69c9628c4a789706cb1f0b260cc3">&#9670;&nbsp;</a></span>FacePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> ON_SubDEdge::FacePtr </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acca2724ec87f244161e085f509da10c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca2724ec87f244161e085f509da10c5">&#9670;&nbsp;</a></span>FacePtrFromFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> ON_SubDEdge::FacePtrFromFace </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68b7ae6eaa743f2ee168974eeb4f6728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b7ae6eaa743f2ee168974eeb4f6728">&#9670;&nbsp;</a></span>FromVertices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubDEdge::FromVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a45a408853d5404b15cb741f0711d6990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a408853d5404b15cb741f0711d6990">&#9670;&nbsp;</a></span>FromVertices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubDEdge::FromVertices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoreOrientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: vertex0 - [in] vertex1 - [in] bIgnoreOrientation - [in] If false, then the returned edge must have vertices (vertex0, vertex1). If true, then the returned edge may have vertices (vertex0, vertex1) or (vertex1, vertex0). Returns: If an edge connects the input vertices, it is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="a58c56b3e8ce2e309c49c89fd221e7924"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c56b3e8ce2e309c49c89fd221e7924">&#9670;&nbsp;</a></span>GetCenterPointAndNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::GetCenterPointAndNormal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>subd_appearance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_face_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af755a31081437967b8a968450880087a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af755a31081437967b8a968450880087a">&#9670;&nbsp;</a></span>GetEdgeSurfaceCurveControlPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::GetEdgeSurfaceCurveControlPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *&#160;</td>
          <td class="paramname"><em>cvs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cv_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: cvs - [out] cv_capacity - [in] Capacity of cvs[] array. Pass 0 if you want this function to return the minimum required capacity for this edge without setting cvs. Returns: 0 - failed. &gt;= 4: Number of cvs for a cubic uniform nonrational NURBS curve with (cv_count+2) knots = (-2,-1,0,1,2,3,4,5,6,7,8,9,10). </p>

</div>
</div>
<a id="afab31b6d7626a2353e28c330eaa56ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab31b6d7626a2353e28c330eaa56ae0">&#9670;&nbsp;</a></span>GetSectorBoundaryEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::GetSectorBoundaryEdges </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_vertex_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edge_ptr0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edge_ptr1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge_vertex_index - [in] 0 or 1 edge_ptr0 - [out] edge_ptr1 - [out] Crease edges that bound the sector containing this edge. The direction value of the edge pointer identifies the end of the sector boundary edge this-&gt;at m_vertex[edge_vertex_index]. Returns: Number of faces in the sector. </p>

</div>
</div>
<a id="a73ca3e52bcdbfb9702ad062770e95562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ca3e52bcdbfb9702ad062770e95562">&#9670;&nbsp;</a></span>GetSharpSubdivisionPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDEdge::GetSharpSubdivisionPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>sharp_subdivision_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the edge's sharp subdivision point and returns the average of the edge's sharpnesses. The final subdivision point is (sharpness &gt;= 1.0) ? sharp_subdivision_point : (1.0-sharpness)(smooth subdivsion point)+sharpness*sharp_subdivision_point. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sharp_subdivision_point</td><td>If the returned sharpness is &gt; 0, then the sharp subdivision point (=edge-&gt;<a class="el" href="class_o_n___sub_d_edge.html#ad496d3ccc3b80eb19708481e1c09be03">ControlNetCenterPoint()</a>) is returned. Otherwise <a class="el" href="class_o_n__3d_point.html#a431f63a983b61e62251c3ebb37d851ff" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_3dPoint::NanPoint</a> is returned.</td></tr>
  </table>
  </dd>
</dl>
<p>The relationship between <br  />
 3d point C = ordinary Catmull-Clark edge subdivision point, 3d point P = sharp_subdivision_point, s = this-&gt;GetSharpSubdivisionPoint(P), and 3d point E = this-&gt;<a class="el" href="class_o_n___sub_d_edge.html#afed6d6b653ab5160c8f904fabe0eae4e" title="Get the SubD edge Catmull-Clark subdivision point.">SubdivisionPoint()</a> is E = (s &gt;= 1.0) ? P : ((s &gt; 0.0) ? (s*P + (1-s)*C) : C);</p>
<p>NOTE WELL: when the returned value is zero, S is <a class="el" href="class_o_n__3d_point.html#a431f63a983b61e62251c3ebb37d851ff" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_3dPoint::NanPoint</a> and any calculation using S will results in nans. </p>
<dl class="section return"><dt>Returns</dt><dd>If the edge is sharp, a value &gt; 0 and &lt; <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a17dfa16a846971eee9f0646fc0005919" title="ON_SubDEdgeSharpness::MaximumValue = 4. SubD edge sharpness values are &lt;= ON_SubDEdgeSharpness::Maxim...">ON_SubDEdgeSharpness::MaximumValue</a> is returned. Otherwise 0.0 is returned and sharp_subdivision_point = <a class="el" href="class_o_n__3d_point.html#a431f63a983b61e62251c3ebb37d851ff" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_3dPoint::NanPoint</a>. </dd></dl>

</div>
</div>
<a id="a7ea7baa19f274de7add6e8ee0b35f4a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea7baa19f274de7add6e8ee0b35f4a0">&#9670;&nbsp;</a></span>GetSubdivisionPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::GetSubdivisionPoint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>subdivision_point</em>[3]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: subdivision_point - [out] Returns: true if successful </p>

</div>
</div>
<a id="acf5bad0053b25b6633812aaed36bcbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf5bad0053b25b6633812aaed36bcbd3">&#9670;&nbsp;</a></span>GetSurfaceCenterPointAndNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::GetSurfaceCenterPointAndNormal </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_face_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>N</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the limit surface point location and normal for the edge's midpoint from the limit mesh grid. Parameters: edge - [in] An edge in this SubD. edge_face_index - [in] Index of the face to use for the normal. If the edge is a crease, then each attached face may have a different normal. Pass 0 when in doubt. P - [out] P = limit surface location or <a class="el" href="class_o_n__3d_point.html#a431f63a983b61e62251c3ebb37d851ff" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_3dPoint::NanPoint</a> if not available. N - [out] N = limit surface unit normal or <a class="el" href="class_o_n__3d_vector.html#a2bb705b5d7458947109344fe28460228" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_3dVector::NanVector</a> if not available. Returns: True if the point and normal were set from the limit mesh fragment. False if the limit mesh fragment was not found and nan values were returned. Remarks: Requires information created by <a class="el" href="class_o_n___sub_d.html#a6abc8cfa298276013a6a7b80bd911dd6">ON_SubD::UpdateSurfaceMeshCache()</a> </p>

</div>
</div>
<a id="a37fb817bd091611587df4d4473036d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fb817bd091611587df4d4473036d91">&#9670;&nbsp;</a></span>GetSurfaceMeshFragmentPoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::GetSurfaceMeshFragmentPoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>P_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Gets the limit esh fragment points for the edge. Parameters: P_capacity - [in] If input 0 = P_capacity, the required capacity is returned, otherwise P_capacity is the capacity of the P[] array P - [out] When P_capacity &gt; 0, the points are returned here. Returns: Number of returned points (0,2,5,5,9,17,33,65) </p>

</div>
</div>
<a id="aeb304f5fc1e43597c826e7e693e56b21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb304f5fc1e43597c826e7e693e56b21">&#9670;&nbsp;</a></span>HasBoundaryEdgeTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::HasBoundaryEdgeTopology </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: bRequireSameFaceOrientation - [in] If true, the attached faces must use the edge with opposite directions (oriented manifold). Returns: True if the edge has two distinct faces. </p>

</div>
</div>
<a id="a57d5cf1dfc9012c17e8ca187e4ae29d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d5cf1dfc9012c17e8ca187e4ae29d9">&#9670;&nbsp;</a></span>HasInteriorEdgeTopology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::HasInteriorEdgeTopology </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bRequireOppositeFaceDirections</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: bRequireSameFaceOrientation - [in] If true, the attached faces must use the edge with opposite directions (oriented manifold). Returns: True if the edge has two distinct faces. </p>

</div>
</div>
<a id="ad581f738f09075c57685627e332a6a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad581f738f09075c57685627e332a6a15">&#9670;&nbsp;</a></span>IsCrease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsCrease </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>. </p>

</div>
</div>
<a id="af7e8650e9641e43b29478ca97f329bac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7e8650e9641e43b29478ca97f329bac">&#9670;&nbsp;</a></span>IsCreaseOrSharp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsCreaseOrSharp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Crease edges have tag = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>. Sharp edges have tag = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> or <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a> and have nonzero sharpness. </p>
<dl class="section return"><dt>Returns</dt><dd>(this-&gt;<a class="el" href="class_o_n___sub_d_edge.html#ad581f738f09075c57685627e332a6a15">IsCrease()</a> || this-&gt;<a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">IsSharp()</a>).</dd></dl>

</div>
</div>
<a id="a8e37ee86eb61bbb40bd8e7d9cffd75ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e37ee86eb61bbb40bd8e7d9cffd75ab">&#9670;&nbsp;</a></span>IsDartCrease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsDartCrease </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a> and at least one of its end vertices are tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a35900d987289a83af101d18a9f7c3501">ON_SubDVertexTag::Dart</a>. </p>

</div>
</div>
<a id="af9c296a2fe8dfceb35a8767675971265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9c296a2fe8dfceb35a8767675971265">&#9670;&nbsp;</a></span>IsHardCrease()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsHardCrease </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a> and both of its end vertices are tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDVertexTag::Crease</a>, or <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a>. </p>

</div>
</div>
<a id="a8e07c79ca0374a1f0d7dea35f79f7e93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e07c79ca0374a1f0d7dea35f79f7e93">&#9670;&nbsp;</a></span>IsSharp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsSharp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous normal along a sharp edge. A sharp edge has a smooth tag, has sharpness &gt; 0 at at least one end, and has sharpness &lt; <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a17dfa16a846971eee9f0646fc0005919" title="ON_SubDEdgeSharpness::MaximumValue = 4. SubD edge sharpness values are &lt;= ON_SubDEdgeSharpness::Maxim...">ON_SubDEdgeSharpness::MaximumValue</a> at at least one end. Sharpness has no meaning for edges with crease tags. Both sharpness values are zero for an ordinary smooth edge. Edge sharpness steadily decreases during subdivision and becomes zero after at most <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a17dfa16a846971eee9f0646fc0005919" title="ON_SubDEdgeSharpness::MaximumValue = 4. SubD edge sharpness values are &lt;= ON_SubDEdgeSharpness::Maxim...">ON_SubDEdgeSharpness::MaximumValue</a> subdivisions. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the edge is tagged as smooth, and has at least one end with sharpness &gt; 0 and &lt; <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a17dfa16a846971eee9f0646fc0005919" title="ON_SubDEdgeSharpness::MaximumValue = 4. SubD edge sharpness values are &lt;= ON_SubDEdgeSharpness::Maxim...">ON_SubDEdgeSharpness::MaximumValue</a>. </dd></dl>

</div>
</div>
<a id="aacf1f7d04647417e403311dd4972e07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf1f7d04647417e403311dd4972e07f">&#9670;&nbsp;</a></span>IsSmooth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsSmooth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> or <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a>. False in all other cases. </p>

</div>
</div>
<a id="a6c791230ec5f328b6919b185cf9c2069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c791230ec5f328b6919b185cf9c2069">&#9670;&nbsp;</a></span>IsSmoothNotSharp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsSmoothNotSharp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if an edge is smooth and is not sharp. </p>
<dl class="section return"><dt>Returns</dt><dd>(true == <a class="el" href="class_o_n___sub_d_edge.html#aacf1f7d04647417e403311dd4972e07f">IsSmooth()</a> and false == <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">IsSharp()</a>)</dd></dl>

</div>
</div>
<a id="a1fb31978402e8b31c96cbaf84913f11a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb31978402e8b31c96cbaf84913f11a">&#9670;&nbsp;</a></span>IsSmoothNotX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsSmoothNotX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a>. Remarks: Expert user function. This is used in rare cases when level 0 edges tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a> need special handling in low level evaluation code. Typical SDK level functions and anything related to runtime user interface should call <a class="el" href="class_o_n___sub_d_edge.html#aacf1f7d04647417e403311dd4972e07f">IsSmooth()</a>. </p>

</div>
</div>
<a id="abd244d774f43e3e21912ae4cb748bae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd244d774f43e3e21912ae4cb748bae5">&#9670;&nbsp;</a></span>IsSmoothNotXNotSharp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsSmoothNotXNotSharp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>An expert user function to determine if an edge tag in <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> and is not sharp. </p>
<dl class="section return"><dt>Returns</dt><dd>(true == <a class="el" href="class_o_n___sub_d_edge.html#a1fb31978402e8b31c96cbaf84913f11a">IsSmoothNotX()</a> and false == <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">IsSharp()</a>)</dd></dl>

</div>
</div>
<a id="a922333803c8a1716d311167aeeb03bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922333803c8a1716d311167aeeb03bc7">&#9670;&nbsp;</a></span>IsSmoothX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::IsSmoothX </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a>. Remarks: Expert user function. This is used in rare cases when level 0 edges tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a> need special handling in low level evaluation code. Typical SDK level functions and anything related to runtime user interface should call <a class="el" href="class_o_n___sub_d_edge.html#aacf1f7d04647417e403311dd4972e07f">IsSmooth()</a>. An edge tagged as "X" can occur at level 0. It is subdivided as a smooth vertex and both of its end vertices are tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDVertexTag::Crease</a>, <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a>, or <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a35900d987289a83af101d18a9f7c3501">ON_SubDVertexTag::Dart</a>. This tag cannot appear at level N with N &gt;= 1. </p>

</div>
</div>
<a id="a498de0efe96602adeaa29d67ba5b662f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498de0efe96602adeaa29d67ba5b662f">&#9670;&nbsp;</a></span>MarkedFaceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::MarkedFaceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Number of faces attached to this edge with <a class="el" href="class_o_n___sub_d_edge.html#a8592d30879261a1160496d215323d2aa">Face()</a>.m_status.RuntimeMark() = true; </p>

</div>
</div>
<a id="aec914ba987c62679972d5d2d4448f5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec914ba987c62679972d5d2d4448f5b4">&#9670;&nbsp;</a></span>MarkedVertexCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::MarkedVertexCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Number of end vertices with <a class="el" href="class_o_n___sub_d_edge.html#a7da052ac2aa20a285dea413819cedcba">Vertex()</a>.m_status.RuntimeMark() = true; </p>

</div>
</div>
<a id="a14bd8d63d2866e5c3cd796ebffe8b8d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14bd8d63d2866e5c3cd796ebffe8b8d4">&#9670;&nbsp;</a></span>NeighborFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubDEdge::NeighborFace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStopAtCrease</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Return the neighboring face. Parameters: face - [in] A face referenced in the edge's m_face2[] array. bStopAtCrease - [in] If true and if m_edge_tag = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>, then nullptr is returned. Returns: If the m_face_count = 2, m_edge_tag is smooth or x or passes the crease tag test, one of m_face2[0,1] points a face, then the neighboring face is returned. In any other case, nullptr is returned. </p>

</div>
</div>
<a id="a03aed478fccb34a0d1b0285e4cb97aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03aed478fccb34a0d1b0285e4cb97aa2">&#9670;&nbsp;</a></span>NeighborFacePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> ON_SubDEdge::NeighborFacePtr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bStopAtCrease</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Return the neighboring face. Parameters: face - [in] A face referenced in the edge's m_face2[] array. bStopAtCrease - [in] If true and if m_edge_tag = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>, then nullptr is returned. Returns: If the m_face_count = 2, m_edge_tag is smooth or x or passes the crease tag test, one of m_face2[0,1] points a face, then the neighboring face is returned. In any other case, <a class="el" href="class_o_n___sub_d_face_ptr.html#abe08e4603fa0ecf78d665b287b443684">ON_SubDFacePtr::Null</a> is returned. </p>

</div>
</div>
<a id="ac4e90a2ee7cac094d2d1376a8c9bb2b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e90a2ee7cac094d2d1376a8c9bb2b3">&#9670;&nbsp;</a></span>NeighborhoodStatusLogicalOr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> ON_SubDEdge::NeighborhoodStatusLogicalOr </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: bIncludeVertices - [in] If true, then attached vertices are included. bIncludeFaces - [in] If true, then attached faces are included. Returns: A ON_ComponentStatusLogicalOr() of this vertex's status and the specified attached components. See Also: <a class="el" href="class_o_n___sub_d_component_base.html#ab2b9d765362542e4f45c5a98e4cc9ab8">ON_SubDComponentBase::Status()</a> </p>

</div>
</div>
<a id="aab929540d1ceafc874111cb4b6046573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab929540d1ceafc874111cb4b6046573">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>&amp; ON_SubDEdge::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5256f191e01725498f3641b652645a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5256f191e01725498f3641b652645a8">&#9670;&nbsp;</a></span>OtherEndVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubDEdge::OtherEndVertex </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Return the vertex at the other end of the edge. Parameters: vertex - [in] A vertex referenced in the edge's m_vertex[] array. Returns: If vertex is not nullptr and exactly one of m_vertex[] is equal to vertex, then the other m_vertex[] pointer is returned. In any other case, nullptr is returned. See Also: <a class="el" href="class_o_n___sub_d_edge.html#a14bd8d63d2866e5c3cd796ebffe8b8d4">ON_SubDEdge.NeighborFace()</a> </p>

</div>
</div>
<a id="ae7fafe41b0fed7f544698d8aee234e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7fafe41b0fed7f544698d8aee234e2f">&#9670;&nbsp;</a></span>PointAt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_SubDEdge::PointAt </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>normalized_edge_parameter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>subd_appearance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f3ecdc83cd8f5f815a8e496aeb2bb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3ecdc83cd8f5f815a8e496aeb2bb14">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubDEdge::Read </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&amp;&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adb666f91f52f1b93d454a94ac223ec85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb666f91f52f1b93d454a94ac223ec85">&#9670;&nbsp;</a></span>RemoveFaceFromArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::RemoveFaceFromArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to remove a face from the edges's face array. Remarks: Does not modify the face. If the edge is referenced in the face's edge array, then the edge must be removed from the face's edge array. </p>

</div>
</div>
<a id="a260640a13947a2a5ad900881b5605b15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a260640a13947a2a5ad900881b5605b15">&#9670;&nbsp;</a></span>RemoveFaceFromArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::RemoveFaceFromArray </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>removed_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to remove a face from the edges's face array. Remarks: Does not modify the face. If the edge is referenced in the face's edge array, then the edge must be removed from the face's edge array. </p>

</div>
</div>
<a id="ac07295fb1f7c855656c6ede2a5b7f431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07295fb1f7c855656c6ede2a5b7f431">&#9670;&nbsp;</a></span>ReplaceFaceInArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::ReplaceFaceInArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>old_face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>new_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to replace reference to old_face with a reference to new_face. Existing orientation is copied. No changes are made to old_face and new_face and their edge references must be updated accordingly. Parameters: old_face = [in] Cannot be nullptr. new_face = [in] If new_face is nullptr, old_face is simply removed. Returns: If the replacement was successful, then the m_faces[] array index where old_face/new_face replacement occurred is returned. Otherwise ON_UNSET_UINT_INDEX is returned. Remarks: No modifications are made to old_face or new_face. </p>

</div>
</div>
<a id="ace6cd7db533e32770cb0c1d7100a6fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6cd7db533e32770cb0c1d7100a6fa2">&#9670;&nbsp;</a></span>SetSharpnessForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubDEdge::SetSharpnessForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_sharpness.html">ON_SubDEdgeSharpness</a>&#160;</td>
          <td class="paramname"><em>sharpness</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This tool is for expert users and internal use. A collection of <a class="el" href="class_o_n___sub_d.html#a9c89462e3815d30c507e98b920b18f18" title="Set or change edge sharpness.">ON_SubD::SetEdgeSharpness()</a> functions provide the easiest way to set and change edge sharpness. Set the edge sharpness values to (sharpness[0],sharpness[1]). The interval values must be &gt;= 0 and &lt;= <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a17dfa16a846971eee9f0646fc0005919" title="ON_SubDEdgeSharpness::MaximumValue = 4. SubD edge sharpness values are &lt;= ON_SubDEdgeSharpness::Maxim...">ON_SubDEdgeSharpness::MaximumValue</a>. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sharpness</td><td>End sharpenss values.</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae960d5f6e322786e65212719c147b42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae960d5f6e322786e65212719c147b42b">&#9670;&nbsp;</a></span>Sharpness()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge_sharpness.html">ON_SubDEdgeSharpness</a> ON_SubDEdge::Sharpness </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseCreaseSharpness</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge's sharpness. See <a class="el" href="class_o_n___sub_d_edge.html#a8e07c79ca0374a1f0d7dea35f79f7e93" title="Sharp edges are a blend between smooth edges and crease edges. The limit surface has a continuous nor...">ON_SubDEdge::IsSharp()</a> for more information about sharp edges. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bUseCreaseSharpness</td><td>If the edge is a crease and bUseCreaseSharpness is false, then <a class="el" href="class_o_n___sub_d_edge_sharpness.html#ac450c47da4dfa105cbb4d22654637da9" title="An edge sharpness with contant value 0.0.">ON_SubDEdgeSharpness::Smooth</a> is returned. If the edge is a crease and bUseCreaseSharpness is true, then <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a16c5939cc1a9f6d6f579fa0199b9cc9a" title="An edge sharpness with both end values = ON_SubDEdgeSharpness::CreaseValue. This value is not a valid...">ON_SubDEdgeSharpness::Crease</a> is returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the edge is smooth, then the sharpness property is returned. If the edge is a crease and bUseCreaseSharpness is true, then <a class="el" href="class_o_n___sub_d_edge_sharpness.html#a16c5939cc1a9f6d6f579fa0199b9cc9a" title="An edge sharpness with both end values = ON_SubDEdgeSharpness::CreaseValue. This value is not a valid...">ON_SubDEdgeSharpness::Crease</a> is returned. In all other cases, <a class="el" href="class_o_n___sub_d_edge_sharpness.html#ac450c47da4dfa105cbb4d22654637da9" title="An edge sharpness with contant value 0.0.">ON_SubDEdgeSharpness::Smooth</a> is returned. </dd></dl>

</div>
</div>
<a id="af4746461e384760dbf9aa2740e344c92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4746461e384760dbf9aa2740e344c92">&#9670;&nbsp;</a></span>SubdivideSharpness() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge_sharpness.html">ON_SubDEdgeSharpness</a> ON_SubDEdge::SubdivideSharpness </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>end_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReverseSharpness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge sharpenss values for the subdivided edge at the specified end of this edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end_vertex</td><td>One of this edge's vertices used to select the subdivided edge.</td></tr>
    <tr><td class="paramname">bReverseSharpness</td><td>Pass true if this edge and the subdividied edge will have opposite orientations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Edge sharpness for the subdivided edge.</dd></dl>

</div>
</div>
<a id="acd34ae348ddb3c403b658bc8504426b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd34ae348ddb3c403b658bc8504426b4">&#9670;&nbsp;</a></span>SubdivideSharpness() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge_sharpness.html">ON_SubDEdgeSharpness</a> ON_SubDEdge::SubdivideSharpness </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>evi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bReverseSharpness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge sharpenss values for the subdivided edge at the specified end of this edge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">evi</td><td>Selects the subdivided edge (0 for the left subdivided edge, 1 for the right subdivided edge) </td></tr>
    <tr><td class="paramname">bReverseSharpness</td><td>Pass true if this edge and the subdividied edge will have opposite orientations. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Edge sharpness for the subdivided edge.</dd></dl>

</div>
</div>
<a id="afed6d6b653ab5160c8f904fabe0eae4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed6d6b653ab5160c8f904fabe0eae4e">&#9670;&nbsp;</a></span>SubdivisionPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_SubDEdge::SubdivisionPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the SubD edge Catmull-Clark subdivision point. </p>
<dl class="section return"><dt>Returns</dt><dd>Catmull-Clark edge subdivision point.</dd></dl>

</div>
</div>
<a id="a8d21d35f9472f5d978bab03757e5ce87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d21d35f9472f5d978bab03757e5ce87">&#9670;&nbsp;</a></span>SurfaceBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> ON_SubDEdge::SurfaceBoundingBox </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad37f11787eac0b734b5bf1f1902dcbe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37f11787eac0b734b5bf1f1902dcbe0">&#9670;&nbsp;</a></span>SurfaceCenterNormal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> ON_SubDEdge::SurfaceCenterNormal </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_face_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the limit surface point location and normal for the edge's midpoint from the limit mesh grid. Parameters: edge - [in] An edge in this SubD. edge_face_index - [in] Index of the face to use for the normal. If the edge is a crease, then each attached face may have a different normal. Pass 0 when in doubt. Returns: A unit normal or <a class="el" href="class_o_n__3d_vector.html#a2bb705b5d7458947109344fe28460228" title="(ON_DBL_QNAN,ON_DBL_QNAN,ON_DBL_QNAN)">ON_3dVector::NanVector</a> if information is not available. Remarks: Requires information created by <a class="el" href="class_o_n___sub_d.html#a6abc8cfa298276013a6a7b80bd911dd6">ON_SubD::UpdateSurfaceMeshCache()</a> </p>

</div>
</div>
<a id="a5e8443a219d753d64822338aa92cf3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8443a219d753d64822338aa92cf3a4">&#9670;&nbsp;</a></span>SurfaceCenterPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> ON_SubDEdge::SurfaceCenterPoint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac40157addc45a5da376c62f90ce6da71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac40157addc45a5da376c62f90ce6da71">&#9670;&nbsp;</a></span>TaggedEndIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::TaggedEndIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Set bTagged[i] = m_vertex[0]-&gt;IsDartOrCreaseOrCorner(). 0: bTagged[0] is true and bTagged[1] is false. 1: bTagged[0] is false and bTagged[1] is true. 2: bTagged[0] and Tagged[1] are both true. 3: bTagged[0] and Tagged[1] are both false. </p>

</div>
</div>
<a id="a7b28c68850328ecacd21d85249ff2b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b28c68850328ecacd21d85249ff2b0b">&#9670;&nbsp;</a></span>TopologyCRC32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga7bc5f55fc24151607737806fdb29668d">ON__UINT32</a> ON_SubDEdge::TopologyCRC32 </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeSubdivisionProperties</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a 32 bit CRC that is useful in detecting when an edge's connections to attached vertices or faces have been changed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIncludeSubdivisionProperties</td><td>Pass true if you want to include nontopological subdivision properties (tags, sharpnesses, control net points) that help determine the edge's subdivision point in the CRC. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 32 bit CRC = this-&gt;TopologyHash(bIncludeSubdivisionProperties).CRC32(0). </dd></dl>

</div>
</div>
<a id="a87e684e9ef1d695d21cb6aed8388b2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e684e9ef1d695d21cb6aed8388b2bd">&#9670;&nbsp;</a></span>TopologyHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubDEdge::TopologyHash </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeSubdivisionProperties</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a SHA-1 hash that is useful in detecting when an edge's connections to attached vertices or faces have been changed. See also <a class="el" href="class_o_n___sub_d_edge.html#a7b28c68850328ecacd21d85249ff2b0b" title="Get a 32 bit CRC that is useful in detecting when an edge&#39;s connections to attached vertices or faces...">ON_SubDEdge::TopologyCRC32()</a> which, in practice, is just as reliable as the hash. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bIncludeSubdivisionProperties</td><td>Pass true if you want to include nontopological subdivision properties (tags, sharpnesses, control net points) that help determine the edge's subdivision point in the hash. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A SHA-1 hash of the edge's id and the ids of the vertices and faces attached to this edge. </dd></dl>

</div>
</div>
<a id="ad68f7b27426bee58638b3a63711933e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68f7b27426bee58638b3a63711933e7">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::Transform </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bTransformationSavedSubdivisionPoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Apply a tranxfomration matrix to vertex geometry information.</p>
<p>Parameters: bTransformationSavedSubdivisionPoint - [in] If the transformation is being applied to every vertex, edge and face in every level of a subdivision object, and the transformation is an orientation preserving isometry (rotation, translation, ...), then set bTransformationSavedSubdivisionPoint = true to apply the transformation to saved subdivision and saved limit point information. In all other cases, set bTransformationSavedSubdivisionPoint = false and any saved subdivision points or saved limit points will be deleted. When in doubt, pass false.</p>
<p>xform - [in] </p>

</div>
</div>
<a id="a739e7762a1d631e2a9802003352736ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739e7762a1d631e2a9802003352736ac">&#9670;&nbsp;</a></span>UnsetSectorCoefficientsForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubDEdge::UnsetSectorCoefficientsForExperts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to unset sector coefficients. </p>

</div>
</div>
<a id="a02cf37ae4aaa2f0d679da0e3ad975d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02cf37ae4aaa2f0d679da0e3ad975d81">&#9670;&nbsp;</a></span>UpdateEdgeSectorCoefficientsForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::UpdateEdgeSectorCoefficientsForExperts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUnsetEdgeSectorCoefficientsOnly</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to set mutable sector coefficients. Returns: True if values were modified. </p>

</div>
</div>
<a id="a7da052ac2aa20a285dea413819cedcba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da052ac2aa20a285dea413819cedcba">&#9670;&nbsp;</a></span>Vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubDEdge::Vertex </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>evi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: evi - [in] 0 or 1 Returns: If evi is 0 or 1, then m_vertex[evi] is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="ab3623c06a981519b19942944a593611e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3623c06a981519b19942944a593611e">&#9670;&nbsp;</a></span>VertexArrayIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::VertexArrayIndex </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af18506d55a9d8350ed317d96de9ff88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af18506d55a9d8350ed317d96de9ff88b">&#9670;&nbsp;</a></span>VertexCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::VertexCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Number of distinct non-nullptr vertices. If the edge is valid, this will be 2. </p>

</div>
</div>
<a id="ac95b0602eb28359b5eab984ff179cb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac95b0602eb28359b5eab984ff179cb20">&#9670;&nbsp;</a></span>VertexId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDEdge::VertexId </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>evi</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: evi - [in] 0 or 1 Returns: If evi is 0 or 1 and m_vertex[evi] is not nullptr, then m_vertex[evi]-&gt;m_id is returned. Otherwise 0 i returned. </p>

</div>
</div>
<a id="a94917b6e0954cae0871e0168dce82185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94917b6e0954cae0871e0168dce82185">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDEdge::Write </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a9a9e907686d639ecb6a4fa92d4fecc89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a9e907686d639ecb6a4fa92d4fecc89">&#9670;&nbsp;</a></span>ON_Internal_SubDFaceMeshFragmentAccumulator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ON_Internal_SubDFaceMeshFragmentAccumulator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a662beea9e0e441b2ee0687d460fad204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662beea9e0e441b2ee0687d460fad204">&#9670;&nbsp;</a></span>ON_SubDArchiveIdMap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ON_SubDArchiveIdMap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5778abbf09c0ca77d0845ad5da4ea44f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5778abbf09c0ca77d0845ad5da4ea44f">&#9670;&nbsp;</a></span>ON_SubDFace</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4c1bf700fda49776b4f7d456fe3b29ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1bf700fda49776b4f7d456fe3b29ed">&#9670;&nbsp;</a></span>ON_SubDHeap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class ON_SubDHeap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf54cfdafac807e154137f737ccb4573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf54cfdafac807e154137f737ccb4573">&#9670;&nbsp;</a></span>ON_SubDVertex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0366b0f548345598c3ba49e75997bc53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0366b0f548345598c3ba49e75997bc53">&#9670;&nbsp;</a></span>Empty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> ON_SubDEdge::Empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1398e0a19c67627d7c9d0dac25c6da35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1398e0a19c67627d7c9d0dac25c6da35">&#9670;&nbsp;</a></span>m_edge_tag</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> ON_SubDEdge::m_edge_tag = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When checking the edge tag, it is important to consider what should happen in the <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a> case. It is strongly suggested that you use the member functions <a class="el" href="class_o_n___sub_d_edge.html#aacf1f7d04647417e403311dd4972e07f">ON_SubDEdge::IsSmooth()</a> and <a class="el" href="class_o_n___sub_d_edge.html#ad581f738f09075c57685627e332a6a15">ON_SubDEdge::IsCrease()</a> instead of comparing m_edge_tag to ON_SubDEdgeTag values. </p>

</div>
</div>
<a id="ad0278804e5eb3aeecd36fa3528037f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0278804e5eb3aeecd36fa3528037f96">&#9670;&nbsp;</a></span>m_face2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> ON_SubDEdge::m_face2[2] = {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5648ad718190be78e5b8d19a687b5a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5648ad718190be78e5b8d19a687b5a77">&#9670;&nbsp;</a></span>m_face_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short ON_SubDEdge::m_face_count = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86d39667e1772862c74e90b3603f76d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d39667e1772862c74e90b3603f76d8">&#9670;&nbsp;</a></span>m_facex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a>* ON_SubDEdge::m_facex = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8bb93838516d8ebc184cf9f05340ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8bb93838516d8ebc184cf9f05340ef5">&#9670;&nbsp;</a></span>m_facex_capacity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short ON_SubDEdge::m_facex_capacity = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afd2efb5803454c2376f1d37383334e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd2efb5803454c2376f1d37383334e0a">&#9670;&nbsp;</a></span>m_next_edge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubDEdge::m_next_edge = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>linked list of edges on this level </p>

</div>
</div>
<a id="a7eff580f9f83fcaeee98ba92afd8dab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eff580f9f83fcaeee98ba92afd8dab4">&#9670;&nbsp;</a></span>m_prev_edge</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubDEdge::m_prev_edge = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>m_prev_edge, m_next_edge must be the first data members of <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> </p>
<p>linked list of edges on this level </p>

</div>
</div>
<a id="ad0c9de427fb1f2eddb3fcabef63fb1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0c9de427fb1f2eddb3fcabef63fb1a5">&#9670;&nbsp;</a></span>m_sector_coefficient</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDEdge::m_sector_coefficient[2] = {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>NOTE: The sector coefficient is a property of a smooth edge end that is constant throughout subdivision. It exists at ends of smooth edges that are attached to dart, crease, or corner vertices. In all other cases the sector coefficient is ignored. In particular crease edges and the ends of smooth edges attached to smooth vertices do not have a sector coefficient.</p>
<p>The <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> class provides three static functions that calculate sector coefficients: <a class="el" href="class_o_n___sub_d_sector_type.html#a53d8c5360e6b2546670cc7cc7acab873">ON_SubDSectorType::DartSectorCoefficient()</a> <a class="el" href="class_o_n___sub_d_sector_type.html#a79b7a3cac6981aa57104e18e371ea6fb">ON_SubDSectorType::CreaseSectorCoefficient()</a> <a class="el" href="class_o_n___sub_d_sector_type.html#a5f5ac5434aed9d168a7ec38309a9f582">ON_SubDSectorType::CornerSectorCoefficient()</a></p>
<p>If the value of vertex-&gt;m_vertex_tag is not <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375ae510cdf33cd497134b47b9316314d4b4">ON_SubDVertexTag::Smooth</a>, then that vertex is "tagged".</p>
<p>If the value of m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>, then m_sector_coefficient[] should be {0,0}. <br  />
 In any case m_sector_coefficient[] values are ignored and the midpoint of the edge is the location of the edge.s subdivision point. The edge's subdivision vertex will be tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDVertexTag::Crease</a> and both subdivision edges will be tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>.</p>
<p>If the value of m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> and neither end vertex is tagged, then m_sector_coefficient[] should be {0,0}. <br  />
 In any case m_sector_coefficient[] values are ignored on smooth edges with smooth vertices at both ends. The edge's subdivision vertex will be tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375ae510cdf33cd497134b47b9316314d4b4">ON_SubDVertexTag::Smooth</a> and both subdivision edges will be tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a>.</p>
<p>If the value of m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> and exactly one end vertex is tagged, then the m_sector_coefficient[] value for the tagged end is calculated by <a class="el" href="class_o_n___sub_d_sector_type.html#afbd772f9fe85152a75653006b69fde71">ON_SubDSectorType::SectorCoefficient()</a>. tagged_coefficient*tagged_vertex + (1.0 - tagged_coefficient)*untagged_vertex is used when combining the edge ends. The edge's subdivision vertex will be tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375ae510cdf33cd497134b47b9316314d4b4">ON_SubDVertexTag::Smooth</a> and both subdivision edges will be tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a>.</p>
<p>If the value of m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a>, then the edge must have exactly two neighboring faces, both vertices must be tagged and the m_sector_coefficient[] values are calculated by <a class="el" href="class_o_n___sub_d_sector_type.html#afbd772f9fe85152a75653006b69fde71">ON_SubDSectorType::SectorCoefficient()</a>. When the edge is subdivided, the midpoint of the edge is the location of the edge.s subdivision point. The edge's subdivision vertex will be tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375ae510cdf33cd497134b47b9316314d4b4">ON_SubDVertexTag::Smooth</a> and both subdivision edges will be tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a>.</p>
<p>If the value of m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> and both end vertices are tagged, that is a severe error condition and the edge is subdivided at its midpoint.</p>
<p>If the value of m_edge_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a> and both end vertices are not tagged, that is a severe error condition and the edge is subdivided at its midpoint.</p>
<p>m_sector_coefficient[tagged_end] = 1/2 + 1/3*cos(theta_k) where "theta_k" is the tagged end's "theta_k", which depends on the vertex tag (dart/crease/corner), the number of faces k in the sector, and the control net crease angle alpha when the tagged end is a corner. Dart: theta_k = 2 * Pi / k Crease: theta_k = Pi / k Corner: theta_k = alpha / k</p>
<p>The name "sector coefficient" is used because the value is a property of the vertex's sector (every smooth edge inside a vertex sector has the same value at the tagged vertex). The sector coefficient does not change which a subdivision is applied.</p>
<hr  />
 <h2>2022-02-09, Pierre C, RH-67377 </h2>
<p>Wrong values in 3dm files created by OpenNURBS 7.16 and before, fixed in 7.17.</p>
<p>Since 2015-02-20, ON_SubDSectorType::CornerSectorThetaFromCornerAngle(unsigned int sector_face_count, double corner_sector_angle_radians) had been incorrectly computing theta as: corner_sector_theta = corner_sector_angle_radians / (2 * sector_face_count) instead of: corner_sector_theta = corner_sector_angle_radians / sector_face_count.</p>
<p>This is fixed as of Rhino 7.17, but 3dm files created before this version saved the incorrect value.</p>
<p>This changes the coefficients saved in the SubD edge, and in the 3dm files. Rhino recomputes all m_sector_coefficients cached in the SubD edges when adding a SubD to a document, so all values are now correct. This changes SubD subdivision, meshing, limit surface, and limit point editing results, for SubDs that have a smooth edge connected to a corner vertex.</p>
<p>If you are using this value from a SubD in a 3dm file created by Rhino 7.16 or earlier, without adding the SubD to a Rhino document using <a class="el" href="class_c_rhino_sub_d_object.html#ae71b0b0cad809ef4f9620baffb654904">CRhinoSubDObject::SetSubD(ON_SubDRef subd_ref)</a>, you need to recompute all sector coefficients using subd-&gt;UpdateAllTagsAndSectorCoefficients(true); </p>

</div>
</div>
<a id="ad6f4c8adb7579d436627ff40c33d6f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6f4c8adb7579d436627ff40c33d6f43">&#9670;&nbsp;</a></span>m_vertex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubDEdge::m_vertex[2] = {}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>m_vertex[0] = vertex at the start of the edge. m_vertex[1] = vertex at the end of the edge. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Mar 12 2024 16:16:23 for Rhino C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
