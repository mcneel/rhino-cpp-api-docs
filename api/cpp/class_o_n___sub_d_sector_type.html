<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_SubDSectorType Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API
   &#160;<span id="projectnumber">7.21</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_o_n___sub_d_sector_type-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_SubDSectorType Class Reference<div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_subd.h&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a177fff351cf42caf48c03f33150fe208"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: unsigned int { <a class="el" href="class_o_n___sub_d_sector_type.html#a177fff351cf42caf48c03f33150fe208a3b20401a5fa8d24a185810657a5f8237">MaximumCornerAngleIndex</a> = 72
 }</td></tr>
<tr class="separator:a177fff351cf42caf48c03f33150fe208"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad99d4a36150bd90a471dcde2db627002"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ad99d4a36150bd90a471dcde2db627002">ON_SubDSectorType</a> ()=default</td></tr>
<tr class="separator:ad99d4a36150bd90a471dcde2db627002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cc43368a5cd8b6458e6c6f7b2c8e18f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a1cc43368a5cd8b6458e6c6f7b2c8e18f">ON_SubDSectorType</a> (const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> &amp;)=default</td></tr>
<tr class="separator:a1cc43368a5cd8b6458e6c6f7b2c8e18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf1b84c4cbc7c24b3e8a717984d8cf6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a0bf1b84c4cbc7c24b3e8a717984d8cf6">ComponentRingCount</a> () const</td></tr>
<tr class="separator:a0bf1b84c4cbc7c24b3e8a717984d8cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8d76b7b95dbab5d56f146038990d24"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#aeb8d76b7b95dbab5d56f146038990d24">CornerSectorAngleIndex</a> () const</td></tr>
<tr class="separator:aeb8d76b7b95dbab5d56f146038990d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453cf2233f925170c86146cc4015448c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a453cf2233f925170c86146cc4015448c">CornerSectorAngleRadians</a> () const</td></tr>
<tr class="separator:a453cf2233f925170c86146cc4015448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f1ce2afbff2cc13a91c7917d6840326"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a7f1ce2afbff2cc13a91c7917d6840326">EdgeCount</a> () const</td></tr>
<tr class="separator:a7f1ce2afbff2cc13a91c7917d6840326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05625579c55251bf13870445e31eaabd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a05625579c55251bf13870445e31eaabd">FaceCount</a> () const</td></tr>
<tr class="separator:a05625579c55251bf13870445e31eaabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6251a86e5f394067bb8c7b3855230628"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a6251a86e5f394067bb8c7b3855230628">FacetEdgeCount</a> () const</td></tr>
<tr class="separator:a6251a86e5f394067bb8c7b3855230628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46add4a52804a1f5ce048f7514c4bbe"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ac46add4a52804a1f5ce048f7514c4bbe">GetAllEigenvalues</a> (double *eigenvalues, size_t eigenvalues_capacity)</td></tr>
<tr class="separator:ac46add4a52804a1f5ce048f7514c4bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc240f2b7e33e26d29bfad9274389cb0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#adc240f2b7e33e26d29bfad9274389cb0">GetSubdivisionMatrix</a> (double **S, size_t matrix_capacity) const</td></tr>
<tr class="separator:adc240f2b7e33e26d29bfad9274389cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af056cbb7d8ca64b57e969e3d60bdb3fb"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#af056cbb7d8ca64b57e969e3d60bdb3fb">GetSubdivisionMatrix</a> (double *S, size_t S_capacity) const</td></tr>
<tr class="separator:af056cbb7d8ca64b57e969e3d60bdb3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eae02762ef68cec847fb5ab8dca9522"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a0eae02762ef68cec847fb5ab8dca9522">GetSubdominantEigenvectors</a> (double *E1, size_t E1_capacity, double *E2, size_t E2_capacity) const</td></tr>
<tr class="separator:a0eae02762ef68cec847fb5ab8dca9522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c9834e4e1d260f763797e1ec295359"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a43c9834e4e1d260f763797e1ec295359">GetSurfaceEvaluationCoefficients</a> (double *LPev, size_t LPev_capacity, double *LT0ev, size_t LT0ev_capacity, double *LT1ev, size_t LT1ev_capacity) const</td></tr>
<tr class="separator:a43c9834e4e1d260f763797e1ec295359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf27e8ab57f8dbc403b8d7d77795e284"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#abf27e8ab57f8dbc403b8d7d77795e284">IsConcaveCornerSector</a> () const</td></tr>
<tr class="separator:abf27e8ab57f8dbc403b8d7d77795e284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a873bace6e4bb2cdb614f3e4824c4bcd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a873bace6e4bb2cdb614f3e4824c4bcd1">IsConvexCornerSector</a> () const</td></tr>
<tr class="separator:a873bace6e4bb2cdb614f3e4824c4bcd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae369f5c4af784b3319e2601c48553acc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ae369f5c4af784b3319e2601c48553acc">IsCornerSector</a> () const</td></tr>
<tr class="separator:ae369f5c4af784b3319e2601c48553acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566995d2a2b4a548bcdd48671a10994b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a566995d2a2b4a548bcdd48671a10994b">IsCreaseSector</a> () const</td></tr>
<tr class="separator:a566995d2a2b4a548bcdd48671a10994b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7260cd082d03690c13ea8b721f23824"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#aa7260cd082d03690c13ea8b721f23824">IsDartSector</a> () const</td></tr>
<tr class="separator:aa7260cd082d03690c13ea8b721f23824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f4f53b084efb1d2f6f8f8644ce4b66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a89f4f53b084efb1d2f6f8f8644ce4b66">IsSmoothSector</a> () const</td></tr>
<tr class="separator:a89f4f53b084efb1d2f6f8f8644ce4b66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a1eafd31ebc8c1b6237fc2250d67db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a58a1eafd31ebc8c1b6237fc2250d67db">IsValid</a> () const</td></tr>
<tr class="separator:a58a1eafd31ebc8c1b6237fc2250d67db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c4dcc86492ae401ee61c96c09b5274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#af7c4dcc86492ae401ee61c96c09b5274">operator=</a> (const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> &amp;)=default</td></tr>
<tr class="separator:af7c4dcc86492ae401ee61c96c09b5274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557b745fa7c6f0566db07c37f4a4ef79"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a557b745fa7c6f0566db07c37f4a4ef79">PointRingCount</a> () const</td></tr>
<tr class="separator:a557b745fa7c6f0566db07c37f4a4ef79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd772f9fe85152a75653006b69fde71"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#afbd772f9fe85152a75653006b69fde71">SectorCoefficient</a> () const</td></tr>
<tr class="separator:afbd772f9fe85152a75653006b69fde71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb9fbf626cbc5c5a873f82d0dc78e63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a3eb9fbf626cbc5c5a873f82d0dc78e63">SectorRingSubD</a> (double radius, double sector_angle_radians, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *subd) const</td></tr>
<tr class="separator:a3eb9fbf626cbc5c5a873f82d0dc78e63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878eb6eb09cf0af21adbaddcc4ba6d09"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a878eb6eb09cf0af21adbaddcc4ba6d09">SectorTypeHash</a> () const</td></tr>
<tr class="separator:a878eb6eb09cf0af21adbaddcc4ba6d09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280402ee6306d7e8e6c9164f78f67051"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a280402ee6306d7e8e6c9164f78f67051">SubdominantEigenvalue</a> () const</td></tr>
<tr class="separator:a280402ee6306d7e8e6c9164f78f67051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8e3e82300c56bc4499fb955b5765b0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#aee8e3e82300c56bc4499fb955b5765b0">SubdominantEigenvalueMulitiplicity</a> () const</td></tr>
<tr class="separator:aee8e3e82300c56bc4499fb955b5765b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce2418305a686ab9d44a8a702b2772e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a8ce2418305a686ab9d44a8a702b2772e">SurfaceEvaluationCoefficientsAvailable</a> () const</td></tr>
<tr class="separator:a8ce2418305a686ab9d44a8a702b2772e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc28bfa2da83318f2faeb44fd492aa40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#afc28bfa2da83318f2faeb44fd492aa40">SurfaceNormalSign</a> () const</td></tr>
<tr class="memdesc:afc28bfa2da83318f2faeb44fd492aa40"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___sub_d_sector_type.html#afc28bfa2da83318f2faeb44fd492aa40" title="SurfaceNormalSign() is a debugging tool - slow and not useful in general.">SurfaceNormalSign()</a> is a debugging tool - slow and not useful in general.  <a href="class_o_n___sub_d_sector_type.html#afc28bfa2da83318f2faeb44fd492aa40">More...</a><br /></td></tr>
<tr class="separator:afc28bfa2da83318f2faeb44fd492aa40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eef65538d96fc77d4d6b4d0711a83b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ac8eef65538d96fc77d4d6b4d0711a83b">VertexTag</a> () const</td></tr>
<tr class="separator:ac8eef65538d96fc77d4d6b4d0711a83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3bbf35105d80b99a2b1934b1314c73d5"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a3bbf35105d80b99a2b1934b1314c73d5">AngleRadiansFromCornerAngleIndex</a> (unsigned int corner_angle_index)</td></tr>
<tr class="separator:a3bbf35105d80b99a2b1934b1314c73d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2190e424dbee52e68c6ae2f8ca08e1"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a9a2190e424dbee52e68c6ae2f8ca08e1">ClampCornerSectorAngleRadians</a> (double corner_sector_angle_radians)</td></tr>
<tr class="separator:a9a2190e424dbee52e68c6ae2f8ca08e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3936379f481a7d115290437c0de683a"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ac3936379f481a7d115290437c0de683a">Compare</a> (const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> &amp;a, const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> &amp;b)</td></tr>
<tr class="separator:ac3936379f481a7d115290437c0de683a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0797eabb7908b803ae2be3f3d1d0c1"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#afb0797eabb7908b803ae2be3f3d1d0c1">Compare</a> (const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> *, const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> *)</td></tr>
<tr class="separator:afb0797eabb7908b803ae2be3f3d1d0c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b561203a2ccfe18b9eb550b764137d"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a54b561203a2ccfe18b9eb550b764137d">CornerAngleIndexFromCornerAngleRadians</a> (double angle_radians)</td></tr>
<tr class="separator:a54b561203a2ccfe18b9eb550b764137d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214e9b7aaf688a8a8d8144a73a5f8d79"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a214e9b7aaf688a8a8d8144a73a5f8d79">CornerSectorAngleRadiansFromEdges</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> sector_boundary_edge0_ptr, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> sector_boundary_edge1_ptr)</td></tr>
<tr class="separator:a214e9b7aaf688a8a8d8144a73a5f8d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5ac5434aed9d168a7ec38309a9f582"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a5f5ac5434aed9d168a7ec38309a9f582">CornerSectorCoefficient</a> (unsigned int sector_face_count, double corner_sector_angle_radians)</td></tr>
<tr class="separator:a5f5ac5434aed9d168a7ec38309a9f582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b7a3cac6981aa57104e18e371ea6fb"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a79b7a3cac6981aa57104e18e371ea6fb">CreaseSectorCoefficient</a> (unsigned int sector_face_count)</td></tr>
<tr class="separator:a79b7a3cac6981aa57104e18e371ea6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c46ffc9f5bb0ad25439f272a25461ac"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a7c46ffc9f5bb0ad25439f272a25461ac">Create</a> (const class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge, unsigned int edge_vertex_index)</td></tr>
<tr class="separator:a7c46ffc9f5bb0ad25439f272a25461ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a784921931453fc6c605ddb43c2fa95"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a5a784921931453fc6c605ddb43c2fa95">Create</a> (const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex)</td></tr>
<tr class="separator:a5a784921931453fc6c605ddb43c2fa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0835146f4f8dfd3ff60396987cfa1a0f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a0835146f4f8dfd3ff60396987cfa1a0f">Create</a> (const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, unsigned int face_vertex_index)</td></tr>
<tr class="separator:a0835146f4f8dfd3ff60396987cfa1a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eeb4df0caa34398dc72784d64d616e4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a0eeb4df0caa34398dc72784d64d616e4">Create</a> (const <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;sit)</td></tr>
<tr class="separator:a0eeb4df0caa34398dc72784d64d616e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef48003e4731db7701763f78f9ee161"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#adef48003e4731db7701763f78f9ee161">Create</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, unsigned int sector_face_count, double corner_sector_angle_radians)</td></tr>
<tr class="separator:adef48003e4731db7701763f78f9ee161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a585c1c3fab32ff03a1a36d7a66392f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a8a585c1c3fab32ff03a1a36d7a66392f">CreateCornerSectorType</a> (unsigned int sector_face_count, double sector_corner_angle_radians)</td></tr>
<tr class="separator:a8a585c1c3fab32ff03a1a36d7a66392f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a726a1e3a8243dc6ea7a02279e6ccf343"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a726a1e3a8243dc6ea7a02279e6ccf343">CreateCreaseSectorType</a> (unsigned int sector_face_count)</td></tr>
<tr class="separator:a726a1e3a8243dc6ea7a02279e6ccf343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0606fb55f6154ead4dcd67ab10e31f8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ae0606fb55f6154ead4dcd67ab10e31f8">CreateDartSectorType</a> (unsigned int sector_face_count)</td></tr>
<tr class="separator:ae0606fb55f6154ead4dcd67ab10e31f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58dde145ed4f23b368c91bd02cc80202"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a58dde145ed4f23b368c91bd02cc80202">CreateSmoothSectorType</a> (unsigned int sector_face_count)</td></tr>
<tr class="separator:a58dde145ed4f23b368c91bd02cc80202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d8c5360e6b2546670cc7cc7acab873"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a53d8c5360e6b2546670cc7cc7acab873">DartSectorCoefficient</a> (unsigned int sector_face_count)</td></tr>
<tr class="separator:a53d8c5360e6b2546670cc7cc7acab873"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519336312daa4a5b79c3239d4aa34059"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a519336312daa4a5b79c3239d4aa34059">IsValidCornerSectorAngleRadians</a> (double corner_sector_angle_radians)</td></tr>
<tr class="separator:a519336312daa4a5b79c3239d4aa34059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24062be5c742ae7e3661fdc424071678"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a24062be5c742ae7e3661fdc424071678">IsValidSectorCoefficientValue</a> (double coefficient_value, bool bAllowUnsetTaggedEndCoefficient)</td></tr>
<tr class="separator:a24062be5c742ae7e3661fdc424071678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237bf41f715c2d22ee3d5a098e03d044"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a237bf41f715c2d22ee3d5a098e03d044">MinimumSectorEdgeCount</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag)</td></tr>
<tr class="separator:a237bf41f715c2d22ee3d5a098e03d044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb92b940aed4a4aa00b7b2c7b3f7c774"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#aeb92b940aed4a4aa00b7b2c7b3f7c774">MinimumSectorFaceCount</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag)</td></tr>
<tr class="separator:aeb92b940aed4a4aa00b7b2c7b3f7c774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6895fdb160b6f6bade9fab37b4da3065"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a6895fdb160b6f6bade9fab37b4da3065">SectorCoefficientCalculationError</a> ()</td></tr>
<tr class="separator:a6895fdb160b6f6bade9fab37b4da3065"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b2570a1295598aa1f0b25c883a209a"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a81b2570a1295598aa1f0b25c883a209a">SectorEdgeCountFromFaceCount</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, unsigned int sector_face_count)</td></tr>
<tr class="separator:a81b2570a1295598aa1f0b25c883a209a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc8264dfce2734648e9939b039b8b1"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a2fbc8264dfce2734648e9939b039b8b1">SectorFaceCountFromEdgeCount</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, unsigned int sector_edge_count)</td></tr>
<tr class="separator:a2fbc8264dfce2734648e9939b039b8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc25f94dcd1f68f990548b8f250acd57"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#adc25f94dcd1f68f990548b8f250acd57">SectorPointRingCountFromEdgeCount</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, unsigned int sector_edge_count)</td></tr>
<tr class="separator:adc25f94dcd1f68f990548b8f250acd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae903e1088ef283f297ae0ebded151a9d"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ae903e1088ef283f297ae0ebded151a9d">SectorPointRingCountFromFaceCount</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, unsigned int sector_face_count)</td></tr>
<tr class="separator:ae903e1088ef283f297ae0ebded151a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28128ef237b4f81c6b879906b10fca4"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#aa28128ef237b4f81c6b879906b10fca4">SmoothSectorCoefficient</a> ()</td></tr>
<tr class="separator:aa28128ef237b4f81c6b879906b10fca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae3b9a4e8d8e5012445781b26770798c5"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ae3b9a4e8d8e5012445781b26770798c5">Empty</a></td></tr>
<tr class="separator:ae3b9a4e8d8e5012445781b26770798c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84b04594a7f2e5f0e6a90f60666ea8e"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ab84b04594a7f2e5f0e6a90f60666ea8e">ErrorCornerSectorAngle</a></td></tr>
<tr class="memdesc:ab84b04594a7f2e5f0e6a90f60666ea8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is indicate a corner sector angle calculation failed.  <a href="class_o_n___sub_d_sector_type.html#ab84b04594a7f2e5f0e6a90f60666ea8e">More...</a><br /></td></tr>
<tr class="separator:ab84b04594a7f2e5f0e6a90f60666ea8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa94981374e1edeb7dc7a58e9bd18e6"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#adfa94981374e1edeb7dc7a58e9bd18e6">ErrorSectorCoefficient</a></td></tr>
<tr class="memdesc:adfa94981374e1edeb7dc7a58e9bd18e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value indicates an edge sector coefficient calculation failed.  <a href="class_o_n___sub_d_sector_type.html#adfa94981374e1edeb7dc7a58e9bd18e6">More...</a><br /></td></tr>
<tr class="separator:adfa94981374e1edeb7dc7a58e9bd18e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab552b68ecece5e2800094a2efdeaebe2"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#ab552b68ecece5e2800094a2efdeaebe2">ErrorSectorTheta</a></td></tr>
<tr class="memdesc:ab552b68ecece5e2800094a2efdeaebe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is used to indicate a sector theta calculation failed.  <a href="class_o_n___sub_d_sector_type.html#ab552b68ecece5e2800094a2efdeaebe2">More...</a><br /></td></tr>
<tr class="separator:ab552b68ecece5e2800094a2efdeaebe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aefde9b112211c931b14c14c95eb2ce"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a3aefde9b112211c931b14c14c95eb2ce">IgnoredCornerSectorAngle</a></td></tr>
<tr class="memdesc:a3aefde9b112211c931b14c14c95eb2ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">= 0.0;  <a href="class_o_n___sub_d_sector_type.html#a3aefde9b112211c931b14c14c95eb2ce">More...</a><br /></td></tr>
<tr class="separator:a3aefde9b112211c931b14c14c95eb2ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed2047b4dc10df421bb3a452a549f834"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#aed2047b4dc10df421bb3a452a549f834">IgnoredSectorCoefficient</a></td></tr>
<tr class="memdesc:aed2047b4dc10df421bb3a452a549f834"><td class="mdescLeft">&#160;</td><td class="mdescRight">= 0.0;  <a href="class_o_n___sub_d_sector_type.html#aed2047b4dc10df421bb3a452a549f834">More...</a><br /></td></tr>
<tr class="separator:aed2047b4dc10df421bb3a452a549f834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef604ada0148720bfde1b6bb17a6fd59"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#aef604ada0148720bfde1b6bb17a6fd59">MaximumCornerAngleRadians</a></td></tr>
<tr class="memdesc:aef604ada0148720bfde1b6bb17a6fd59"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___sub_d_sector_type.html#aef604ada0148720bfde1b6bb17a6fd59" title="ON_SubDSectorType::MaximumCornerAngleRadians = 2.0*ON_PI - ON_SubDSectorType::MinimumCornerAngleRadia...">ON_SubDSectorType::MaximumCornerAngleRadians</a> = 2.0*ON_PI - <a class="el" href="class_o_n___sub_d_sector_type.html#a147745d8a3eafc25ae2b833bc2e3c017" title="ON_SubDSectorType::MinimumCornerAngleRadians = (2.0*ON_PI)/((double)(ON_SubDSectorType::MaximumCorner...">ON_SubDSectorType::MinimumCornerAngleRadians</a>;.  <a href="class_o_n___sub_d_sector_type.html#aef604ada0148720bfde1b6bb17a6fd59">More...</a><br /></td></tr>
<tr class="separator:aef604ada0148720bfde1b6bb17a6fd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a147745d8a3eafc25ae2b833bc2e3c017"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a147745d8a3eafc25ae2b833bc2e3c017">MinimumCornerAngleRadians</a></td></tr>
<tr class="memdesc:a147745d8a3eafc25ae2b833bc2e3c017"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___sub_d_sector_type.html#a147745d8a3eafc25ae2b833bc2e3c017" title="ON_SubDSectorType::MinimumCornerAngleRadians = (2.0*ON_PI)/((double)(ON_SubDSectorType::MaximumCorner...">ON_SubDSectorType::MinimumCornerAngleRadians</a> = (2.0*ON_PI)/((double)(<a class="el" href="class_o_n___sub_d_sector_type.html#a177fff351cf42caf48c03f33150fe208a3b20401a5fa8d24a185810657a5f8237">ON_SubDSectorType::MaximumCornerAngleIndex</a>));.  <a href="class_o_n___sub_d_sector_type.html#a147745d8a3eafc25ae2b833bc2e3c017">More...</a><br /></td></tr>
<tr class="separator:a147745d8a3eafc25ae2b833bc2e3c017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd548a236d525d733b6a47b6f58993c"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a7fd548a236d525d733b6a47b6f58993c">SmoothSectorTheta</a></td></tr>
<tr class="memdesc:a7fd548a236d525d733b6a47b6f58993c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is used for smooth sector thetas.  <a href="class_o_n___sub_d_sector_type.html#a7fd548a236d525d733b6a47b6f58993c">More...</a><br /></td></tr>
<tr class="separator:a7fd548a236d525d733b6a47b6f58993c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3baecd92db308e017b6f92c688cb38b"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#aa3baecd92db308e017b6f92c688cb38b">UnsetCornerSectorAngle</a></td></tr>
<tr class="memdesc:aa3baecd92db308e017b6f92c688cb38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">= -8881.0;  <a href="class_o_n___sub_d_sector_type.html#aa3baecd92db308e017b6f92c688cb38b">More...</a><br /></td></tr>
<tr class="separator:aa3baecd92db308e017b6f92c688cb38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95adb9f9e356893850b3cb5dc7b3b5e6"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#a95adb9f9e356893850b3cb5dc7b3b5e6">UnsetSectorCoefficient</a></td></tr>
<tr class="memdesc:a95adb9f9e356893850b3cb5dc7b3b5e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">= -8883.0;  <a href="class_o_n___sub_d_sector_type.html#a95adb9f9e356893850b3cb5dc7b3b5e6">More...</a><br /></td></tr>
<tr class="separator:a95adb9f9e356893850b3cb5dc7b3b5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed3a55676c89b88815be395c9adb5dd7"><td class="memItemLeft" align="right" valign="top">static const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d_sector_type.html#aed3a55676c89b88815be395c9adb5dd7">UnsetSectorTheta</a></td></tr>
<tr class="memdesc:aed3a55676c89b88815be395c9adb5dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This value is used to indicate a sector theta needs to be set.  <a href="class_o_n___sub_d_sector_type.html#aed3a55676c89b88815be395c9adb5dd7">More...</a><br /></td></tr>
<tr class="separator:aed3a55676c89b88815be395c9adb5dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a177fff351cf42caf48c03f33150fe208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177fff351cf42caf48c03f33150fe208">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: An angle index value of <a class="el" href="class_o_n___sub_d_sector_type.html#a177fff351cf42caf48c03f33150fe208a3b20401a5fa8d24a185810657a5f8237">ON_SubDSectorType::MaximumCornerAngleIndex</a> indicates the angle is 2pi radians. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a177fff351cf42caf48c03f33150fe208a3b20401a5fa8d24a185810657a5f8237"></a>MaximumCornerAngleIndex&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad99d4a36150bd90a471dcde2db627002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99d4a36150bd90a471dcde2db627002">&#9670;&nbsp;</a></span>ON_SubDSectorType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubDSectorType::ON_SubDSectorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cc43368a5cd8b6458e6c6f7b2c8e18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cc43368a5cd8b6458e6c6f7b2c8e18f">&#9670;&nbsp;</a></span>ON_SubDSectorType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubDSectorType::ON_SubDSectorType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3bbf35105d80b99a2b1934b1314c73d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bbf35105d80b99a2b1934b1314c73d5">&#9670;&nbsp;</a></span>AngleRadiansFromCornerAngleIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDSectorType::AngleRadiansFromCornerAngleIndex </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>corner_angle_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert and angle index into radians Parameters: corner_angle_index - [in] 0 to <a class="el" href="class_o_n___sub_d_sector_type.html#a177fff351cf42caf48c03f33150fe208a3b20401a5fa8d24a185810657a5f8237">ON_SubDSectorType::MaximumCornerAngleIndex</a>. Returns: If angle_index is valid, the corresponding angle in radians is returned. = (angle_index / ((double)<a class="el" href="class_o_n___sub_d_sector_type.html#a177fff351cf42caf48c03f33150fe208a3b20401a5fa8d24a185810657a5f8237">ON_SubDSectorType::MaximumCornerAngleIndex</a>)) * ON_2PI Otherwise ON_UNSET_VALUE is returned. </p>

</div>
</div>
<a id="a9a2190e424dbee52e68c6ae2f8ca08e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2190e424dbee52e68c6ae2f8ca08e1">&#9670;&nbsp;</a></span>ClampCornerSectorAngleRadians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDSectorType::ClampCornerSectorAngleRadians </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>corner_sector_angle_radians</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3936379f481a7d115290437c0de683a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3936379f481a7d115290437c0de683a">&#9670;&nbsp;</a></span>Compare() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ON_SubDSectorType::Compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afb0797eabb7908b803ae2be3f3d1d0c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0797eabb7908b803ae2be3f3d1d0c1">&#9670;&nbsp;</a></span>Compare() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int ON_SubDSectorType::Compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bf1b84c4cbc7c24b3e8a717984d8cf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf1b84c4cbc7c24b3e8a717984d8cf6">&#9670;&nbsp;</a></span>ComponentRingCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::ComponentRingCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: 1 + <a class="el" href="class_o_n___sub_d_sector_type.html#a05625579c55251bf13870445e31eaabd">FaceCount()</a> + <a class="el" href="class_o_n___sub_d_sector_type.html#a7f1ce2afbff2cc13a91c7917d6840326">EdgeCount()</a> </p>

</div>
</div>
<a id="a54b561203a2ccfe18b9eb550b764137d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b561203a2ccfe18b9eb550b764137d">&#9670;&nbsp;</a></span>CornerAngleIndexFromCornerAngleRadians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDSectorType::CornerAngleIndexFromCornerAngleRadians </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>angle_radians</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: angle_radians - <a href="0.0 &lt;= angle_radians &lt;= 2*ON_PI">in</a> The angle between the bounding crease edges Returns: If angle_radians is valid input, then the value angle_index is returned. The value angle_index is selected so that (0 &lt; angle_index &lt; ON_SubDSectorType::MaximumCornerSectorIndex) and fabs(angle_index*angle_quantum - angle_radians) is as small as possible, where angle_quantum = (2.0*ON_PI)/ON_SubDSectorType::MaximumCornerSectorIndex. Otherwise ON_UNSET_UINT_INDEX is returned. </p>

</div>
</div>
<a id="aeb8d76b7b95dbab5d56f146038990d24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8d76b7b95dbab5d56f146038990d24">&#9670;&nbsp;</a></span>CornerSectorAngleIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::CornerSectorAngleIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: a value &gt;= 0 and &lt;= <a class="el" href="class_o_n___sub_d_sector_type.html#a177fff351cf42caf48c03f33150fe208a3b20401a5fa8d24a185810657a5f8237">ON_SubDSectorType::MaximumCornerAngleIndex</a> </p>

</div>
</div>
<a id="a453cf2233f925170c86146cc4015448c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453cf2233f925170c86146cc4015448c">&#9670;&nbsp;</a></span>CornerSectorAngleRadians()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDSectorType::CornerSectorAngleRadians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: If the sector vertex tag is <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a>, the angle between the corner crease boundary edges is returned. <br  />
 Otherwise, <a class="el" href="class_o_n___sub_d_sector_type.html#ab84b04594a7f2e5f0e6a90f60666ea8e" title="This value is indicate a corner sector angle calculation failed.">ON_SubDSectorType::ErrorCornerSectorAngle</a> is returned. </p>

</div>
</div>
<a id="a214e9b7aaf688a8a8d8144a73a5f8d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214e9b7aaf688a8a8d8144a73a5f8d79">&#9670;&nbsp;</a></span>CornerSectorAngleRadiansFromEdges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDSectorType::CornerSectorAngleRadiansFromEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>sector_boundary_edge0_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>sector_boundary_edge1_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: sector_boundary_edge0_ptr - [in] sector_boundary_edge1_ptr - [in] Crease edges that bound the sector containing the smooth edge. The edge direction must identify the corner vertex. corner vertex = sector_boundary_edge0_ptr.RelativeVertex(0) = sector_boundary_edge1_ptr.RelativeVertex(0) Returns: tagged end angle for a smooth edge that 1) ends at a vertex tagged on <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a> 2) has two adjacent faces. 3) lies in a sector bounded by 2 distinct crease edges. The angle is convex and positive: 0 &lt; angle &lt;= Pi </p>

</div>
</div>
<a id="a5f5ac5434aed9d168a7ec38309a9f582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5ac5434aed9d168a7ec38309a9f582">&#9670;&nbsp;</a></span>CornerSectorCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDSectorType::CornerSectorCoefficient </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>corner_sector_angle_radians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a79b7a3cac6981aa57104e18e371ea6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b7a3cac6981aa57104e18e371ea6fb">&#9670;&nbsp;</a></span>CreaseSectorCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDSectorType::CreaseSectorCoefficient </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: face_type - [in] sector_face_count - [in] number of faces in the smooth sector. Returns: 0: failed to caclulate coefficient <a class="el" href="class_o_n___sub_d_sector_type.html#a95adb9f9e356893850b3cb5dc7b3b5e6" title="= -8883.0;">ON_SubDSectorType::UnsetSectorCoefficient</a>: This typically happens when a SubD control net is being created and a facet type is not specified. <br  />
 The coefficients will be calculated at the first subdivision. 0 &lt; w &lt; 1: 1/2 + 1/3*cos(tagged end sector angle / number of faces) for quadrangle facets Remarks: This is a useful tool when calling AddEdge while a subdivision level is being constructed. </p>

</div>
</div>
<a id="a7c46ffc9f5bb0ad25439f272a25461ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c46ffc9f5bb0ad25439f272a25461ac">&#9670;&nbsp;</a></span>Create() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::Create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_vertex_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the sector containing the edge. Parameters: subd_type - [in] edge - [in] edge_vertex_index - [in] edge-&gt;Vertex(edge_vertex_index) will be the sector's center vertex. Returns: An <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the sector containing the edge. </p>

</div>
</div>
<a id="a5a784921931453fc6c605ddb43c2fa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a784921931453fc6c605ddb43c2fa95">&#9670;&nbsp;</a></span>Create() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::Create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0835146f4f8dfd3ff60396987cfa1a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0835146f4f8dfd3ff60396987cfa1a0f">&#9670;&nbsp;</a></span>Create() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::Create </td>
          <td>(</td>
          <td class="paramtype">const class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>face_vertex_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the sector containing the face. Parameters: subd_type - [in] face - [in] face_vertex_index - [in] face-&gt;Vertex(face_vertex_index) will be the sector's center vertex. Returns: An <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the sector containing the face. </p>

</div>
</div>
<a id="a0eeb4df0caa34398dc72784d64d616e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eeb4df0caa34398dc72784d64d616e4">&#9670;&nbsp;</a></span>Create() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::Create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> from a <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a>. Parameters: subd_type - [in] sit - [in] Returns: An <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the sector identified by sit. </p>

</div>
</div>
<a id="adef48003e4731db7701763f78f9ee161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef48003e4731db7701763f78f9ee161">&#9670;&nbsp;</a></span>Create() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>corner_sector_angle_radians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> from a <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a>. Parameters: subd_type - [in] vertex_tag - [in] sector_face_count - [in] Number of faces in the sector. corner_sector_angle_radians - [in] If vertex_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a>, this parameter is the angle between the crease edges that bound the corner. <br  />
 If vertex_tag is not <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a>, this parameter is ignored. Returns: An <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the case the input parameters identify. </p>

</div>
</div>
<a id="a8a585c1c3fab32ff03a1a36d7a66392f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a585c1c3fab32ff03a1a36d7a66392f">&#9670;&nbsp;</a></span>CreateCornerSectorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::CreateCornerSectorType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sector_corner_angle_radians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a corner <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>. Parameters: subd_type - [in] sector_face_count - [in] Number of faces in the sector. corner_sector_angle_radians - [in] The angle between the crease edges that bound the corner. <br  />
 Returns: An <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the corner sector case specified by the input parameters. </p>

</div>
</div>
<a id="a726a1e3a8243dc6ea7a02279e6ccf343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a726a1e3a8243dc6ea7a02279e6ccf343">&#9670;&nbsp;</a></span>CreateCreaseSectorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::CreateCreaseSectorType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a crease <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>. Parameters: subd_type - [in] sector_face_count - [in] Number of faces in the sector. Returns: An <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the crease sector case specified by the input parameters. </p>

</div>
</div>
<a id="ae0606fb55f6154ead4dcd67ab10e31f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0606fb55f6154ead4dcd67ab10e31f8">&#9670;&nbsp;</a></span>CreateDartSectorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::CreateDartSectorType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a dart <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>. Parameters: subd_type - [in] sector_face_count - [in] Number of faces in the sector. Returns: An <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the dart sector case specified by the input parameters. </p>

</div>
</div>
<a id="a58dde145ed4f23b368c91bd02cc80202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58dde145ed4f23b368c91bd02cc80202">&#9670;&nbsp;</a></span>CreateSmoothSectorType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::CreateSmoothSectorType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a smooth <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>. Parameters: subd_type - [in] sector_face_count - [in] Number of faces in the sector. Returns: An <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> for the smooth sector case specified by the input parameters. </p>

</div>
</div>
<a id="a53d8c5360e6b2546670cc7cc7acab873"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d8c5360e6b2546670cc7cc7acab873">&#9670;&nbsp;</a></span>DartSectorCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDSectorType::DartSectorCoefficient </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f1ce2afbff2cc13a91c7917d6840326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f1ce2afbff2cc13a91c7917d6840326">&#9670;&nbsp;</a></span>EdgeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::EdgeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05625579c55251bf13870445e31eaabd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05625579c55251bf13870445e31eaabd">&#9670;&nbsp;</a></span>FaceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::FaceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6251a86e5f394067bb8c7b3855230628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6251a86e5f394067bb8c7b3855230628">&#9670;&nbsp;</a></span>FacetEdgeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::FacetEdgeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac46add4a52804a1f5ce048f7514c4bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46add4a52804a1f5ce048f7514c4bbe">&#9670;&nbsp;</a></span>GetAllEigenvalues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::GetAllEigenvalues </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>eigenvalues_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: eigenvalues_capacity - [in] Capacity of the eigenvalues[] array. Must be 0 or &gt;= <a class="el" href="class_o_n___sub_d_sector_type.html#a557b745fa7c6f0566db07c37f4a4ef79">PointRingCount()</a> eigenvalues - [out] If 0 = eigenvalues_capacity, eigenvalues must be nullptr. If eigenvalues_capacity &gt; 0, is specifies the capactiy of the eigenvalues[] array. Returns: R &gt; 0: A complete set of eigenvalues is available for this sector type. The eigenvalues are (1, lambda, lambda, e3, ..., eR), where 1 &gt; lambda &gt; e3 &gt;= ... &gt;= eR &gt; 0. 0: Invalid input or the eigenvalues for this sector typoe are not available. </p>

</div>
</div>
<a id="adc240f2b7e33e26d29bfad9274389cb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc240f2b7e33e26d29bfad9274389cb0">&#9670;&nbsp;</a></span>GetSubdivisionMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::GetSubdivisionMatrix </td>
          <td>(</td>
          <td class="paramtype">double **&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>matrix_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the subdivision matrix for the default subdivison algorithms used by <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>.</p>
<p>The matrix coefficents are ordered so that the matrix acts on the left of the points returned by ON_SubDSectorIterator::GetVertexRing().</p>
<p>For an interior vertex (smooth or dart), the coefficents are ordered so that one iteration of subdivision is given by: S*Transpose(V, E[0], F[0], E[1], F[1], ..., E[N-1], F[N-1]). For a dart vertex, E[0] is the point at the end of the creased edge.</p>
<p>For a boundary vertex (crease or corner), the coefficents are ordered so that one iteration of subdivision is given by: S*Transpose(V, E[0], F[0], E[1], F[1], ..., F[N-2], E[N-1]).</p>
<p>N = edge valence = number of edges in the sector. E[i] = end of i-th edge radiating from V. F[i] = point on the quad that is opposite V. The edges and faces are ordered radially so that the face for F[i] lies between the edges for E[i] and E[(i+1)N].</p>
<p>Parameters: S - [out] subdivision matrix Matrix coefficent (i,j) = S[i][j] 0 &lt;= i &lt; R, 0 &lt;= j &lt; R, R = <a class="el" href="class_o_n___sub_d_sector_type.html#a557b745fa7c6f0566db07c37f4a4ef79">ON_SubDSectorType.PointRingCount()</a> matrix_capacity - [in] S[] can store any RxR matrix with R &lt;= matrix_capacity.</p>
<p>Returns: R &gt; 0: R = <a class="el" href="class_o_n___sub_d_sector_type.html#a557b745fa7c6f0566db07c37f4a4ef79">PointRingCount()</a> and S is the RxR subdivision matrix for the sector type. 0: Invalid input </p>

</div>
</div>
<a id="af056cbb7d8ca64b57e969e3d60bdb3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af056cbb7d8ca64b57e969e3d60bdb3fb">&#9670;&nbsp;</a></span>GetSubdivisionMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::GetSubdivisionMatrix </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>S_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: S - [out] subdivision matrix. Matrix coefficent (i,j) = S[i*R + j], 0 &lt;= i &lt; R, 0 &lt;= j &lt; R, R = <a class="el" href="class_o_n___sub_d_sector_type.html#a557b745fa7c6f0566db07c37f4a4ef79">ON_SubDSectorType.PointRingCount()</a> S_capacity - [in] Number of elements in S[] array Returns: 0: Invalid input. &gt;0: Number of rows and columns in S. This number is always <a class="el" href="class_o_n___sub_d_sector_type.html#a557b745fa7c6f0566db07c37f4a4ef79">ON_SubDSectorType.PointRingCount()</a>. </p>

</div>
</div>
<a id="a0eae02762ef68cec847fb5ab8dca9522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eae02762ef68cec847fb5ab8dca9522">&#9670;&nbsp;</a></span>GetSubdominantEigenvectors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDSectorType::GetSubdominantEigenvectors </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>E1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>E1_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>E2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>E2_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: With one exception, which is described below, all the subdivision matrices for the <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> built-in subdivision algorithms have eigenvalues (1, lambda, lambda, e4, ..., eR), where lambda is real, 1 &gt; lambda &gt; |e4| &gt;= ... &gt;= |eR| &gt; 0, and the geometric dimension of the lambda eigenspace is 2 (there are two linearly independent lambda eigenvectors).</p>
<p>The subdominant eigenvalue is lamda. This function returns an orthogonal basis, (E1, E2), for the subdominant eigenspace.</p>
<p>An eigenvector for the dominant eigen value 1 has is (1,1,...,1). The domainant eignevector is orthogonal to the subdominant eigenspace.</p>
<p>Put another way, 0 = E1[0] + ... + E1[R-1] 0 = E2[0] + ... + E2[R-1] 0 = E1[0]*E2[0] + ... + E1[R-1]*E2[R-1]</p>
<p>Exceptional case: The Catmull-Clark subdivision matrix for a crease vertex with two crease edges and a single face is a special case. <br  />
 In this exceptional, this function returns lambda = 1/2, E1 = {0,-1,0,-1} and E2 = {1, -2, -5, -2}. For more information about the exceptional case, see the description of <a class="el" href="class_o_n___sub_d_sector_type.html#aee8e3e82300c56bc4499fb955b5765b0">ON_SubDSectorType::SubdominantEigenvalueMulitiplicity()</a>.</p>
<p>Parameters: E1_capacity - [in] Capacity of the E1[] array. E1 - [out] E2_capacity - [in] Capacity of the E2[] array. E2 - [out] When E1_capacity &gt; 0 and E2_capacity &gt; 0, two orthoganal eigenvectors spanning the subdivision matrix subdominant eigenspace are returned in E1[] and E2[]. If one of E1_capacity or E2_capacity is &gt; 0, then both must be &gt; 0.</p>
<p>Returns: ON_UNSET_VALUE: Invalid input. e &gt; 0.0 and e &lt; 1.0: subdominant eigenvalue. </p>

</div>
</div>
<a id="a43c9834e4e1d260f763797e1ec295359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c9834e4e1d260f763797e1ec295359">&#9670;&nbsp;</a></span>GetSurfaceEvaluationCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::GetSurfaceEvaluationCoefficients </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>LPev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>LPev_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>LT0ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>LT0ev_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>LT1ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>LT1ev_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: LPev_capacity - [in] Capacity of the LPev[] array. LPev - [out] When LPev_capacity &gt; 0, then the limit surface point evaluation coefficients are returned in LPev[]. Otherwise LPev is ignored. LT0ev_capacity - [in] Capacity of the LPev[] array. LT0ev - [out] LT1ev_capacity - [in] Capacity of the LPev[] array. LT1ev - [out] When LT0ev_capacity &gt; 0 and LT1ev_capacity &gt; 0, then the limit surface tangent coefficients are returned in LT0ev[] and LT1ev[]. Otherwise, LT0ev[] and LT1ev[] are ignored. If one of LT0ev_capacity or LT1ev_capacity is &gt; 0, then both must be &gt; 0. Returns: 0: Invalid input. &gt;0: Number of evaluation coefficients in the L*ev[] arrays. This number is always <a class="el" href="class_o_n___sub_d_sector_type.html#a557b745fa7c6f0566db07c37f4a4ef79">ON_SubDSectorType.PointRingCount()</a>. </p>

</div>
</div>
<a id="abf27e8ab57f8dbc403b8d7d77795e284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf27e8ab57f8dbc403b8d7d77795e284">&#9670;&nbsp;</a></span>IsConcaveCornerSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDSectorType::IsConcaveCornerSector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if this is a concave corner vertex sector (sector angle &gt; pi) </p>

</div>
</div>
<a id="a873bace6e4bb2cdb614f3e4824c4bcd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a873bace6e4bb2cdb614f3e4824c4bcd1">&#9670;&nbsp;</a></span>IsConvexCornerSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDSectorType::IsConvexCornerSector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if this is a convex corner vertex sector (sector angle &lt;= pi) </p>

</div>
</div>
<a id="ae369f5c4af784b3319e2601c48553acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae369f5c4af784b3319e2601c48553acc">&#9670;&nbsp;</a></span>IsCornerSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDSectorType::IsCornerSector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if this is a corner vertex sector </p>

</div>
</div>
<a id="a566995d2a2b4a548bcdd48671a10994b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566995d2a2b4a548bcdd48671a10994b">&#9670;&nbsp;</a></span>IsCreaseSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDSectorType::IsCreaseSector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if this is a crease vertex sector </p>

</div>
</div>
<a id="aa7260cd082d03690c13ea8b721f23824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7260cd082d03690c13ea8b721f23824">&#9670;&nbsp;</a></span>IsDartSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDSectorType::IsDartSector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if this is a dart interior vertex sector </p>

</div>
</div>
<a id="a89f4f53b084efb1d2f6f8f8644ce4b66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f4f53b084efb1d2f6f8f8644ce4b66">&#9670;&nbsp;</a></span>IsSmoothSector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDSectorType::IsSmoothSector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if this is a smooth interior vertex sector </p>

</div>
</div>
<a id="a58a1eafd31ebc8c1b6237fc2250d67db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a1eafd31ebc8c1b6237fc2250d67db">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDSectorType::IsValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a519336312daa4a5b79c3239d4aa34059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519336312daa4a5b79c3239d4aa34059">&#9670;&nbsp;</a></span>IsValidCornerSectorAngleRadians()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubDSectorType::IsValidCornerSectorAngleRadians </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>corner_sector_angle_radians</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a24062be5c742ae7e3661fdc424071678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24062be5c742ae7e3661fdc424071678">&#9670;&nbsp;</a></span>IsValidSectorCoefficientValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubDSectorType::IsValidSectorCoefficientValue </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coefficient_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllowUnsetTaggedEndCoefficient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a237bf41f715c2d22ee3d5a098e03d044"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237bf41f715c2d22ee3d5a098e03d044">&#9670;&nbsp;</a></span>MinimumSectorEdgeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDSectorType::MinimumSectorEdgeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb92b940aed4a4aa00b7b2c7b3f7c774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb92b940aed4a4aa00b7b2c7b3f7c774">&#9670;&nbsp;</a></span>MinimumSectorFaceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDSectorType::MinimumSectorFaceCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7c4dcc86492ae401ee61c96c09b5274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c4dcc86492ae401ee61c96c09b5274">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>&amp; ON_SubDSectorType::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a557b745fa7c6f0566db07c37f4a4ef79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a557b745fa7c6f0566db07c37f4a4ef79">&#9670;&nbsp;</a></span>PointRingCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::PointRingCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Number of points in the point ring. <br  />
 For quad subds, this is 1 + <a class="el" href="class_o_n___sub_d_sector_type.html#a05625579c55251bf13870445e31eaabd">FaceCount()</a> + <a class="el" href="class_o_n___sub_d_sector_type.html#a7f1ce2afbff2cc13a91c7917d6840326">EdgeCount()</a>. For tri subds, this is 1 + <a class="el" href="class_o_n___sub_d_sector_type.html#a7f1ce2afbff2cc13a91c7917d6840326">EdgeCount()</a>. </p>

</div>
</div>
<a id="afbd772f9fe85152a75653006b69fde71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd772f9fe85152a75653006b69fde71">&#9670;&nbsp;</a></span>SectorCoefficient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDSectorType::SectorCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sector Coefficients</p>
<p>In the comment below, F = number of faces in the sector, E = number of edges in the sector.</p>
<p>There are five valid sector configurations of edges and faces. In all configurations, the edges have one end at the center vertex and the faces have one corner at the center vertex.</p>
<p>SMOOTH 1) The center vertex is smooth. 2) F &gt;= 2 3) E = F 4) Every edge is smooth. 5) Every edge is an edge of two different faces in the sector.</p>
<p>DART 1) The center vertex is a dart. 2) F &gt;= 2 3) E = F 4) One edge is a crease. 5) The crease edge is an edge of two geometrically adjacent sector faces.</p>
<p>DART* (The same as "DART", but the crease edge has been duplicated.) 1) The center vertex is a dart. 2) F &gt;= 2 3) E = F+1 4) Two edges are creases that have the same end locations. 5) Each crease edge is an edge of a single face in the sector, these faces are different and are geometrically adjacent.</p>
<p>BOUNDED 1) The center vertex is a crease or corner vertex. 2) F &gt;= 2 3) E = F+1 4) Two edges are crease edges that have different vertices at their ends. 5) Each crease edge is an edge of a single face in the sector, these faces are different and not geometrically adjacent.</p>
<p>BOUNDED* 1) The center vertex is a crease or corner vertex. 2) F = 1 3) E = 2 4) The edges are crease edges that have different vertices at their ends. 5) The edges a edges of the face.</p>
<p>The sector coefficient is used when subdividing smooth edges in sectors with a DART, DART* or BOUNDED configuration. In these cases the sector coefficient is a value strictly between 0.0 and 1.0 that depends on 1) the center vertex tag (crease, corner or dart), 2) the value of F, 3) and when the center vertex is a corner, the angle between the boundary edges. <br  />
</p>
<p>The sector coefficient is ignored when dividing smooth edges in SMOOTH sectors. The sector coefficient is ignored when subdividing crease edges.</p>
<p>For a smooth edge in a sector with a DART, DART* or BOUNDED configuration, with w = sector coefficient, C = location of the center vertex and P = location of the smooth vertex at the other end of the smooth edge, the point</p>
<p>Q = 3/4 * (w*C + (1-w)*P)</p>
<p>is the contribution of C and P to the edge's subdivision point.</p>
<p>When a smooth edge has smooth vertices at both ends located at A and B, the contribution of A and B to the edge's subdivision point is</p>
<p>Q = 3/8 * (A + B) = 3/4 * (1/2*A + 1/2*B)</p>
<p>A crease edge's subdivision point is always the edge's midpoint. Description: Calculates sector coefficient value for the sector type identified by this <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a>. Returns: w: 0.0 &lt; w &lt; 1.0 w = sector coefficient value. <a class="el" href="class_o_n___sub_d_sector_type.html#a3aefde9b112211c931b14c14c95eb2ce" title="= 0.0;">ON_SubDSectorType::IgnoredCornerSectorAngle</a> (= 0.0) This value is used to set sector angles when the actual value is not needed. <a class="el" href="class_o_n___sub_d_sector_type.html#adfa94981374e1edeb7dc7a58e9bd18e6" title="This value indicates an edge sector coefficient calculation failed.">ON_SubDSectorType::ErrorSectorCoefficient</a> This <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> is not valid and the calculation failed. </p>

</div>
</div>
<a id="a6895fdb160b6f6bade9fab37b4da3065"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6895fdb160b6f6bade9fab37b4da3065">&#9670;&nbsp;</a></span>SectorCoefficientCalculationError()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDSectorType::SectorCoefficientCalculationError </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: <a class="el" href="class_o_n___sub_d_sector_type.html#adfa94981374e1edeb7dc7a58e9bd18e6" title="This value indicates an edge sector coefficient calculation failed.">ON_SubDSectorType::ErrorSectorCoefficient</a> and calls debug breakpoint </p>

</div>
</div>
<a id="a81b2570a1295598aa1f0b25c883a209a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b2570a1295598aa1f0b25c883a209a">&#9670;&nbsp;</a></span>SectorEdgeCountFromFaceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDSectorType::SectorEdgeCountFromFaceCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fbc8264dfce2734648e9939b039b8b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fbc8264dfce2734648e9939b039b8b1">&#9670;&nbsp;</a></span>SectorFaceCountFromEdgeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDSectorType::SectorFaceCountFromEdgeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="adc25f94dcd1f68f990548b8f250acd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc25f94dcd1f68f990548b8f250acd57">&#9670;&nbsp;</a></span>SectorPointRingCountFromEdgeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDSectorType::SectorPointRingCountFromEdgeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: Number of subdivision points in a sector ring facet_type vertex_tag ring count tri smooth N+1 tri crease N+2 quad smooth 2N+1 quad crease 2N+2 (2 * valence + 1) for quad subds (valence + 1) for tri subds </p>

</div>
</div>
<a id="ae903e1088ef283f297ae0ebded151a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae903e1088ef283f297ae0ebded151a9d">&#9670;&nbsp;</a></span>SectorPointRingCountFromFaceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubDSectorType::SectorPointRingCountFromFaceCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3eb9fbf626cbc5c5a873f82d0dc78e63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb9fbf626cbc5c5a873f82d0dc78e63">&#9670;&nbsp;</a></span>SectorRingSubD()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubDSectorType::SectorRingSubD </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sector_angle_radians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Create a partial subdivison sector around vertex. The resulting <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> has an outer ring with smooth edges and vertices, which is not valid as a stand-alone subd. This is typically used for testing. Parameters: radius - [in] The center vertex is located at (0,0,0), If radius &gt; 0.0, then the end of the first edge is at (radius,0,0), subsequent edges are in a radial array and quad face points, if any, are 2*radius from the origin. sector_angle_radians - [in] If radius &gt; 0, this-&gt;<a class="el" href="class_o_n___sub_d_sector_type.html#ac8eef65538d96fc77d4d6b4d0711a83b">VertexTag()</a> is <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDVertexTag::Crease</a>, crease_sector_angle_radians &gt; 0.0 and crease_sector_angle_radians &lt; 2.0*ON_PI, then this will be the angle between the crease boundary edges. In all other cases, crease_sector_angle_radians is ignored. subd - [in] If subd is not null, the vertex ring is put in this subd. Returns: a pointer to the vertex ring nullptr is returned if the input is not valid. </p>

</div>
</div>
<a id="a878eb6eb09cf0af21adbaddcc4ba6d09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878eb6eb09cf0af21adbaddcc4ba6d09">&#9670;&nbsp;</a></span>SectorTypeHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::SectorTypeHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa28128ef237b4f81c6b879906b10fca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa28128ef237b4f81c6b879906b10fca4">&#9670;&nbsp;</a></span>SmoothSectorCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubDSectorType::SmoothSectorCoefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: <a class="el" href="class_o_n___sub_d_sector_type.html#aed2047b4dc10df421bb3a452a549f834" title="= 0.0;">ON_SubDSectorType::IgnoredSectorCoefficient</a> </p>

</div>
</div>
<a id="a280402ee6306d7e8e6c9164f78f67051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a280402ee6306d7e8e6c9164f78f67051">&#9670;&nbsp;</a></span>SubdominantEigenvalue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDSectorType::SubdominantEigenvalue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: All the subdivision matrices for the <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> built-in subdivision algorithms have eigenvalues (1, lambda1, lambda2, e4, ..., eR), where 1 &gt; lambda1 &gt;= lambda2 &gt; |e4| &gt;= ... &gt;= |eR| &gt; 0.</p>
<p>The subdominant eigenvalue is lambda1 and, with one exception, lambda1 = lambda2. The exception is described in the description of <a class="el" href="class_o_n___sub_d_sector_type.html#aee8e3e82300c56bc4499fb955b5765b0">ON_SubDSectorType::SubdominantEigenvalueMulitiplicity()</a>.</p>
<p>Returns: </p><blockquote class="doxtable">
<p>0.0: </p>
</blockquote>
<p>The subdominant eigenvalue for the subdivision matrix.</p>
<p>ON_UNSET_VALUE: This <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> is not valid. </p>

</div>
</div>
<a id="aee8e3e82300c56bc4499fb955b5765b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8e3e82300c56bc4499fb955b5765b0">&#9670;&nbsp;</a></span>SubdominantEigenvalueMulitiplicity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubDSectorType::SubdominantEigenvalueMulitiplicity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: 0: The sector type is not set.</p>
<p>2: The subdominant eigenvalue has algebraic and geometric multiplicty = 2. This is the most common case.</p>
<p>1: The subdominant eigenvalue has algebraic and geometric multiplicty = 1. This occures in Catmull-Clark subdivision at a crease vertex with two crease edges and a single face. The subdivision matrix for this case is S is a 4 x 4 matrix with rows = (3/4, 1/8, 0, 1/8), (1/2, 1/2, 0, 0), (1/4, 1/4, 1/4, 1/4), (1/2, 0, 0, 1/2). S has 4 real eigenvalues = (1, 1/2, 1/4, 1/4), all wtih geometric multiplicity = 1. The three eigenvectors are (1, 1, 1, 1), (0, -1, 0, 1), (0, 0, 1, 0). </p>

</div>
</div>
<a id="a8ce2418305a686ab9d44a8a702b2772e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce2418305a686ab9d44a8a702b2772e">&#9670;&nbsp;</a></span>SurfaceEvaluationCoefficientsAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubDSectorType::SurfaceEvaluationCoefficientsAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc28bfa2da83318f2faeb44fd492aa40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc28bfa2da83318f2faeb44fd492aa40">&#9670;&nbsp;</a></span>SurfaceNormalSign()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ON_SubDSectorType::SurfaceNormalSign </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___sub_d_sector_type.html#afc28bfa2da83318f2faeb44fd492aa40" title="SurfaceNormalSign() is a debugging tool - slow and not useful in general.">SurfaceNormalSign()</a> is a debugging tool - slow and not useful in general. </p>

</div>
</div>
<a id="ac8eef65538d96fc77d4d6b4d0711a83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8eef65538d96fc77d4d6b4d0711a83b">&#9670;&nbsp;</a></span>VertexTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> ON_SubDSectorType::VertexTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae3b9a4e8d8e5012445781b26770798c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3b9a4e8d8e5012445781b26770798c5">&#9670;&nbsp;</a></span>Empty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_o_n___sub_d_sector_type.html">ON_SubDSectorType</a> ON_SubDSectorType::Empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab84b04594a7f2e5f0e6a90f60666ea8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84b04594a7f2e5f0e6a90f60666ea8e">&#9670;&nbsp;</a></span>ErrorCornerSectorAngle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::ErrorCornerSectorAngle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This value is indicate a corner sector angle calculation failed. </p>
<p>= -9991.0; </p>

</div>
</div>
<a id="adfa94981374e1edeb7dc7a58e9bd18e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfa94981374e1edeb7dc7a58e9bd18e6">&#9670;&nbsp;</a></span>ErrorSectorCoefficient</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::ErrorSectorCoefficient</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This value indicates an edge sector coefficient calculation failed. </p>
<p>= -9993.0; </p>

</div>
</div>
<a id="ab552b68ecece5e2800094a2efdeaebe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab552b68ecece5e2800094a2efdeaebe2">&#9670;&nbsp;</a></span>ErrorSectorTheta</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::ErrorSectorTheta</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This value is used to indicate a sector theta calculation failed. </p>
<p>= -9992.0; </p>

</div>
</div>
<a id="a3aefde9b112211c931b14c14c95eb2ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aefde9b112211c931b14c14c95eb2ce">&#9670;&nbsp;</a></span>IgnoredCornerSectorAngle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::IgnoredCornerSectorAngle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>= 0.0; </p>
<p>This value is is used to set sector angles when the actual value is not needed. This occurs at both ends of a creased edge and when the end of a smooth edge is a smooth vertex. </p>

</div>
</div>
<a id="aed2047b4dc10df421bb3a452a549f834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed2047b4dc10df421bb3a452a549f834">&#9670;&nbsp;</a></span>IgnoredSectorCoefficient</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::IgnoredSectorCoefficient</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>= 0.0; </p>
<p>This value is is used to set edge sector coefficients when the actual value is not needed. This occurs at both ends of a creased edge and when the end of a smooth edge is a smooth vertex. </p>

</div>
</div>
<a id="aef604ada0148720bfde1b6bb17a6fd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef604ada0148720bfde1b6bb17a6fd59">&#9670;&nbsp;</a></span>MaximumCornerAngleRadians</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::MaximumCornerAngleRadians</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___sub_d_sector_type.html#aef604ada0148720bfde1b6bb17a6fd59" title="ON_SubDSectorType::MaximumCornerAngleRadians = 2.0*ON_PI - ON_SubDSectorType::MinimumCornerAngleRadia...">ON_SubDSectorType::MaximumCornerAngleRadians</a> = 2.0*ON_PI - <a class="el" href="class_o_n___sub_d_sector_type.html#a147745d8a3eafc25ae2b833bc2e3c017" title="ON_SubDSectorType::MinimumCornerAngleRadians = (2.0*ON_PI)/((double)(ON_SubDSectorType::MaximumCorner...">ON_SubDSectorType::MinimumCornerAngleRadians</a>;. </p>

</div>
</div>
<a id="a147745d8a3eafc25ae2b833bc2e3c017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a147745d8a3eafc25ae2b833bc2e3c017">&#9670;&nbsp;</a></span>MinimumCornerAngleRadians</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::MinimumCornerAngleRadians</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___sub_d_sector_type.html#a147745d8a3eafc25ae2b833bc2e3c017" title="ON_SubDSectorType::MinimumCornerAngleRadians = (2.0*ON_PI)/((double)(ON_SubDSectorType::MaximumCorner...">ON_SubDSectorType::MinimumCornerAngleRadians</a> = (2.0*ON_PI)/((double)(<a class="el" href="class_o_n___sub_d_sector_type.html#a177fff351cf42caf48c03f33150fe208a3b20401a5fa8d24a185810657a5f8237">ON_SubDSectorType::MaximumCornerAngleIndex</a>));. </p>

</div>
</div>
<a id="a7fd548a236d525d733b6a47b6f58993c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd548a236d525d733b6a47b6f58993c">&#9670;&nbsp;</a></span>SmoothSectorTheta</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::SmoothSectorTheta</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This value is used for smooth sector thetas. </p>
<p>= 0.5*ON_PI </p>

</div>
</div>
<a id="aa3baecd92db308e017b6f92c688cb38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3baecd92db308e017b6f92c688cb38b">&#9670;&nbsp;</a></span>UnsetCornerSectorAngle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::UnsetCornerSectorAngle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>= -8881.0; </p>
<p>This value is used to set sector coefficients that could not be correctly set because something in the calculation failed. <br  />
 It is typically used when an invalid component in SubD object was needed to calculate the coefficient. </p>

</div>
</div>
<a id="a95adb9f9e356893850b3cb5dc7b3b5e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95adb9f9e356893850b3cb5dc7b3b5e6">&#9670;&nbsp;</a></span>UnsetSectorCoefficient</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::UnsetSectorCoefficient</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>= -8883.0; </p>
<p>This value is used to mark edge sector coefficients that need to be set in the future when more information is available. It is typically used when creating a subD control net and the facet type is not known. Any value &lt; 0.0 and not equal to ON_UNSET_VALUE would work. The fact that the actual value is -999.0 has no other significance. </p>

</div>
</div>
<a id="aed3a55676c89b88815be395c9adb5dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed3a55676c89b88815be395c9adb5dd7">&#9670;&nbsp;</a></span>UnsetSectorTheta</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double ON_SubDSectorType::UnsetSectorTheta</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This value is used to indicate a sector theta needs to be set. </p>
<p>= -8882.0; </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 11 2022 07:59:23 for Rhino C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
