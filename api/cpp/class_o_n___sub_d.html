<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rhino C++ API: ON_SubD Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rhino C++ API
   &#160;<span id="projectnumber">7.18</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="class_o_n___sub_d-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ON_SubD Class Reference<div class="ingroups"><a class="el" href="group__open_n_u_r_b_s.html">OpenNURBS</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;opennurbs_subd.h&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ON_SubD:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_o_n___sub_d.png" usemap="#ON_5FSubD_map" alt=""/>
  <map id="ON_5FSubD_map" name="ON_5FSubD_map">
<area href="class_o_n___geometry.html" alt="ON_Geometry" shape="rect" coords="0,56,92,80"/>
<area href="class_o_n___object.html" alt="ON_Object" shape="rect" coords="0,0,92,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a89d6c70eef1e83ec2a0889fd2bea9e7e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: unsigned int { <a class="el" href="class_o_n___sub_d.html#a89d6c70eef1e83ec2a0889fd2bea9e7eaaaafc6d2b5efd3c1d3214afbaa46c9bc">maximum_subd_level</a> = 128
 }</td></tr>
<tr class="separator:a89d6c70eef1e83ec2a0889fd2bea9e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6356d9ba7b424672377a4722efd09b3c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">: unsigned int { <a class="el" href="class_o_n___sub_d.html#a6356d9ba7b424672377a4722efd09b3cab72d6681c2028801f5b78c651928692d">TextureImageSuggestedMinimumSize</a> = 1024
 }</td></tr>
<tr class="separator:a6356d9ba7b424672377a4722efd09b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef51f2ea460e4edd104e4216bc197f5b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b">AutomaticMeshToSubDContext</a> : unsigned char { <a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5bac9f88e098f6fe4e4e112eeb05ccb9671">AutomaticMeshToSubDContext::Unset</a> = 0, 
<a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5ba81705f4f7e91e6b42f211b35ff10269f">AutomaticMeshToSubDContext::Rhino5BoxModeTSpline</a> = 1, 
<a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5ba4fa22b0ffaacc4a064817da0d307c614">AutomaticMeshToSubDContext::FBXMeshWithDivisionLevels</a> = 2
 }</td></tr>
<tr class="memdesc:aef51f2ea460e4edd104e4216bc197f5b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b" title="ON_SubD::AutomaticMeshToSubDContext indentifies a context where meshes can automatically be converted...">ON_SubD::AutomaticMeshToSubDContext</a> indentifies a context where meshes can automatically be converted to subds.  <a href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b">More...</a><br /></td></tr>
<tr class="separator:aef51f2ea460e4edd104e4216bc197f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e50466f1c3768aa762510fcd0fe69e8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ChainType</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8ac9f88e098f6fe4e4e112eeb05ccb9671">ChainType::Unset</a> = 0, 
<a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8a3c8a5f42bf19ef0a3bb3cc711b306fe0">ChainType::MixedTag</a> = 1, 
<a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8a459e8ddf41da27acf50b4a3dd67f5403">ChainType::EqualEdgeTag</a> = 2, 
<a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8a2dddc3785878ddb038ef340c32ff6365">ChainType::EqualEdgeAndVertexTag</a> = 3, 
<br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8a026664e24577e394192b2445ff3ada49">ChainType::EqualEdgeTagAndOrdinary</a> = 4, 
<a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8a316113003bff84ff40bd586026604e9a">ChainType::EqualEdgeAndVertexTagAndOrdinary</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:a3e50466f1c3768aa762510fcd0fe69e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">SubD::ChainType specifies what edge and vertex tag tests are used when creating edge chains.  <a href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">More...</a><br /></td></tr>
<tr class="separator:a3e50466f1c3768aa762510fcd0fe69e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a846f70b68ad8e33519d6e1293470e42b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b">NurbsSurfaceType</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42bac9f88e098f6fe4e4e112eeb05ccb9671">NurbsSurfaceType::Unset</a> = 0, 
<a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42ba3a69b34ce86dacb205936a8094f6c743">NurbsSurfaceType::Large</a> = 1, 
<a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42ba87f8a6ab85c9ced3702b4ea641ad4bb5">NurbsSurfaceType::Medium</a> = 2, 
<a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42ba2660064e68655415da2628c2ae2f7592">NurbsSurfaceType::Small</a> = 3, 
<br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42baed68856c2a7dd273f073f3403ef08934">NurbsSurfaceType::Unprocessed</a> = 4
<br />
 }</td></tr>
<tr class="memdesc:a846f70b68ad8e33519d6e1293470e42b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b" title="ON_SubD::NurbsSurfaceType specifies what type of NURBS surfaces are returned by ON_SubD....">ON_SubD::NurbsSurfaceType</a> specifies what type of NURBS surfaces are returned by <a class="el" href="class_o_n___sub_d.html#ae302078b9174b39d1332120b5c56c74a">ON_SubD.GetSurfaceNurbsFragments()</a>  <a href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b">More...</a><br /></td></tr>
<tr class="separator:a846f70b68ad8e33519d6e1293470e42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add35ac1773196f338b2b53e0e5ffdf50"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50">PatchStyle</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50ac9f88e098f6fe4e4e112eeb05ccb9671">PatchStyle::Unset</a> = 0, 
<a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50a086247a9b57fde6eefee2a0c4752242d">PatchStyle::Automatic</a> = 1, 
<a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50ae16a58ecfe5f43f85c33c4967cc0f1d2">PatchStyle::SingleFace</a> = 2, 
<a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50a18d58fde618e4a30e2dfdc122e693047">PatchStyle::TriangleFan</a> = 3, 
<br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50ab79b9fa2d98f59af3e135e2745754d31">PatchStyle::QuadOrTriangleFan</a> = 4, 
<a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50ac696e04dab021dfe28bfcee5ad4590ce">PatchStyle::Triangulated</a> = 5
<br />
 }</td></tr>
<tr class="memdesc:add35ac1773196f338b2b53e0e5ffdf50"><td class="mdescLeft">&#160;</td><td class="mdescRight">SubD::PatchStyle identifies the style of patch used to fill holes.  <a href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50">More...</a><br /></td></tr>
<tr class="separator:add35ac1773196f338b2b53e0e5ffdf50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf1f951df917b01dcf8e01af028c2e6e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6e">SubDFriendlyKnotType</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6eac9f88e098f6fe4e4e112eeb05ccb9671">SubDFriendlyKnotType::Unset</a> = 0, 
<a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6ea1812d32016245e0374a9ad0e0038b465">SubDFriendlyKnotType::UnclampedUniform</a> = 1, 
<a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6ea4eefc61c5cfe160c18751ab1eb05e191">SubDFriendlyKnotType::ClampedUniform</a> = 2, 
<a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6ea134a520e90d073f7ee15cef5d381a666">SubDFriendlyKnotType::ClampedPiecewiseUniform</a> = 4, 
<br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6eab3b0d3e7139cadb1d3336c1465eb1703">SubDFriendlyKnotType::Unfriendly</a> = 127
<br />
 }</td></tr>
<tr class="memdesc:acf1f951df917b01dcf8e01af028c2e6e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6e" title="ON_SubD::SubDFriendlyKnotType identifies the types of subd friendly NURBS knot vectors....">ON_SubD::SubDFriendlyKnotType</a> identifies the types of subd friendly NURBS knot vectors. SubD friendly NURBS curves and surfacaes are always cubic and nonrational. Any time there is a multiple knot, the 2nd derivative is zero at the corresponding parameter. SubD friendly NURBS curves are either periodic or have zero 2nd derivative at the ends.  <a href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6e">More...</a><br /></td></tr>
<tr class="separator:acf1f951df917b01dcf8e01af028c2e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669d9987c2605ae8d914ca28a1b6a07e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07e">VertexFacetType</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07eac9f88e098f6fe4e4e112eeb05ccb9671">VertexFacetType::Unset</a> = 0, 
<a class="el" href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07eab8c4c2cd6e0f11e2fbb894caeaeccef3">VertexFacetType::Tri</a> = 3, 
<a class="el" href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07eae9017664588010860a92ceb5f8fcb824">VertexFacetType::Quad</a> = 4, 
<a class="el" href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07ea4371d32113ff78b6d6ed2da59b10b2f5">VertexFacetType::Ngon</a> = 5, 
<br />
&#160;&#160;<a class="el" href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07ea699b4f79215d191584653efebf156e52">VertexFacetType::Mixed</a> = 0xFF
<br />
 }</td></tr>
<tr class="memdesc:a669d9987c2605ae8d914ca28a1b6a07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Summarizes the number of edges in faces in the whole object.  <a href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07e">More...</a><br /></td></tr>
<tr class="separator:a669d9987c2605ae8d914ca28a1b6a07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_class_o_n___object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_class_o_n___object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="class_o_n___object.html">ON_Object</a></td></tr>
<tr class="memitem:a7f520e987ffa14e71b06493340f9956c inherit pub_types_class_o_n___object"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956c">UserDataConflictResolution</a> : unsigned char { <br />
&#160;&#160;<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956caba9e24ac13ffcde7d2f6b554a33df7cd">UserDataConflictResolution::destination_object</a> = 0, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956ca34f1a09f0cf6c7e702b6aad2260c6b0f">UserDataConflictResolution::source_object</a> = 1, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956cad741a50b9ec9ac0de6491a83bc5b166f">UserDataConflictResolution::source_copycount_gt</a> = 2, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956ca35055504b8fe7e98f97c2b2ea6168ad2">UserDataConflictResolution::source_copycount_ge</a> = 3, 
<br />
&#160;&#160;<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956ca6c944380c6bd502741a041a82ad00a5a">UserDataConflictResolution::destination_copycount_gt</a> = 4, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956cadb77cee2050a09b500c679688e45a105">UserDataConflictResolution::destination_copycount_ge</a> = 5, 
<a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956ca880ec7882afd9386e91140bf4f77e594">UserDataConflictResolution::delete_item</a> = 6
<br />
 }</td></tr>
<tr class="separator:a7f520e987ffa14e71b06493340f9956c inherit pub_types_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a688da634c4a1257feaddf867a73c1c70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a688da634c4a1257feaddf867a73c1c70">ON_SubD</a> () <a class="el" href="group__open_n_u_r_b_s.html#ga1b9bbb0fba1d3a5fae3accc23a26e990">ON_NOEXCEPT</a></td></tr>
<tr class="separator:a688da634c4a1257feaddf867a73c1c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32fe9c0950281d076c018669942012b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a32fe9c0950281d076c018669942012b3">ON_SubD</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;src)</td></tr>
<tr class="separator:a32fe9c0950281d076c018669942012b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddde20f234ae734078c8ad54a26374b"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7ddde20f234ae734078c8ad54a26374b">~ON_SubD</a> ()</td></tr>
<tr class="separator:a7ddde20f234ae734078c8ad54a26374b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf6fb833f43db460ba7a7da6bd8ef24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class ON_SubDLevel &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afaf6fb833f43db460ba7a7da6bd8ef24">ActiveLevel</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:afaf6fb833f43db460ba7a7da6bd8ef24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30361600ed58615c9624775665468692"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a30361600ed58615c9624775665468692">ActiveLevelIndex</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a30361600ed58615c9624775665468692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad615fb238dd50d7777a59f669616d8"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4ad615fb238dd50d7777a59f669616d8">AddEdge</a> (class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v0, class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v1)</td></tr>
<tr class="separator:a4ad615fb238dd50d7777a59f669616d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dac9465bdfefec1c5d6411c7362c536"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7dac9465bdfefec1c5d6411c7362c536">AddEdge</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag, class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v0, class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v1)</td></tr>
<tr class="separator:a7dac9465bdfefec1c5d6411c7362c536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1632fe118521690d210566212b2285"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2f1632fe118521690d210566212b2285">AddEdgeForExperts</a> (unsigned int candidate_edge_id, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag, class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v0, double v0_sector_coefficient, class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v1, double v1_sector_coefficient, unsigned int initial_face_capacity)</td></tr>
<tr class="separator:a2f1632fe118521690d210566212b2285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10c401b54f35fa62be73d7b0062e89"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0c10c401b54f35fa62be73d7b0062e89">AddEdgeWithSectorCoefficients</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag, class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v0, double v0_sector_coefficient, class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v1, double v1_sector_coefficient)</td></tr>
<tr class="separator:a0c10c401b54f35fa62be73d7b0062e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3a6a44a0aeebf7592c4a28cb094306"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3b3a6a44a0aeebf7592c4a28cb094306">AddFace</a> (class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *edges, unsigned int edge_count)</td></tr>
<tr class="separator:a3b3a6a44a0aeebf7592c4a28cb094306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311fc42a57d47419e86ad66b869ef783"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a311fc42a57d47419e86ad66b869ef783">AddFace</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edges, unsigned int edge_count)</td></tr>
<tr class="separator:a311fc42a57d47419e86ad66b869ef783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34671d71cc51ac676e42eba10322c118"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a34671d71cc51ac676e42eba10322c118">AddFace</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;edges)</td></tr>
<tr class="separator:a34671d71cc51ac676e42eba10322c118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e811779cd172ba23845434449f2e50"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a20e811779cd172ba23845434449f2e50">AddFace</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edges)</td></tr>
<tr class="separator:a20e811779cd172ba23845434449f2e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f72e04db5bdc9c19f2d57aa1a0b644"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab1f72e04db5bdc9c19f2d57aa1a0b644">AddFaceEdgeConnection</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, unsigned int i, <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge, ON__UINT_PTR edge_direction)</td></tr>
<tr class="separator:ab1f72e04db5bdc9c19f2d57aa1a0b644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1501eb3bce73a47f548ade5cc989ef27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1501eb3bce73a47f548ade5cc989ef27">AddFaceEdgeConnection</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, unsigned int i, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> eptr)</td></tr>
<tr class="separator:a1501eb3bce73a47f548ade5cc989ef27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98fef592fc10f2a92b6080e68460770b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a98fef592fc10f2a92b6080e68460770b">AddFaceEdgeConnection</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, unsigned int i, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> eptr, bool bAddbAddFaceToRelativeVertex0, bool bAddbAddFaceToRelativeVertex1)</td></tr>
<tr class="separator:a98fef592fc10f2a92b6080e68460770b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6f050e9af542a171a6112a5b5069db"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8e6f050e9af542a171a6112a5b5069db">AddFaceForExperts</a> (unsigned candidate_face_id, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edge, unsigned int edge_count)</td></tr>
<tr class="separator:a8e6f050e9af542a171a6112a5b5069db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410c91d323081284b1b65be824ddbd42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a410c91d323081284b1b65be824ddbd42">AddFaceTexturePoints</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *texture_points, size_t texture_points_count) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a410c91d323081284b1b65be824ddbd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe732ecfb19ee77ac3214a13a86d64b"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#acbe732ecfb19ee77ac3214a13a86d64b">AddQuadFace</a> (class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge0, class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge1, class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge2, class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge3)</td></tr>
<tr class="separator:acbe732ecfb19ee77ac3214a13a86d64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38f61503e500f28e109f8b40d767fc8"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa38f61503e500f28e109f8b40d767fc8">AddQuadFace</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge0, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge1, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge2, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge3)</td></tr>
<tr class="separator:aa38f61503e500f28e109f8b40d767fc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83083a407f9ca2ba5e9388a5b4a99139"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a83083a407f9ca2ba5e9388a5b4a99139">AddSymmetrySetsToComponentList</a> (bool bAddVertexSymmetrySets, bool bAddEdgeSymmetrySets, bool bAddFaceSymmetrySets, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;component_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a83083a407f9ca2ba5e9388a5b4a99139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e727fba565a6a529561834d13dfa67"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a71e727fba565a6a529561834d13dfa67">AddSymmetrySetsToComponentList</a> (bool bAddVertexSymmetrySets, bool bAddEdgeSymmetrySets, bool bAddFaceSymmetrySets, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;component_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a71e727fba565a6a529561834d13dfa67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69e4995fa0ffcb9e2490a3e4d848e6da"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a69e4995fa0ffcb9e2490a3e4d848e6da">AddTriangleFace</a> (class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge0, class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge1, class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge2)</td></tr>
<tr class="separator:a69e4995fa0ffcb9e2490a3e4d848e6da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1e1026f4ebbafb1424178d6106ada59"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad1e1026f4ebbafb1424178d6106ada59">AddTriangleFace</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge0, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge1, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge2)</td></tr>
<tr class="separator:ad1e1026f4ebbafb1424178d6106ada59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2800bf03755d17eaa868c1a77766aec"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad2800bf03755d17eaa868c1a77766aec">AddVertex</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *P)</td></tr>
<tr class="separator:ad2800bf03755d17eaa868c1a77766aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e376f017ca46acd583b105fc4172e5a"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4e376f017ca46acd583b105fc4172e5a">AddVertex</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *P)</td></tr>
<tr class="separator:a4e376f017ca46acd583b105fc4172e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb65dfb0da98c2f5a42c92e107725f8"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afcb65dfb0da98c2f5a42c92e107725f8">AddVertexForExperts</a> (unsigned int candidate_vertex_id, <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *P, unsigned int initial_edge_capacity, unsigned int initial_face_capacity)</td></tr>
<tr class="separator:afcb65dfb0da98c2f5a42c92e107725f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811e33d12d90d557f0d435aa3da99d39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___aggregate_component_status.html">ON_AggregateComponentStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a811e33d12d90d557f0d435aa3da99d39">AggregateComponentStatus</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a811e33d12d90d557f0d435aa3da99d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a811e33d12d90d557f0d435aa3da99d39">More...</a><br /></td></tr>
<tr class="separator:a811e33d12d90d557f0d435aa3da99d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ccae911c49f201733d34dc379ed07b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a36ccae911c49f201733d34dc379ed07b">AggregateEdgeAttributes</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a36ccae911c49f201733d34dc379ed07b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d5a5be12479684e104c73dd22c2fd2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a29d5a5be12479684e104c73dd22c2fd2">AllocateFaceTexturePoints</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a29d5a5be12479684e104c73dd22c2fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881917f73d7881ff87251bfda8fab370"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a881917f73d7881ff87251bfda8fab370">Append</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, double tolerance, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> prefered_merged_edge_tag, bool bMergeAllCoincidentVertices, bool bMarkMergedComponents, bool bMarkAddedComponents)</td></tr>
<tr class="separator:a881917f73d7881ff87251bfda8fab370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f23c088a5a14856941571291cad8a94"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7f23c088a5a14856941571291cad8a94">Append</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, double tolerance, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> prefered_merged_edge_tag, bool bMergeAllCoincidentVertices, bool bMarkMergedComponents, bool bMarkAddedComponents, bool bPermitDisjointAppend, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *merge_map)</td></tr>
<tr class="separator:a7f23c088a5a14856941571291cad8a94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384f9d7e6ec6cf11df503eea0ad0a96c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a384f9d7e6ec6cf11df503eea0ad0a96c">Append</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, double tolerance, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> prefered_merged_edge_tag, bool bMergeAllCoincidentVertices, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;this_vertex_filter, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;subd_vertex_filter, bool bMarkMergedComponents, bool bMarkAddedComponents, bool bPermitDisjointAppend, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *merge_map)</td></tr>
<tr class="separator:a384f9d7e6ec6cf11df503eea0ad0a96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f0c261911cf32f4810d062eab06b0d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad0f0c261911cf32f4810d062eab06b0d">AppendDisjoint</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;disjoint_subd, bool bMarkOriginalComponents, bool bMarkAddedComponents)</td></tr>
<tr class="separator:ad0f0c261911cf32f4810d062eab06b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be19cb4701a0dc494f4867f902c9c18"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3be19cb4701a0dc494f4867f902c9c18">AppendDisjoint</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;disjoint_subd, bool bMarkOriginalComponents, bool bMarkAddedComponents, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *merge_map)</td></tr>
<tr class="separator:a3be19cb4701a0dc494f4867f902c9c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe601ddd0b4a9c188da6f26b369cee09"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#abe601ddd0b4a9c188da6f26b369cee09">AutoBridge</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> bridge_boundary_edge_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *start_edges, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *end_edges, unsigned int edge_count, bool bMarkNewFaces)</td></tr>
<tr class="separator:abe601ddd0b4a9c188da6f26b369cee09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba867f3b66fc1f1953e7c21d3f933133"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aba867f3b66fc1f1953e7c21d3f933133">AutoBridge</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> bridge_boundary_edge_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> start_edge, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> end_edge, bool bMarkNewFaces)</td></tr>
<tr class="separator:aba867f3b66fc1f1953e7c21d3f933133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bc8d532412456d1660621b23853765"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a68bc8d532412456d1660621b23853765">AutoMultiPatch</a> (<a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50">ON_SubD::PatchStyle</a> patch_style, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> patch_boundary_edge_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;unsorted_edges, bool bMarkNewFaces)</td></tr>
<tr class="separator:a68bc8d532412456d1660621b23853765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3240150bfa23a5ee6009c853f87a8dcf"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3240150bfa23a5ee6009c853f87a8dcf">AutoMultiPatch</a> (<a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50">ON_SubD::PatchStyle</a> patch_style, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> patch_edge_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;unsorted_edges, bool bMarkNewFaces)</td></tr>
<tr class="separator:a3240150bfa23a5ee6009c853f87a8dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e7c02ef85f24b041f3b6c9b572f520"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad9e7c02ef85f24b041f3b6c9b572f520">AutoPatch</a> (<a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50">ON_SubD::PatchStyle</a> patch_style, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> patch_boundary_edge_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edges, bool bMarkNewFaces)</td></tr>
<tr class="separator:ad9e7c02ef85f24b041f3b6c9b572f520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd25483350c3704ec0cce3451ee055c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afd25483350c3704ec0cce3451ee055c6">BrepForm</a> (<a class="el" href="class_o_n___brep.html">ON_Brep</a> *brep=nullptr) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:afd25483350c3704ec0cce3451ee055c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#afd25483350c3704ec0cce3451ee055c6">More...</a><br /></td></tr>
<tr class="separator:afd25483350c3704ec0cce3451ee055c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31e75e9f0cbdd8c55e725a30e36de20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae31e75e9f0cbdd8c55e725a30e36de20">ChangeGeometryContentSerialNumberForExperts</a> (bool bChangePreservesSymmetry)</td></tr>
<tr class="separator:ae31e75e9f0cbdd8c55e725a30e36de20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c62a3f7eacb09e487ef7215a13633a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a18c62a3f7eacb09e487ef7215a13633a">ChangeRenderContentSerialNumber</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a18c62a3f7eacb09e487ef7215a13633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb94e4ee32e9e8e9820d7801f50e29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0dcb94e4ee32e9e8e9820d7801f50e29">Clear</a> ()</td></tr>
<tr class="separator:a0dcb94e4ee32e9e8e9820d7801f50e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bdc135bc3376821f925f14a36d2680"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a44bdc135bc3376821f925f14a36d2680">ClearBoundingBox</a> () override</td></tr>
<tr class="memdesc:a44bdc135bc3376821f925f14a36d2680"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a44bdc135bc3376821f925f14a36d2680">More...</a><br /></td></tr>
<tr class="separator:a44bdc135bc3376821f925f14a36d2680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a610db54c408232cad99e9959c6090f79"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a610db54c408232cad99e9959c6090f79">ClearComponentGroupIds</a> (bool bClearVertexGroupIds, bool bClearEdgeGroupIds, bool bClearFaceGroupIds) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a610db54c408232cad99e9959c6090f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ab564d777e645245960c4dbad816208"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7ab564d777e645245960c4dbad816208">ClearComponentMarkBits</a> (bool bClearVertexMarkBits, bool bClearEdgeMarkBits, bool bClearFaceMarkBits) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7ab564d777e645245960c4dbad816208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad8a137f38839d415a98c6306b1e39bc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aad8a137f38839d415a98c6306b1e39bc">ClearComponentMarks</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aad8a137f38839d415a98c6306b1e39bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2434435be3a0eca6e1e51a986b9d4a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afa2434435be3a0eca6e1e51a986b9d4a">ClearComponentMarks</a> (bool bClearVertexMarks, bool bClearEdgeMarks, bool bClearFaceMarks, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; *marked_component_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:afa2434435be3a0eca6e1e51a986b9d4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1954538284e3331fd83a1012a284398"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad1954538284e3331fd83a1012a284398">ClearComponentStates</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_to_clear) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:ad1954538284e3331fd83a1012a284398"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#ad1954538284e3331fd83a1012a284398">More...</a><br /></td></tr>
<tr class="separator:ad1954538284e3331fd83a1012a284398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1c99fc75feba4249117256e6ba24ca"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aef1c99fc75feba4249117256e6ba24ca">ClearComponentStates</a> (<a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_to_clear) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:aef1c99fc75feba4249117256e6ba24ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#aef1c99fc75feba4249117256e6ba24ca">More...</a><br /></td></tr>
<tr class="separator:aef1c99fc75feba4249117256e6ba24ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2c50a7e3006488c4f1400e728cd5c0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7d2c50a7e3006488c4f1400e728cd5c0">ClearComponentStates</a> (<a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> component_ptr, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_to_clear) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7d2c50a7e3006488c4f1400e728cd5c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798bbf724f95bcc7d5d0dc10d8525d0f"><td class="memItemLeft" align="right" valign="top">**void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a798bbf724f95bcc7d5d0dc10d8525d0f">ClearControlNetComponentTree</a> ()</td></tr>
<tr class="separator:a798bbf724f95bcc7d5d0dc10d8525d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c2403537aa954dc6c09a750959cc6e7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6c2403537aa954dc6c09a750959cc6e7">ClearEdgeGroupIds</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a6c2403537aa954dc6c09a750959cc6e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9f4432b4391c046bda3e86db1fe232"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7e9f4432b4391c046bda3e86db1fe232">ClearEdgeMarkBits</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7e9f4432b4391c046bda3e86db1fe232"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67aa038ebc116d7b951d8ead490f61b9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a67aa038ebc116d7b951d8ead490f61b9">ClearEdgeMarks</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a67aa038ebc116d7b951d8ead490f61b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1cd072b07905979be7f0fc453b11cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5e1cd072b07905979be7f0fc453b11cc">ClearEvaluationCache</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a5e1cd072b07905979be7f0fc453b11cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7469bafd0acc8f54da80c0a310b8ac48"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7469bafd0acc8f54da80c0a310b8ac48">ClearFaceGroupIds</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7469bafd0acc8f54da80c0a310b8ac48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452daafb274f648b547220f25f8e3bc2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a452daafb274f648b547220f25f8e3bc2">ClearFaceMarkBits</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a452daafb274f648b547220f25f8e3bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf941338bad8d3e23b75f5d576a27c36"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aaf941338bad8d3e23b75f5d576a27c36">ClearFaceMarks</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aaf941338bad8d3e23b75f5d576a27c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e6e7feaadfde6d7a8de414b1dcf25e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a53e6e7feaadfde6d7a8de414b1dcf25e">ClearFacePackIds</a> ()</td></tr>
<tr class="separator:a53e6e7feaadfde6d7a8de414b1dcf25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac88e1a2f207ab6cacba712ae0d8357"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aaac88e1a2f207ab6cacba712ae0d8357">ClearFacePackingTopologyHashForExperts</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aaac88e1a2f207ab6cacba712ae0d8357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2584647056fe328150cfcc91a504776f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2584647056fe328150cfcc91a504776f">ClearFragmentColors</a> (bool bClearFragmentColorsMappingTag)</td></tr>
<tr class="separator:a2584647056fe328150cfcc91a504776f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacccdce5b56d8690e760b262f7c0798"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#abacccdce5b56d8690e760b262f7c0798">ClearFragmentTextureCoordinatesTextureSettingsHash</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:abacccdce5b56d8690e760b262f7c0798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3182a3f78c700bef1bbdf42f469477d"><td class="memItemLeft" align="right" valign="top">**void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af3182a3f78c700bef1bbdf42f469477d">ClearFragmentTree</a> ()</td></tr>
<tr class="separator:af3182a3f78c700bef1bbdf42f469477d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6451bb5d144ad787d21a5d3fda519798"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6451bb5d144ad787d21a5d3fda519798">ClearGroupIds</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a6451bb5d144ad787d21a5d3fda519798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ad622bf4ffd961e703fb8b775ada0f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad0ad622bf4ffd961e703fb8b775ada0f">ClearHigherSubdivisionLevels</a> (unsigned int max_level_index)</td></tr>
<tr class="separator:ad0ad622bf4ffd961e703fb8b775ada0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7797500986d963d8db4bb3b67781c397"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7797500986d963d8db4bb3b67781c397">ClearInactiveLevels</a> ()</td></tr>
<tr class="separator:a7797500986d963d8db4bb3b67781c397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb389cd1ec487746e818b7e3be79d435"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#adb389cd1ec487746e818b7e3be79d435">ClearLowerSubdivisionLevels</a> (unsigned int min_level_index)</td></tr>
<tr class="separator:adb389cd1ec487746e818b7e3be79d435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6ec96fb185289e07b1f43a867dc903"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9e6ec96fb185289e07b1f43a867dc903">ClearMarkBits</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a9e6ec96fb185289e07b1f43a867dc903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ab2ee7a336c569564f21ce10975cb3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a76ab2ee7a336c569564f21ce10975cb3">ClearPerFaceColors</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a76ab2ee7a336c569564f21ce10975cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4de6e40238e6110215a6ee5b021dce43"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4de6e40238e6110215a6ee5b021dce43">ClearPerFaceMaterialChannelIndices</a> ()</td></tr>
<tr class="separator:a4de6e40238e6110215a6ee5b021dce43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7bfbe956fdfc9ddcf1eab6be822026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5d7bfbe956fdfc9ddcf1eab6be822026">ClearSymmetry</a> ()</td></tr>
<tr class="separator:a5d7bfbe956fdfc9ddcf1eab6be822026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa366f471d28fdda4831a9d3cbabaee0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa366f471d28fdda4831a9d3cbabaee0d">ClearSymmetrySetForExperts</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge)</td></tr>
<tr class="separator:aa366f471d28fdda4831a9d3cbabaee0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa7df2bf0a7c430c3207a818d46a6b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7aa7df2bf0a7c430c3207a818d46a6b3">ClearSymmetrySetForExperts</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face)</td></tr>
<tr class="separator:a7aa7df2bf0a7c430c3207a818d46a6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355c1e1a657fde002c604d517f520e30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a355c1e1a657fde002c604d517f520e30">ClearSymmetrySetForExperts</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex)</td></tr>
<tr class="separator:a355c1e1a657fde002c604d517f520e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9027a4ff9027687fa6673c659facde54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9027a4ff9027687fa6673c659facde54">ClearSymmetrySetForExperts</a> (<a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> cptr)</td></tr>
<tr class="separator:a9027a4ff9027687fa6673c659facde54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fb133f4e932fd5d6e20f23bd7c6457"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae3fb133f4e932fd5d6e20f23bd7c6457">ClearSymmetrySetNextForExperts</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge)</td></tr>
<tr class="separator:ae3fb133f4e932fd5d6e20f23bd7c6457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed46aa02e8c55fe47c8a2ee4d356d452"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aed46aa02e8c55fe47c8a2ee4d356d452">ClearSymmetrySetNextForExperts</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face)</td></tr>
<tr class="separator:aed46aa02e8c55fe47c8a2ee4d356d452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ba48467e87f296776f7684deeb74ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9ba48467e87f296776f7684deeb74ff6">ClearSymmetrySetNextForExperts</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex)</td></tr>
<tr class="separator:a9ba48467e87f296776f7684deeb74ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeaa049e65f0ab7aed082efabb4107b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aeeaa049e65f0ab7aed082efabb4107b6">ClearSymmetrySetNextForExperts</a> (<a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> component)</td></tr>
<tr class="separator:aeeaa049e65f0ab7aed082efabb4107b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915fd32959b98d44c68ac4df536bdb3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a915fd32959b98d44c68ac4df536bdb3e">ClearSymmetrySetsForExperts</a> ()</td></tr>
<tr class="separator:a915fd32959b98d44c68ac4df536bdb3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0541fa1dd9f679206bce1abdbe670003"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0541fa1dd9f679206bce1abdbe670003">ClearTexturePoints</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a0541fa1dd9f679206bce1abdbe670003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6dfebd7c397831d32ba389ea17a239c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa6dfebd7c397831d32ba389ea17a239c">ClearVertexGroupIds</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa6dfebd7c397831d32ba389ea17a239c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc886c1d71f9e871fafd4013f57a4cb9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afc886c1d71f9e871fafd4013f57a4cb9">ClearVertexMarkBits</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:afc886c1d71f9e871fafd4013f57a4cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedeaaa535804d339195bf24747ef0df5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aedeaaa535804d339195bf24747ef0df5">ClearVertexMarks</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aedeaaa535804d339195bf24747ef0df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8358c77769549add432045b791330243"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8358c77769549add432045b791330243">CombineBoundaryEdgeChains</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;edge_chain0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;edge_chain1, double combined_edge_location, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> combined_edge_tag)</td></tr>
<tr class="separator:a8358c77769549add432045b791330243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df65caf4556ea0adab42aa14c0f1fa5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4df65caf4556ea0adab42aa14c0f1fa5">CombineBoundaryEdgeChains</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;edge_chain0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;edge_chain1, double combined_edge_location, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> combined_edge_tag)</td></tr>
<tr class="separator:a4df65caf4556ea0adab42aa14c0f1fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377f2a7170542414f2cf5863532ae20c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a377f2a7170542414f2cf5863532ae20c">CombineBoundaryEdgeChains</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;edge_chain0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;edge_chain1, double combined_edge_location, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> combined_edge_tag)</td></tr>
<tr class="separator:a377f2a7170542414f2cf5863532ae20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ae8d928ec36daff324c26e86727395"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a40ae8d928ec36daff324c26e86727395">CombineBoundaryEdgeChains</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chain0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chain1, double combined_edge_location, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> combined_edge_tag)</td></tr>
<tr class="separator:a40ae8d928ec36daff324c26e86727395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0811d8d493cdf77130775f29630bd25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac0811d8d493cdf77130775f29630bd25">CombineBoundaryEdges</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge1, double merged_edge_location, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> merged_edge_tag)</td></tr>
<tr class="separator:ac0811d8d493cdf77130775f29630bd25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1df3bee27d24d07a86db08316cbcf73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab1df3bee27d24d07a86db08316cbcf73">CombineBoundaryEdges</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> edge1, double merged_edge_location, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> merged_edge_tag)</td></tr>
<tr class="separator:ab1df3bee27d24d07a86db08316cbcf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4097fc1b7edc7e899467bd17851a316"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad4097fc1b7edc7e899467bd17851a316">CombineBoundaryVertices</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;ci_list, <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> combined_vertex_tag)</td></tr>
<tr class="separator:ad4097fc1b7edc7e899467bd17851a316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab569b7d09a215065c2222bd61c720889"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab569b7d09a215065c2222bd61c720889">CombineBoundaryVertices</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;vertex_list, <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> combined_vertex_tag)</td></tr>
<tr class="separator:ab569b7d09a215065c2222bd61c720889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec68eaf8aaea7464da391e811a1cf4b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2ec68eaf8aaea7464da391e811a1cf4b">CombineBoundaryVertices</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex1, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> combined_vertex_control_net_point, <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> combined_vertex_tag)</td></tr>
<tr class="separator:a2ec68eaf8aaea7464da391e811a1cf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff1cca32b3c5ec738dcead27ce15584e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aff1cca32b3c5ec738dcead27ce15584e">ComponentIndex</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:aff1cca32b3c5ec738dcead27ce15584e"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#aff1cca32b3c5ec738dcead27ce15584e">More...</a><br /></td></tr>
<tr class="separator:aff1cca32b3c5ec738dcead27ce15584e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49517e4c8b172bdfa7cf78f3711fb997"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a49517e4c8b172bdfa7cf78f3711fb997">ComponentPtrFromComponentIndex</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count, bool bIncludeVertices, bool bIncludeEdges, bool bIncludeFaces, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;cptr_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a49517e4c8b172bdfa7cf78f3711fb997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adedd46d29370a5a8885dba3830fbf8df"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#adedd46d29370a5a8885dba3830fbf8df">ComponentPtrFromComponentIndex</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;cptr_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:adedd46d29370a5a8885dba3830fbf8df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12cbee173aeab61f2b894403b6c18db6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a12cbee173aeab61f2b894403b6c18db6">ComponentPtrFromComponentIndex</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a12cbee173aeab61f2b894403b6c18db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4254106e4a203dfb14dac06e84371708"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4254106e4a203dfb14dac06e84371708">ComponentStatusSerialNumber</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a4254106e4a203dfb14dac06e84371708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda5bb6a04c93f681cf672ca9208abc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afda5bb6a04c93f681cf672ca9208abc4">ContentIsSymmetric</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:afda5bb6a04c93f681cf672ca9208abc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c3292d353aaf0f19a816f83bfc9d1b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0c3292d353aaf0f19a816f83bfc9d1b0">CopyEvaluationCacheForExperts</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;src)</td></tr>
<tr class="separator:a0c3292d353aaf0f19a816f83bfc9d1b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ca314d3522042865ab415447128703"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a97ca314d3522042865ab415447128703">CreateRotateSymmetryFromTwoFacesAndAxis</a> (unsigned primary_face_id, unsigned secondary_face_id, <a class="el" href="class_o_n___line.html">ON_Line</a> rotation_axis, double cleanup_tolerance) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a97ca314d3522042865ab415447128703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d9181a6e9f55eb6d8b5c3c6f74c9a04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1d9181a6e9f55eb6d8b5c3c6f74c9a04">CreateSymmetryPrimaryMotif</a> (<a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a> symmetry, <a class="el" href="class_o_n___sub_d_component_id_list.html">ON_SubDComponentIdList</a> &amp;motif_outer_vertex_list, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a1d9181a6e9f55eb6d8b5c3c6f74c9a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956cafc1882293ecefaa615959c001c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#gaea03c6f4bab106103ada72c766f7fe5c">ON__UINT32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a956cafc1882293ecefaa615959c001c4">DataCRC</a> (<a class="el" href="group__open_n_u_r_b_s.html#gaea03c6f4bab106103ada72c766f7fe5c">ON__UINT32</a> current_remainder) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a956cafc1882293ecefaa615959c001c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a956cafc1882293ecefaa615959c001c4">More...</a><br /></td></tr>
<tr class="separator:a956cafc1882293ecefaa615959c001c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d47a7372b1663e5440d1009b77d4807"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5d47a7372b1663e5440d1009b77d4807">DeleteComponents</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count) override</td></tr>
<tr class="memdesc:a5d47a7372b1663e5440d1009b77d4807"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a5d47a7372b1663e5440d1009b77d4807">More...</a><br /></td></tr>
<tr class="separator:a5d47a7372b1663e5440d1009b77d4807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33929c32bbeff4275c5c3cf75ae747b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae33929c32bbeff4275c5c3cf75ae747b">DeleteComponents</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;cptr_list, bool bMarkDeletedFaceEdges)</td></tr>
<tr class="separator:ae33929c32bbeff4275c5c3cf75ae747b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259284c37d1af92e9f811f99720ee355"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a259284c37d1af92e9f811f99720ee355">DeleteComponents</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *cptr_list, size_t cptr_count, bool bMarkDeletedFaceEdges)</td></tr>
<tr class="separator:a259284c37d1af92e9f811f99720ee355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc05d8d257e41d364a3a24730000eef1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afc05d8d257e41d364a3a24730000eef1">DeleteComponentsForExperts</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *cptr_list, size_t cptr_count, bool bDeleteIsolatedEdges, bool bUpdateTagsAndCoefficients, bool bMarkDeletedFaceEdges)</td></tr>
<tr class="separator:afc05d8d257e41d364a3a24730000eef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aead0ac8554846604f41d6a022c783c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4aead0ac8554846604f41d6a022c783c">DeleteFacesOnPlane</a> (<a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a> plane_equation, double distance_tolerance)</td></tr>
<tr class="separator:a4aead0ac8554846604f41d6a022c783c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab30470bf102b7c6388ee3b62bfa57e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aab30470bf102b7c6388ee3b62bfa57e7">DeleteMarkedComponents</a> (bool bDeleteMarkedComponents, <a class="el" href="group__open_n_u_r_b_s.html#ga3b6aca42cfeb22b5315f542d04ba024c">ON__UINT8</a> mark_bits, bool bMarkDeletedFaceEdges)</td></tr>
<tr class="separator:aab30470bf102b7c6388ee3b62bfa57e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae68b7e6139ae014a80665878e80307d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae68b7e6139ae014a80665878e80307d2">DeleteMarkedComponentsForExperts</a> (bool bDeleteMarkedComponents, <a class="el" href="group__open_n_u_r_b_s.html#ga3b6aca42cfeb22b5315f542d04ba024c">ON__UINT8</a> mark_bits, bool bDeleteIsolatedEdges, bool bUpdateTagsAndCoefficients, bool bMarkDeletedFaceEdges)</td></tr>
<tr class="separator:ae68b7e6139ae014a80665878e80307d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8074d561bee1dc38fcef3cb2e8b19b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5f8074d561bee1dc38fcef3cb2e8b19b">Destroy</a> ()</td></tr>
<tr class="separator:a5f8074d561bee1dc38fcef3cb2e8b19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc3756ee7209297f559f4f48d82ccbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2cc3756ee7209297f559f4f48d82ccbe">DestroyRuntimeCache</a> (bool bDelete=true) override</td></tr>
<tr class="memdesc:a2cc3756ee7209297f559f4f48d82ccbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a2cc3756ee7209297f559f4f48d82ccbe">More...</a><br /></td></tr>
<tr class="separator:a2cc3756ee7209297f559f4f48d82ccbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4b47df189a6ba5a8b1e60b2c5879f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1c4b47df189a6ba5a8b1e60b2c5879f1">Dimension</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a1c4b47df189a6ba5a8b1e60b2c5879f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a1c4b47df189a6ba5a8b1e60b2c5879f1">More...</a><br /></td></tr>
<tr class="separator:a1c4b47df189a6ba5a8b1e60b2c5879f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a33810f2fae5af6f51a87ffc8d4184c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6a33810f2fae5af6f51a87ffc8d4184c">DissolveOrDelete</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;ci_list)</td></tr>
<tr class="separator:a6a33810f2fae5af6f51a87ffc8d4184c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48ab98172ebd8edfa28fd78c53fd9094"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a48ab98172ebd8edfa28fd78c53fd9094">DissolveOrDelete</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;cptr_list)</td></tr>
<tr class="separator:a48ab98172ebd8edfa28fd78c53fd9094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c206f8957113a813a9a97b13eb4a08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a72c206f8957113a813a9a97b13eb4a08">Dump</a> (<a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a72c206f8957113a813a9a97b13eb4a08"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a72c206f8957113a813a9a97b13eb4a08">More...</a><br /></td></tr>
<tr class="separator:a72c206f8957113a813a9a97b13eb4a08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae125d90f0c3383a645ad8dda9a94b95c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae125d90f0c3383a645ad8dda9a94b95c">DumpTopology</a> (<a class="el" href="class_o_n__2udex.html">ON_2udex</a> vertex_id_range, <a class="el" href="class_o_n__2udex.html">ON_2udex</a> edge_id_range, <a class="el" href="class_o_n__2udex.html">ON_2udex</a> face_id_range, <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ae125d90f0c3383a645ad8dda9a94b95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace95b06b8a34ca6a1b1f4ceb72e6bca3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ace95b06b8a34ca6a1b1f4ceb72e6bca3">DumpTopology</a> (<a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ace95b06b8a34ca6a1b1f4ceb72e6bca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7d67d77d74a6ad4a82fcc722599b4c"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_edge_array.html">ON_SubDEdgeArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8f7d67d77d74a6ad4a82fcc722599b4c">EdgeArray</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a8f7d67d77d74a6ad4a82fcc722599b4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5da40c3ae92bcbc1c0c9aac31a3d1dc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae5da40c3ae92bcbc1c0c9aac31a3d1dc">EdgeCount</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ae5da40c3ae92bcbc1c0c9aac31a3d1dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92f58d8724ce3201056354724f658bc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a92f58d8724ce3201056354724f658bc0">EdgeFromComponentIndex</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a92f58d8724ce3201056354724f658bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3856d4b06981f767afe787cf54577e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6e3856d4b06981f767afe787cf54577e">EdgeFromId</a> (unsigned int edge_id) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a6e3856d4b06981f767afe787cf54577e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b96a1b8c9e000a297c59242910be6b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8b96a1b8c9e000a297c59242910be6b1">EdgeHash</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga7901fb222b1b25e32978f0b34ba7234a">ON_SubDHashType</a> hash_type) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a8b96a1b8c9e000a297c59242910be6b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304d043dcf7858d62c0859c7fa42865c"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_edge_iterator.html">ON_SubDEdgeIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a304d043dcf7858d62c0859c7fa42865c">EdgeIterator</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a304d043dcf7858d62c0859c7fa42865c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1058f674502c9091370a2114412c08bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1058f674502c9091370a2114412c08bc">EvaluatePoint</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___obj_ref.html">ON_ObjRef</a> &amp;objref, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;P) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a1058f674502c9091370a2114412c08bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a1058f674502c9091370a2114412c08bc">More...</a><br /></td></tr>
<tr class="separator:a1058f674502c9091370a2114412c08bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb8987f5ddefe2a8b4f70f813938008"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#accb8987f5ddefe2a8b4f70f813938008">ExpandEdges</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;unsorted_edges, <a class="el" href="class_o_n___sub_d_expand_edges_parameters.html">ON_SubDExpandEdgesParameters</a> parameters)</td></tr>
<tr class="separator:accb8987f5ddefe2a8b4f70f813938008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0f4155000807ffd72aea0b1eac5f71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3c0f4155000807ffd72aea0b1eac5f71">ExpandEdges</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;unsorted_edges, <a class="el" href="class_o_n___sub_d_expand_edges_parameters.html">ON_SubDExpandEdgesParameters</a> parameters)</td></tr>
<tr class="separator:a3c0f4155000807ffd72aea0b1eac5f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3b8b7382167167201aab69c9621e92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7d3b8b7382167167201aab69c9621e92">ExpandEdges</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edges, <a class="el" href="class_o_n___sub_d_expand_edges_parameters.html">ON_SubDExpandEdgesParameters</a> parameters)</td></tr>
<tr class="separator:a7d3b8b7382167167201aab69c9621e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae13ab63601e290727592397aa636610"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aae13ab63601e290727592397aa636610">ExtractMarkedComponents</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga3b6aca42cfeb22b5315f542d04ba024c">ON__UINT8</a> mark_bits, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aae13ab63601e290727592397aa636610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d86e948b85ff135ca1645a2b3703493"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9d86e948b85ff135ca1645a2b3703493">Extrude</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform)</td></tr>
<tr class="separator:a9d86e948b85ff135ca1645a2b3703493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff38b984cc9b5877da935d3ef95a3b2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1ff38b984cc9b5877da935d3ef95a3b2">ExtrudeComponents</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count)</td></tr>
<tr class="separator:a1ff38b984cc9b5877da935d3ef95a3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da5c9e01508044cc5db2772e2eceeee"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0da5c9e01508044cc5db2772e2eceeee">ExtrudeComponents</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count, bool bExtrudeBoundaries, bool bPermitNonManifoldEdgeCreation)</td></tr>
<tr class="separator:a0da5c9e01508044cc5db2772e2eceeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cf910bffc3fd80e873f360081caa7d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a67cf910bffc3fd80e873f360081caa7d">ExtrudeComponents</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *cptr_list, size_t cptr_count)</td></tr>
<tr class="separator:a67cf910bffc3fd80e873f360081caa7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673961e3b9a2a8f6d68a4974e93766f0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a673961e3b9a2a8f6d68a4974e93766f0">ExtrudeComponents</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *cptr_list, size_t cptr_count, bool bExtrudeBoundaries, bool bPermitNonManifoldEdgeCreation)</td></tr>
<tr class="separator:a673961e3b9a2a8f6d68a4974e93766f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa587d66b116360d6e6e8b109aa6ff43a"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face_array.html">ON_SubDFaceArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa587d66b116360d6e6e8b109aa6ff43a">FaceArray</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa587d66b116360d6e6e8b109aa6ff43a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0b2ca2e120a29e35d1a7cb2ae3a349"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:afd0b2ca2e120a29e35d1a7cb2ae3a349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70d637396bd1256f0bc82b125dc0171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac70d637396bd1256f0bc82b125dc0171">FaceFromComponentIndex</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ac70d637396bd1256f0bc82b125dc0171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986798efe2b246bf3d10f7083ba2c015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a986798efe2b246bf3d10f7083ba2c015">FaceFromId</a> (unsigned int face_id) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a986798efe2b246bf3d10f7083ba2c015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95b59a21f20e65eda6bfeda262ee848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa95b59a21f20e65eda6bfeda262ee848">FaceHash</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga7901fb222b1b25e32978f0b34ba7234a">ON_SubDHashType</a> hash_type) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa95b59a21f20e65eda6bfeda262ee848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1584fe08574d979d876404880971d3cd"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face_iterator.html">ON_SubDFaceIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1584fe08574d979d876404880971d3cd">FaceIterator</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a1584fe08574d979d876404880971d3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e1be9442ba79f4f717cad5d62b49c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a35e1be9442ba79f4f717cad5d62b49c9">FacePackingId</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a35e1be9442ba79f4f717cad5d62b49c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d9159a92026d46817fcc09b8ac5229"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a97d9159a92026d46817fcc09b8ac5229">FacePackingIsValid</a> (bool bIfValidThenUpdateFacePackingTopologyHash) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a97d9159a92026d46817fcc09b8ac5229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae32373a2c26ae53a008f9f717919d9a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_hash.html">ON_SubDHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae32373a2c26ae53a008f9f717919d9a7">FacePackingTopologyHash</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ae32373a2c26ae53a008f9f717919d9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33584a16cca239644a5be3ab243f1d14"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a33584a16cca239644a5be3ab243f1d14">FacesArePacked</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a33584a16cca239644a5be3ab243f1d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2083fce55da4501da8c2df12f8811f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa2083fce55da4501da8c2df12f8811f7">FindEdge</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v1) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa2083fce55da4501da8c2df12f8811f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae83f35ec8dcb63f07a198b209d6046c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae83f35ec8dcb63f07a198b209d6046c3">FindOrAddEdge</a> (class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v0, class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v1)</td></tr>
<tr class="separator:ae83f35ec8dcb63f07a198b209d6046c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c40b95139bd90083c50393d78b0a3ed"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8c40b95139bd90083c50393d78b0a3ed">FindOrAddFace</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> new_edge_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *face_vertices[], size_t face_vertex_count)</td></tr>
<tr class="separator:a8c40b95139bd90083c50393d78b0a3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64138b0bcf8e0b791a2c526114941ed8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a64138b0bcf8e0b791a2c526114941ed8">FindOrAddVertex</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *control_net_point, double distance_tolerance)</td></tr>
<tr class="separator:a64138b0bcf8e0b791a2c526114941ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8210fce6b1e365c51b623ab2c2e9f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aee8210fce6b1e365c51b623ab2c2e9f4">FindVertex</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *control_net_point, double distance_tolerance) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aee8210fce6b1e365c51b623ab2c2e9f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650426a4aec98892ea13ea36328082e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a650426a4aec98892ea13ea36328082e3">FirstEdge</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a650426a4aec98892ea13ea36328082e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37fdfc8a70690725734fb6dee5ff3e54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a37fdfc8a70690725734fb6dee5ff3e54">FirstFace</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a37fdfc8a70690725734fb6dee5ff3e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f419c300415321b26bb9b40647df86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a90f419c300415321b26bb9b40647df86">FirstVertex</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a90f419c300415321b26bb9b40647df86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7465243080b065bff2748d7197a83f58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7465243080b065bff2748d7197a83f58">FragmentColorsMappingTag</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7465243080b065bff2748d7197a83f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7149920a9bed945f7e368b0e5cb21ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad7149920a9bed945f7e368b0e5cb21ee">FragmentColorsSettingsHash</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ad7149920a9bed945f7e368b0e5cb21ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df5adfe19107926126f077722831b50"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7df5adfe19107926126f077722831b50">FragmentTextureCoordinatesTextureSettingsHash</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7df5adfe19107926126f077722831b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ad6d6d37db0ca96497b734526b42a6"><td class="memItemLeft" align="right" valign="top">*ON_RTreeRef&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad1ad6d6d37db0ca96497b734526b42a6">FragmentTree</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ad1ad6d6d37db0ca96497b734526b42a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07d885e05ed47e9ed99ef3428814c07"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae07d885e05ed47e9ed99ef3428814c07">GeometryContentSerialNumber</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ae07d885e05ed47e9ed99ef3428814c07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddfa18eda363a886e80542319129578"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8ddfa18eda363a886e80542319129578">GeometryHash</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a8ddfa18eda363a886e80542319129578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce3c25318be659eff5607e1df04d008"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3ce3c25318be659eff5607e1df04d008">GetBBox</a> (double *boxmin, double *boxmax, bool bGrowBox=false) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a3ce3c25318be659eff5607e1df04d008"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> GetBBox override <br  />
  <a href="class_o_n___sub_d.html#a3ce3c25318be659eff5607e1df04d008">More...</a><br /></td></tr>
<tr class="separator:a3ce3c25318be659eff5607e1df04d008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bdbbe6aefba0a006a5e7ac097691882"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8bdbbe6aefba0a006a5e7ac097691882">GetBoundaryEdgeChains</a> (unsigned int minimum_face_count, unsigned int maximum_face_count, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;boundary_edge_chains) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a8bdbbe6aefba0a006a5e7ac097691882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67b9add6051da22ab993c305b002471"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad67b9add6051da22ab993c305b002471">GetComponentStatus</a> (bool bGetVertexStatus, bool bGetEdgeStatus, bool bGetFaceStatus, bool bClearStatus, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> status_mask, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; &amp;component_list, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> &gt; &amp;status_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ad67b9add6051da22ab993c305b002471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719e30ea56a1b5ed36141f0a22c5ef6d"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a719e30ea56a1b5ed36141f0a22c5ef6d">GetComponentsWithSetStates</a> (<a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_filter, bool bAllEqualStates, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;components) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a719e30ea56a1b5ed36141f0a22c5ef6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a719e30ea56a1b5ed36141f0a22c5ef6d">More...</a><br /></td></tr>
<tr class="separator:a719e30ea56a1b5ed36141f0a22c5ef6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0c90f41c021cf62f1576f19d5b94175"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af0c90f41c021cf62f1576f19d5b94175">GetComponentsWithSetStates</a> (<a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_filter, bool bAllEqualStates, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;components_with_set_states) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:af0c90f41c021cf62f1576f19d5b94175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa142a25b13fa107f35eebcf57d81fd54"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa142a25b13fa107f35eebcf57d81fd54">GetConnectedRegions</a> (bool bManifoldRegions, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> * &gt; &amp;connected_regions) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa142a25b13fa107f35eebcf57d81fd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd222f967bbbce9f430011e8f5636e4"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1cd222f967bbbce9f430011e8f5636e4">GetControlNetMesh</a> (class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *mesh, <a class="el" href="group__open_n_u_r_b_s.html#ga870f5c5708f131b6a2bdf3d138607fd9">ON_SubDGetControlNetMeshPriority</a> priority) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a1cd222f967bbbce9f430011e8f5636e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274c1b5f9e52b7d827f7e7071fca66b6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a274c1b5f9e52b7d827f7e7071fca66b6">GetMarkedComponents</a> (bool bAddMarkedComponents, <a class="el" href="group__open_n_u_r_b_s.html#ga3b6aca42cfeb22b5315f542d04ba024c">ON__UINT8</a> mark_bits, bool bIncludeVertices, bool bIncludeEdges, bool bIncludeFaces, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; class <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;component_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a274c1b5f9e52b7d827f7e7071fca66b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e477b81ca2cff783f48532a2634f2b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a52e477b81ca2cff783f48532a2634f2b">GetMarkedComponents</a> (bool bIncludeVertices, bool bIncludeEdges, bool bIncludeFaces, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; &amp;marked_component_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a52e477b81ca2cff783f48532a2634f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6ebb34429c0c98d75c37e0dce9019e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0e6ebb34429c0c98d75c37e0dce9019e">GetMeshFragments</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_display_parameters.html">ON_SubDDisplayParameters</a> &amp;display_parameters, ON__UINT_PTR fragment_callback_context, bool(*fragment_callback_function)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_mesh_fragment.html">ON_SubDMeshFragment</a> *)) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a0e6ebb34429c0c98d75c37e0dce9019e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64c6cb08739888547abb010c18a45a90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a64c6cb08739888547abb010c18a45a90">GetSurfaceBrep</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_to_brep_parameters.html">ON_SubDToBrepParameters</a> &amp;brep_parameters, <a class="el" href="class_o_n___brep.html">ON_Brep</a> *destination_brep) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a64c6cb08739888547abb010c18a45a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a291fbf37c80259b898352d90d7b4d70e"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a291fbf37c80259b898352d90d7b4d70e">GetSurfaceMesh</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_display_parameters.html">ON_SubDDisplayParameters</a> &amp;display_parameters, class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *mesh) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a291fbf37c80259b898352d90d7b4d70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00f960eb4cdb632a0b48eed19f0d292"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae00f960eb4cdb632a0b48eed19f0d292">GetSurfaceNurbs</a> (<a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b">ON_SubD::NurbsSurfaceType</a> nurbs_surface_type, ON__UINT_PTR callback_context, bool(*nurbs_callback_function)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face_region.html">ON_SubDFaceRegion</a> &amp;, class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *)) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ae00f960eb4cdb632a0b48eed19f0d292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a484806f2c1bb5f03768a0f3d228c3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae9a484806f2c1bb5f03768a0f3d228c3">GetSurfaceNurbs</a> (<a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b">ON_SubD::NurbsSurfaceType</a> nurbs_surface_type, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> * &gt; &amp;patches) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ae9a484806f2c1bb5f03768a0f3d228c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac290009042b3e05cbc26e2d8b5c3113f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac290009042b3e05cbc26e2d8b5c3113f">GetSurfaceNurbs</a> (<a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b">ON_SubD::NurbsSurfaceType</a> nurbs_surface_type, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_face_region_and_nurbs.html">ON_SubDFaceRegionAndNurbs</a> &gt; &amp;patches) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ac290009042b3e05cbc26e2d8b5c3113f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae302078b9174b39d1332120b5c56c74a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae302078b9174b39d1332120b5c56c74a">GetSurfaceNurbsFragments</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_display_parameters.html">ON_SubDDisplayParameters</a> &amp;display_parameters, ON__UINT_PTR callback_context, bool(*begin_face_callback_function)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face_region.html">ON_SubDFaceRegion</a> &amp;), bool(*fragment_callback_function)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_surface_nurbs_fragment.html">ON_SubDSurfaceNurbsFragment</a> *)) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ae302078b9174b39d1332120b5c56c74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893599c3cc818e97f43cd1444b64e883"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a893599c3cc818e97f43cd1444b64e883">GetSurfacePointLinearSystem</a> (<a class="el" href="class_o_n___matrix.html">ON_Matrix</a> &amp;m, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;v) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a893599c3cc818e97f43cd1444b64e883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c89b2ef8a43089d35021333833df2b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5c89b2ef8a43089d35021333833df2b2">GetSurfacePointLinearSystem</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_vertex_surface_point_coefficient.html">ON_SubDVertexSurfacePointCoefficient</a> &gt; &amp;coefficients, <a class="el" href="class_o_n__2udex.html">ON_2udex</a> *coefficient_matrix_size) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a5c89b2ef8a43089d35021333833df2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a1af4bdd509207d564895b180fbee2"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a87a1af4bdd509207d564895b180fbee2">GetSurfaceWireframe</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag, unsigned int minimum_face_count, unsigned int maximum_face_count, <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a> chain_type, ON__UINT_PTR curve_callback_context, bool(*curve_callback_function)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *, unsigned int, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &amp;)) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a87a1af4bdd509207d564895b180fbee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32170768f1d7c1c3b181b462aa1aee11"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a32170768f1d7c1c3b181b462aa1aee11">GetSurfaceWireframe</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag, unsigned int minimum_face_count, unsigned int maximum_face_count, <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a> chain_type, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;nurbs_curves) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a32170768f1d7c1c3b181b462aa1aee11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0158d58e11c6a527ae1a4368445b92aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0158d58e11c6a527ae1a4368445b92aa">GetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> cptr, bool bMotifFirst, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;component_symmetry_set) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a0158d58e11c6a527ae1a4368445b92aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe89d793bf2e2a331838cc71c18f376a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#abe89d793bf2e2a331838cc71c18f376a">GetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge, bool bPrimaryMotifFirst, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;edge_symmetry_set) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:abe89d793bf2e2a331838cc71c18f376a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5014810971696f50a6fb0389f8af8ccd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5014810971696f50a6fb0389f8af8ccd">GetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, bool bPrimaryMotifFirst, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;face_symmetry_set) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a5014810971696f50a6fb0389f8af8ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2288016aa93b7c93fed028f0a3f02d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa2288016aa93b7c93fed028f0a3f02d4">GetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex, bool bPrimaryMotifFirst, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;vertex_symmetry_set) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa2288016aa93b7c93fed028f0a3f02d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbafa5f485a0f53097fde2d0eee0808b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#adbafa5f485a0f53097fde2d0eee0808b">GetTightBoundingBox</a> (class <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;tight_bbox, bool bGrowBox=false, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *xform=nullptr) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:adbafa5f485a0f53097fde2d0eee0808b"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> GetTightBoundingBox override <br  />
  <a href="class_o_n___sub_d.html#adbafa5f485a0f53097fde2d0eee0808b">More...</a><br /></td></tr>
<tr class="separator:adbafa5f485a0f53097fde2d0eee0808b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6839c860d6e56a40f786362eff24648b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6839c860d6e56a40f786362eff24648b">GetWireframeEdgeChains</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag, unsigned int minimum_face_count, unsigned int maximum_face_count, <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a> chain_type, ON__UINT_PTR edge_chain_callback_context, bool(*edge_chain_callback_function)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *, unsigned int)) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a6839c860d6e56a40f786362eff24648b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67407752057b33b2e0d35f8a31a3547f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a67407752057b33b2e0d35f8a31a3547f">GlobalSubdivide</a> ()</td></tr>
<tr class="separator:a67407752057b33b2e0d35f8a31a3547f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664b296cb38c698ab7fb784888ef84da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a664b296cb38c698ab7fb784888ef84da">GlobalSubdivide</a> (unsigned int count)</td></tr>
<tr class="separator:a664b296cb38c698ab7fb784888ef84da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0cfd801289cf7d9406cebb22b500292"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab0cfd801289cf7d9406cebb22b500292">GroupConnectedRegions</a> (bool bManifoldRegions) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ab0cfd801289cf7d9406cebb22b500292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd7af2b3015684e980b679351270f1af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#abd7af2b3015684e980b679351270f1af">GrowEdgeFaceArray</a> (<a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *e, size_t capacity)</td></tr>
<tr class="separator:abd7af2b3015684e980b679351270f1af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7171e34db9b9b2a4c1fe33d1e2177b95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7171e34db9b9b2a4c1fe33d1e2177b95">GrowFaceEdgeArray</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *f, size_t capacity)</td></tr>
<tr class="separator:a7171e34db9b9b2a4c1fe33d1e2177b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b275f0c7f614ecc05ce75abe81b7cdb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4b275f0c7f614ecc05ce75abe81b7cdb">GrowVertexEdgeArray</a> (<a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v, size_t capacity)</td></tr>
<tr class="separator:a4b275f0c7f614ecc05ce75abe81b7cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cf1da1212f4faa9a79ad952ead98b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a77cf1da1212f4faa9a79ad952ead98b2">GrowVertexFaceArray</a> (<a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v, size_t capacity)</td></tr>
<tr class="separator:a77cf1da1212f4faa9a79ad952ead98b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe1cab25ef65f3cfd1dc3931b94bd2d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afe1cab25ef65f3cfd1dc3931b94bd2d6">HasBrepForm</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:afe1cab25ef65f3cfd1dc3931b94bd2d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#afe1cab25ef65f3cfd1dc3931b94bd2d6">More...</a><br /></td></tr>
<tr class="separator:afe1cab25ef65f3cfd1dc3931b94bd2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d7d5d6157c1a398dc03a7c0ff2e2bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa3d7d5d6157c1a398dc03a7c0ff2e2bf">HasPerFaceColors</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa3d7d5d6157c1a398dc03a7c0ff2e2bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3735b695cdea2113e5a56c57cbc1de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7c3735b695cdea2113e5a56c57cbc1de">HasPerFaceColorsFromPackId</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7c3735b695cdea2113e5a56c57cbc1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a32dba8965bff1085ec4cd20748a1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a99a32dba8965bff1085ec4cd20748a1f">HasPerFaceColorsFromSymmetryMotif</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a99a32dba8965bff1085ec4cd20748a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2029809d54f653dc4f20917cbf647e10"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2029809d54f653dc4f20917cbf647e10">HasPerFaceMaterialChannelIndices</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a2029809d54f653dc4f20917cbf647e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87af1313e286fd032fdd848f78d0f277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a87af1313e286fd032fdd848f78d0f277">InSubD</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> *b) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a87af1313e286fd032fdd848f78d0f277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af0e791060516cc03ddcd0b35feda61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5af0e791060516cc03ddcd0b35feda61">InSubD</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a5af0e791060516cc03ddcd0b35feda61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2949e6e0091b3fcaf6112b1f9eacb2fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2949e6e0091b3fcaf6112b1f9eacb2fa">InSubD</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a2949e6e0091b3fcaf6112b1f9eacb2fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7268c24583c67db2a0e6a2774623b5f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7268c24583c67db2a0e6a2774623b5f1">InSubD</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7268c24583c67db2a0e6a2774623b5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477fa8d88b1e498804e21b28660802f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a477fa8d88b1e498804e21b28660802f2">InSubD</a> (<a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> cptr) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a477fa8d88b1e498804e21b28660802f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc2467c56d4a63f7a66e13d464d2429"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#abbc2467c56d4a63f7a66e13d464d2429">InterpolateControlNet</a> ()</td></tr>
<tr class="separator:abbc2467c56d4a63f7a66e13d464d2429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd87c83ca89fac4813142012d539632"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9dd87c83ca89fac4813142012d539632">InterpolateSurfacePoints</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;vertices, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;surface_points)</td></tr>
<tr class="separator:a9dd87c83ca89fac4813142012d539632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf54f93f972f0af4d2e2ba55ce68ec3d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aaf54f93f972f0af4d2e2ba55ce68ec3d">InterpolateSurfacePoints</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;surface_points)</td></tr>
<tr class="separator:aaf54f93f972f0af4d2e2ba55ce68ec3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd73c4faa8f393ccdc6db9e91734b0ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#abd73c4faa8f393ccdc6db9e91734b0ea">InterpolateSurfacePoints</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;vertices, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;surface_points)</td></tr>
<tr class="separator:abd73c4faa8f393ccdc6db9e91734b0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc9f54aaa612879ef8b9be6817416176"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#acc9f54aaa612879ef8b9be6817416176">InterpolateSurfacePoints</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;vertices, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;surface_points)</td></tr>
<tr class="separator:acc9f54aaa612879ef8b9be6817416176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5669bfe06d9d6f8730d0de66df6006"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4e5669bfe06d9d6f8730d0de66df6006">InterpolateSurfacePoints</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_vertex_ptr.html">ON_SubDVertexPtr</a> &gt; &amp;vertices, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;surface_points)</td></tr>
<tr class="separator:a4e5669bfe06d9d6f8730d0de66df6006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16e25bc37b56d05082218d73d495b81b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a16e25bc37b56d05082218d73d495b81b">IsDeformable</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a16e25bc37b56d05082218d73d495b81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a16e25bc37b56d05082218d73d495b81b">More...</a><br /></td></tr>
<tr class="separator:a16e25bc37b56d05082218d73d495b81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec85eda36162cbd6721dbc264ee9abf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aec85eda36162cbd6721dbc264ee9abf2">IsEmpty</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aec85eda36162cbd6721dbc264ee9abf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af368b018163a2ee43d4b66ec8c285f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4af368b018163a2ee43d4b66ec8c285f">IsManifold</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a4af368b018163a2ee43d4b66ec8c285f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8fd6f54038169c308ca42adabb6a36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aae8fd6f54038169c308ca42adabb6a36">IsManifold</a> (bool &amp;bIsOriented, bool &amp;bHasBoundary) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aae8fd6f54038169c308ca42adabb6a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f32618fb0bdf828df56d44ec9442d49"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8f32618fb0bdf828df56d44ec9442d49">IsMorphable</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a8f32618fb0bdf828df56d44ec9442d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a8f32618fb0bdf828df56d44ec9442d49">More...</a><br /></td></tr>
<tr class="separator:a8f32618fb0bdf828df56d44ec9442d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a182ffba1da22483bd6c6555fc8668fd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a182ffba1da22483bd6c6555fc8668fd4">IsNotEmpty</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a182ffba1da22483bd6c6555fc8668fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d16735d4923fe253ad33d23eccc2eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a61d16735d4923fe253ad33d23eccc2eb">IsOriented</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="memdesc:a61d16735d4923fe253ad33d23eccc2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if all facets are consistently oriented  <a href="class_o_n___sub_d.html#a61d16735d4923fe253ad33d23eccc2eb">More...</a><br /></td></tr>
<tr class="separator:a61d16735d4923fe253ad33d23eccc2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56b5ba53e60b15c972d829afca431625"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a56b5ba53e60b15c972d829afca431625">IsSolid</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a56b5ba53e60b15c972d829afca431625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da31bca23860a93830d3de23d5ffb1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6da31bca23860a93830d3de23d5ffb1a">IsValid</a> (class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *text_log=nullptr) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a6da31bca23860a93830d3de23d5ffb1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a6da31bca23860a93830d3de23d5ffb1a">More...</a><br /></td></tr>
<tr class="separator:a6da31bca23860a93830d3de23d5ffb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e16d64efdc8d7bb8a99830b6938706"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a35e16d64efdc8d7bb8a99830b6938706">LastEdge</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a35e16d64efdc8d7bb8a99830b6938706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96900ef2fd03179fe5dc9e125caf1536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a96900ef2fd03179fe5dc9e125caf1536">LastFace</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a96900ef2fd03179fe5dc9e125caf1536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7405dfa4aad4131c083c57d1ffc8604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae7405dfa4aad4131c083c57d1ffc8604">LastVertex</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ae7405dfa4aad4131c083c57d1ffc8604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4d589a902cc1c69148aaa20ff14615"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2a4d589a902cc1c69148aaa20ff14615">LevelCount</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a2a4d589a902cc1c69148aaa20ff14615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6621df72011303a610b7d7086a276bed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6621df72011303a610b7d7086a276bed">LocalSubdivide</a> (class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *face_list, size_t face_count)</td></tr>
<tr class="separator:a6621df72011303a610b7d7086a276bed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08819459daad0696e30c583027e09fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae08819459daad0696e30c583027e09fc">LocalSubdivide</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;face_list)</td></tr>
<tr class="separator:ae08819459daad0696e30c583027e09fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f94d449e2c94096ef39644749b3b6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a17f94d449e2c94096ef39644749b3b6f">LocalSubdivide</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;face_list)</td></tr>
<tr class="separator:a17f94d449e2c94096ef39644749b3b6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5330d078b194a5a017aa8391e1ec910c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5330d078b194a5a017aa8391e1ec910c">MakeDeformable</a> () override</td></tr>
<tr class="memdesc:a5330d078b194a5a017aa8391e1ec910c"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a5330d078b194a5a017aa8391e1ec910c">More...</a><br /></td></tr>
<tr class="separator:a5330d078b194a5a017aa8391e1ec910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e8eabe1646331effbe9deb5f407169"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac6e8eabe1646331effbe9deb5f407169">MakeReflectSymmetric</a> (<a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a> symmetry)</td></tr>
<tr class="separator:ac6e8eabe1646331effbe9deb5f407169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b1750bfa1feaac0e336fd41ddbecf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a31b1750bfa1feaac0e336fd41ddbecf7">MakeSymmetric</a> (<a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a> symmetry)</td></tr>
<tr class="separator:a31b1750bfa1feaac0e336fd41ddbecf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6ff9bb07fa310535965a53e14e5b6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#acd6ff9bb07fa310535965a53e14e5b6b">MakeSymmetric</a> (<a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a> symmetry, bool bIgnoredParameter1, bool bIgnoredParameter2)</td></tr>
<tr class="separator:acd6ff9bb07fa310535965a53e14e5b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e86225585cf815749bac641b495017"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae9e86225585cf815749bac641b495017">MarkAggregateComponentStatusAsNotCurrent</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:ae9e86225585cf815749bac641b495017"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#ae9e86225585cf815749bac641b495017">More...</a><br /></td></tr>
<tr class="separator:ae9e86225585cf815749bac641b495017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f218011417be626ef20caeb5a088638"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4f218011417be626ef20caeb5a088638">MarkConnectedRegion</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> seed_component, bool bManifoldRegions) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a4f218011417be626ef20caeb5a088638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f6c295baa65a55482367015853f66b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a18f6c295baa65a55482367015853f66b">MemoryRelocate</a> () override</td></tr>
<tr class="memdesc:a18f6c295baa65a55482367015853f66b"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a18f6c295baa65a55482367015853f66b">More...</a><br /></td></tr>
<tr class="separator:a18f6c295baa65a55482367015853f66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12df8e08da5056212f8ed7ae0ca48969"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a12df8e08da5056212f8ed7ae0ca48969">Merge</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> *vertex_pairs, size_t vertex_pairs_count, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> prefered_merged_edge_tag, bool bMergeAllCoincidentVertices, bool bMarkMergedComponents, bool bMarkAddedComponents)</td></tr>
<tr class="separator:a12df8e08da5056212f8ed7ae0ca48969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff437e52c58934f9579015cce87def6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5ff437e52c58934f9579015cce87def6">Merge</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> *vertex_pairs, size_t vertex_pairs_count, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> prefered_merged_edge_tag, bool bMergeAllCoincidentVertices, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;this_vertex_filter, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;subd_vertex_filter, bool bMarkMergedComponents, bool bMarkAddedComponents)</td></tr>
<tr class="separator:a5ff437e52c58934f9579015cce87def6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea433bfc1ffc61a1a98dedcf8e09dc25"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aea433bfc1ffc61a1a98dedcf8e09dc25">Merge</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; &amp;vertex_pairs, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> prefered_merged_edge_tag, bool bMergeAllCoincidentVertices, bool bMarkMergedComponents, bool bMarkAddedComponents)</td></tr>
<tr class="separator:aea433bfc1ffc61a1a98dedcf8e09dc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a555e5eb5cbbbeeda6140cd62edf01ea1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a555e5eb5cbbbeeda6140cd62edf01ea1">Merge</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; &amp;vertex_pairs, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> prefered_merged_edge_tag, bool bMergeAllCoincidentVertices, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;this_vertex_filter, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;subd_vertex_filter, bool bMarkMergedComponents, bool bMarkAddedComponents)</td></tr>
<tr class="separator:a555e5eb5cbbbeeda6140cd62edf01ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f91e70d0308c804cfaf172f4d0c0b67"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6f91e70d0308c804cfaf172f4d0c0b67">MergeColinearEdges</a> (bool bMergeBoundaryEdges, bool bMergeInteriorCreaseEdges, bool bMergeInteriorSmoothEdges, double distance_tolerance, double maximum_aspect, double sin_angle_tolerance)</td></tr>
<tr class="separator:a6f91e70d0308c804cfaf172f4d0c0b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3bf5a73e0b1be46758302662b55472"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aea3bf5a73e0b1be46758302662b55472">MergeConsecutiveEdges</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> eptr0, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> eptr1)</td></tr>
<tr class="separator:aea3bf5a73e0b1be46758302662b55472"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc49e44b87428a1cbbaa0140f147d20c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afc49e44b87428a1cbbaa0140f147d20c">MergeFaces</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge)</td></tr>
<tr class="separator:afc49e44b87428a1cbbaa0140f147d20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0412e0107132bcad5a3def31ed368f01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0412e0107132bcad5a3def31ed368f01">MergeFaces</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex)</td></tr>
<tr class="separator:a0412e0107132bcad5a3def31ed368f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdb6c2c8b62798a6bdec93fb331131f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5bdb6c2c8b62798a6bdec93fb331131f">MergeFaces</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;face_list, bool bFaceListMayBeInvalid)</td></tr>
<tr class="separator:a5bdb6c2c8b62798a6bdec93fb331131f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af558f2d1f7371716d245e42216b9e95a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af558f2d1f7371716d245e42216b9e95a">MergeFaces</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> *face_list, size_t face_count, bool bFaceListMayBeInvalid)</td></tr>
<tr class="separator:af558f2d1f7371716d245e42216b9e95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf773013478b1e3148aa1e9adbc3b47b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aaf773013478b1e3148aa1e9adbc3b47b">MergeFaces</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *face_list, size_t face_count, bool bFaceListMayBeInvalid)</td></tr>
<tr class="separator:aaf773013478b1e3148aa1e9adbc3b47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a693b3076c4b3b5421a3c913c2476a71c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a693b3076c4b3b5421a3c913c2476a71c">MergeFaceSets</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;face_list)</td></tr>
<tr class="separator:a693b3076c4b3b5421a3c913c2476a71c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b184fe314be54759be677c9c505f9c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a27b184fe314be54759be677c9c505f9c">MergeFaceSets</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;ci_list, bool bMergeSharedEdges)</td></tr>
<tr class="separator:a27b184fe314be54759be677c9c505f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287fa6c2659a164a5f30b784f43fdd9a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a287fa6c2659a164a5f30b784f43fdd9a">MergeFaceSets</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;cptr_list, bool bMergeSharedEdges)</td></tr>
<tr class="separator:a287fa6c2659a164a5f30b784f43fdd9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb66f90496c22c4b737ce84a4a221fb"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0eb66f90496c22c4b737ce84a4a221fb">MergeFaceSets</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *cptr_list, size_t cptr_count, bool bMergeSharedEdges)</td></tr>
<tr class="separator:a0eb66f90496c22c4b737ce84a4a221fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7da703ec2e031e021473330deee94285"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7da703ec2e031e021473330deee94285">MeshFragmentCount</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7da703ec2e031e021473330deee94285"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7644c65cb6234acb0d79723de8f30db0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7644c65cb6234acb0d79723de8f30db0">Morph</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___space_morph.html">ON_SpaceMorph</a> &amp;morph) override</td></tr>
<tr class="memdesc:a7644c65cb6234acb0d79723de8f30db0"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a7644c65cb6234acb0d79723de8f30db0">More...</a><br /></td></tr>
<tr class="separator:a7644c65cb6234acb0d79723de8f30db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a830ccb2334339677aff5a9749a6460d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n.html#a328d22b5ad7bf9d4e9ba1123355d3cf9">ON::object_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a830ccb2334339677aff5a9749a6460d5">ObjectType</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a830ccb2334339677aff5a9749a6460d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a830ccb2334339677aff5a9749a6460d5">More...</a><br /></td></tr>
<tr class="separator:a830ccb2334339677aff5a9749a6460d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af996b7ead8af69329ed467be8c5d1e3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af996b7ead8af69329ed467be8c5d1e3c">Offset</a> (double offset_distance, bool bOffsetSurface, bool bBothSides, bool bMakeSolid, bool bPreserveSymmetry, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:af996b7ead8af69329ed467be8c5d1e3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3fb2bd4ddb6b5658a77ec42b2f3709"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5e3fb2bd4ddb6b5658a77ec42b2f3709">Offset</a> (double offset_distance, bool bOffsetSurface, bool bBothSides, bool bMakeSolid, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a5e3fb2bd4ddb6b5658a77ec42b2f3709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6012d7d4b7f9ab046d1d36c9788dd3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad6012d7d4b7f9ab046d1d36c9788dd3a">Offset</a> (<a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> offset_direction, bool bOffsetSurface, bool bBothSides, bool bMakeSolid, bool bPreserveSymmetry, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ad6012d7d4b7f9ab046d1d36c9788dd3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cccbc915594a18ebd50968d5cac095"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a65cccbc915594a18ebd50968d5cac095">Offset</a> (<a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> offset_direction, bool bOffsetSurface, bool bBothSides, bool bMakeSolid, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a65cccbc915594a18ebd50968d5cac095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228fd567f8aa46db376fef2d32512b19"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a228fd567f8aa46db376fef2d32512b19">operator=</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;src)</td></tr>
<tr class="separator:a228fd567f8aa46db376fef2d32512b19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68093b5d13b3b7510bfac5a822d5a907"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a68093b5d13b3b7510bfac5a822d5a907">Orient</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="memdesc:a68093b5d13b3b7510bfac5a822d5a907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to orient all facet to match the first facet.  <a href="class_o_n___sub_d.html#a68093b5d13b3b7510bfac5a822d5a907">More...</a><br /></td></tr>
<tr class="separator:a68093b5d13b3b7510bfac5a822d5a907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae35f701fbf4f43bb90827458abb6ae"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7ae35f701fbf4f43bb90827458abb6ae">PackFaces</a> ()</td></tr>
<tr class="separator:a7ae35f701fbf4f43bb90827458abb6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68b3874bb2387fc0a1c6f135f6427f1"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad68b3874bb2387fc0a1c6f135f6427f1">PackFaces</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> face_packing_id)</td></tr>
<tr class="separator:ad68b3874bb2387fc0a1c6f135f6427f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2217f352d21c27d180e7cb6d36b3e072"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2217f352d21c27d180e7cb6d36b3e072">ProjectVerticesToPlane</a> (<a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a> plane_equation, double distance_tolerance)</td></tr>
<tr class="separator:a2217f352d21c27d180e7cb6d36b3e072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c535f015caf4aa27dfa95f3d768deb"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac0c535f015caf4aa27dfa95f3d768deb">ProxyBrep</a> (<a class="el" href="class_o_n___brep.html">ON_Brep</a> *destination_brep) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="memdesc:ac0c535f015caf4aa27dfa95f3d768deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">SubD proxy brep interface.  <a href="class_o_n___sub_d.html#ac0c535f015caf4aa27dfa95f3d768deb">More...</a><br /></td></tr>
<tr class="separator:ac0c535f015caf4aa27dfa95f3d768deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3d7944a9466b3bd8fa829a6ac9385f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_edge.html">ON_BrepEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5a3d7944a9466b3bd8fa829a6ac9385f">ProxyBrepEdge</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___brep.html">ON_Brep</a> *proxy_brep, unsigned subd_edge_id, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_edge.html">ON_BrepEdge</a> *prev_proxy_edge) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a5a3d7944a9466b3bd8fa829a6ac9385f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aea6ae0c9228d9f70b4504c8d4d5f48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_face.html">ON_BrepFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8aea6ae0c9228d9f70b4504c8d4d5f48">ProxyBrepFace</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___brep.html">ON_Brep</a> *proxy_brep, unsigned subd_face_id, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_face.html">ON_BrepFace</a> *prev_proxy_face) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a8aea6ae0c9228d9f70b4504c8d4d5f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389f7c6400638375f128cc9ef5b29c69"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_vertex.html">ON_BrepVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a389f7c6400638375f128cc9ef5b29c69">ProxyBrepVertex</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___brep.html">ON_Brep</a> *proxy_brep, unsigned subd_vertex_id) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a389f7c6400638375f128cc9ef5b29c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a985d76907f6ab912d5b4c66858b7e490"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a985d76907f6ab912d5b4c66858b7e490">Read</a> (<a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;archive) override</td></tr>
<tr class="memdesc:a985d76907f6ab912d5b4c66858b7e490"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a985d76907f6ab912d5b4c66858b7e490">More...</a><br /></td></tr>
<tr class="separator:a985d76907f6ab912d5b4c66858b7e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cbe1ab19c940c6cbf800eb6f100c75"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab5cbe1ab19c940c6cbf800eb6f100c75">RemoveAllCreases</a> ()</td></tr>
<tr class="separator:ab5cbe1ab19c940c6cbf800eb6f100c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f08f40c4bcb8e0f85dfb1a5c9c9596"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a34f08f40c4bcb8e0f85dfb1a5c9c9596">RemoveEdgeVertexConnection</a> (<a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *e, <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v)</td></tr>
<tr class="separator:a34f08f40c4bcb8e0f85dfb1a5c9c9596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ec24a00a769bfd485ab61d947b404c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a84ec24a00a769bfd485ab61d947b404c">RemoveEdgeVertexConnection</a> (<a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *e, unsigned evi)</td></tr>
<tr class="separator:a84ec24a00a769bfd485ab61d947b404c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e47ece8a0299bd973c87149632ead0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4e47ece8a0299bd973c87149632ead0a">RemoveFaceConnections</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face)</td></tr>
<tr class="separator:a4e47ece8a0299bd973c87149632ead0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4553f75547dfd9db03ca0a6487b91e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6a4553f75547dfd9db03ca0a6487b91e">RemoveFaceEdgeConnection</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge)</td></tr>
<tr class="separator:a6a4553f75547dfd9db03ca0a6487b91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf865446d02d96263f6580cc717e63e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2bf865446d02d96263f6580cc717e63e">RemoveFaceEdgeConnection</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, unsigned int i)</td></tr>
<tr class="separator:a2bf865446d02d96263f6580cc717e63e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c5d0dd4e933a8fbc06c97ac1a54fb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a33c5d0dd4e933a8fbc06c97ac1a54fb5">RemoveFaceEdgeConnection</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, unsigned int i, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &amp;removed_edge)</td></tr>
<tr class="separator:a33c5d0dd4e933a8fbc06c97ac1a54fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71741d50e05aa5bd6571d0ca2e6e15d0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a71741d50e05aa5bd6571d0ca2e6e15d0">RemoveZeroLengthEdges</a> ()</td></tr>
<tr class="separator:a71741d50e05aa5bd6571d0ca2e6e15d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5070b9f89eb3330080e5fc41283dd555"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5070b9f89eb3330080e5fc41283dd555">RenderContentSerialNumber</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a5070b9f89eb3330080e5fc41283dd555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a8f2c5a3f9106bd1c177dabf08ba8fb"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5a8f2c5a3f9106bd1c177dabf08ba8fb">ReplaceFaceWithTrianglation</a> (class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> triangluation_plane_normal, bool bMarkFaces)</td></tr>
<tr class="separator:a5a8f2c5a3f9106bd1c177dabf08ba8fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44559922bedb93779be41a603a063e04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a44559922bedb93779be41a603a063e04">ReplaceFaceWithTriangleFan</a> (class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> fan_center_point, bool bMarkFaces)</td></tr>
<tr class="separator:a44559922bedb93779be41a603a063e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c5f9c3d9ac7f0a153d2d79e169e6751"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5c5f9c3d9ac7f0a153d2d79e169e6751">ReturnEdgeForExperts</a> (<a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *e)</td></tr>
<tr class="separator:a5c5f9c3d9ac7f0a153d2d79e169e6751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e34dbc57870f067bfd2821721cb41e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa4e34dbc57870f067bfd2821721cb41e">ReturnFaceForExperts</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *f)</td></tr>
<tr class="separator:aa4e34dbc57870f067bfd2821721cb41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4d342996a170bf84108f0a8ceddbcd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0b4d342996a170bf84108f0a8ceddbcd">ReturnVertexForExperts</a> (<a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v)</td></tr>
<tr class="separator:a0b4d342996a170bf84108f0a8ceddbcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a192d2d9347cef690f7b3e9e469170eb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a192d2d9347cef690f7b3e9e469170eb6">ReverseOrientation</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="memdesc:a192d2d9347cef690f7b3e9e469170eb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses the orientation of all facets  <a href="class_o_n___sub_d.html#a192d2d9347cef690f7b3e9e469170eb6">More...</a><br /></td></tr>
<tr class="separator:a192d2d9347cef690f7b3e9e469170eb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a849e7dfb0c615f0fdd6ddbf0fa0ffe92"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a849e7dfb0c615f0fdd6ddbf0fa0ffe92">RuntimeSerialNumber</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a849e7dfb0c615f0fdd6ddbf0fa0ffe92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a85d24bb1b78802d96989f4bcc61c09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1a85d24bb1b78802d96989f4bcc61c09">SeparateInteriorEdge</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> interior_edge, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *separator0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *separator1)</td></tr>
<tr class="separator:a1a85d24bb1b78802d96989f4bcc61c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee878f3a3d8fa6d15cbc3f2692f7e83"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afee878f3a3d8fa6d15cbc3f2692f7e83">SeparateInteriorEdgeChains</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;edge_chains, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *separated_edges)</td></tr>
<tr class="separator:afee878f3a3d8fa6d15cbc3f2692f7e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5495c8231e79f9a19816b59fe341a81b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5495c8231e79f9a19816b59fe341a81b">SeparateInteriorEdgeChains</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;edge_chains, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *separated_edges)</td></tr>
<tr class="separator:a5495c8231e79f9a19816b59fe341a81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65883fe1e11f9d751a8b98174af48d60"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a65883fe1e11f9d751a8b98174af48d60">SeparateInteriorEdgeChains</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;edge_chains, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *separated_edges)</td></tr>
<tr class="separator:a65883fe1e11f9d751a8b98174af48d60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ec8f95a8bb6228fb10ac4bd5009601a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5ec8f95a8bb6228fb10ac4bd5009601a">SeparateInteriorEdgeChains</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chains, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *separated_edges)</td></tr>
<tr class="separator:a5ec8f95a8bb6228fb10ac4bd5009601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8378aa17125d9931e260f14e25cef8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afe8378aa17125d9931e260f14e25cef8">SeparateInteriorEdges</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *separated_edges)</td></tr>
<tr class="separator:afe8378aa17125d9931e260f14e25cef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65ee1a90dec85791474b312d10fafb6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab65ee1a90dec85791474b312d10fafb6">SeparateInteriorEdges</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *separated_edges)</td></tr>
<tr class="separator:ab65ee1a90dec85791474b312d10fafb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a751afda122f7ca28061a6ae9aa04c6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2a751afda122f7ca28061a6ae9aa04c6">SeparateInteriorEdges</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *separated_edges)</td></tr>
<tr class="separator:a2a751afda122f7ca28061a6ae9aa04c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9c8a047ca9563641430f69b1a0860c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5d9c8a047ca9563641430f69b1a0860c">SeparateInteriorEdges</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edges, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *separated_edges)</td></tr>
<tr class="separator:a5d9c8a047ca9563641430f69b1a0860c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8939f2aa50b61de9b8e978c40ed419fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8939f2aa50b61de9b8e978c40ed419fa">SeparateVertex</a> (<a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex, bool bApplyCreaseBias)</td></tr>
<tr class="separator:a8939f2aa50b61de9b8e978c40ed419fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e2fc4a3b87663caa7cb2f609b48277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af4e2fc4a3b87663caa7cb2f609b48277">SeparateVertex</a> (<a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *separator0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *separator1)</td></tr>
<tr class="separator:af4e2fc4a3b87663caa7cb2f609b48277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0afeb4a01c3e6508a1d679891f697142"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0afeb4a01c3e6508a1d679891f697142">SetComponentMarkBitsFromSymmetryMotif</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a0afeb4a01c3e6508a1d679891f697142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16eda814d8042574b046c41a5ec81f5"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac16eda814d8042574b046c41a5ec81f5">SetComponentMarks</a> (bool bClearBeforeSet, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; &amp;marked_component_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ac16eda814d8042574b046c41a5ec81f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae20ebb4f459cc7081f69602646b30736"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae20ebb4f459cc7081f69602646b30736">SetComponentStates</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_to_set) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:ae20ebb4f459cc7081f69602646b30736"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#ae20ebb4f459cc7081f69602646b30736">More...</a><br /></td></tr>
<tr class="separator:ae20ebb4f459cc7081f69602646b30736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b75cd50d16e683c39d002a881a32a96"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7b75cd50d16e683c39d002a881a32a96">SetComponentStates</a> (<a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> component_ptr, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> states_to_set) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7b75cd50d16e683c39d002a881a32a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72b8d1d5f3061cdc03a7bacf96935ac7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a72b8d1d5f3061cdc03a7bacf96935ac7">SetComponentStatus</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> status_to_copy) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a72b8d1d5f3061cdc03a7bacf96935ac7"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a72b8d1d5f3061cdc03a7bacf96935ac7">More...</a><br /></td></tr>
<tr class="separator:a72b8d1d5f3061cdc03a7bacf96935ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7eaa42f4b7920ec7e5fddcbe79b691e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac7eaa42f4b7920ec7e5fddcbe79b691e">SetComponentStatus</a> (<a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> status_mask, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; &amp;component_list, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> &gt; &amp;status_list) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ac7eaa42f4b7920ec7e5fddcbe79b691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4551eaa7d35206b253de8f2cd2b2488c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4551eaa7d35206b253de8f2cd2b2488c">SetComponentStatus</a> (<a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> component_ptr, <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> status_to_copy) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a4551eaa7d35206b253de8f2cd2b2488c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0131cc30d66feb9db6174f39c59c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0b0131cc30d66feb9db6174f39c59c76">SetContentIsSymmetricForExperts</a> (bool bContentIsSymmetric) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a0b0131cc30d66feb9db6174f39c59c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceeb7387be3d5a0e942432b3cf5bbe00"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aceeb7387be3d5a0e942432b3cf5bbe00">SetEdgeTags</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag)</td></tr>
<tr class="separator:aceeb7387be3d5a0e942432b3cf5bbe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac02264cb0f949a437e9c62cee449cd57"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac02264cb0f949a437e9c62cee449cd57">SetEdgeTags</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *cptr_list, size_t cptr_count, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag)</td></tr>
<tr class="separator:ac02264cb0f949a437e9c62cee449cd57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09239b446068c4d7e7412456d0928b5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a09239b446068c4d7e7412456d0928b5f">SetFaceBoundary</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edges)</td></tr>
<tr class="separator:a09239b446068c4d7e7412456d0928b5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb86effb61c2c03db5f8c48e90d0a88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afb86effb61c2c03db5f8c48e90d0a88e">SetFaceBoundary</a> (<a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edges, size_t edge_count)</td></tr>
<tr class="separator:afb86effb61c2c03db5f8c48e90d0a88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ed37d3786c33275da7d806937470131"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4ed37d3786c33275da7d806937470131">SetFacePackingIdForExperts</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> custom_packing_id)</td></tr>
<tr class="separator:a4ed37d3786c33275da7d806937470131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20368cab20031945ad346dbdd297f4c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a20368cab20031945ad346dbdd297f4c4">SetFragmentColorsFromCallback</a> (bool bLazySet, <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> fragment_colors_settings_hash, <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> fragment_colors_mapping_tag, ON__UINT_PTR callback_context, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___color.html">ON_Color</a>(*color_callback)(ON__UINT_PTR callback_context, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> &amp;mapping_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> cptr, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;P, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;N, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;T, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___surface_curvature.html">ON_SurfaceCurvature</a> &amp;K)) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a20368cab20031945ad346dbdd297f4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdb74d61f29ee06c737812b031c15ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0cdb74d61f29ee06c737812b031c15ad">SetFragmentColorsMappingTag</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> &amp;) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a0cdb74d61f29ee06c737812b031c15ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab196a6ea0bc70f34b7831463f9bd6972"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab196a6ea0bc70f34b7831463f9bd6972">SetFragmentTextureCoordinates</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;mapping, bool bLazy) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ab196a6ea0bc70f34b7831463f9bd6972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056119983695a5a9ed2ee5dbaa2c323f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a056119983695a5a9ed2ee5dbaa2c323f">SetPerFaceColorsFromPackId</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a056119983695a5a9ed2ee5dbaa2c323f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7a441089953c2633fc5f8845e96987f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab7a441089953c2633fc5f8845e96987f">SetPerFaceColorsFromSymmetryMotif</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ab7a441089953c2633fc5f8845e96987f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33c10824d856a4afd24f4847e414930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa33c10824d856a4afd24f4847e414930">SetSubDAppearance</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> subd_appearance) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa33c10824d856a4afd24f4847e414930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45857e8f068edbd334dbf62aa2f73f79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a45857e8f068edbd334dbf62aa2f73f79">SetSymmetryForExperts</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a> &amp;symmetry, bool SetContentSerialNumber)</td></tr>
<tr class="separator:a45857e8f068edbd334dbf62aa2f73f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88258912dd469b7612f564fb0b67ada5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a88258912dd469b7612f564fb0b67ada5">SetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;edge_symmetry_set, unsigned primary_motif_index)</td></tr>
<tr class="separator:a88258912dd469b7612f564fb0b67ada5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bca082af1af5659761e4192342a3adf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3bca082af1af5659761e4192342a3adf">SetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;face_symmetry_set, unsigned primary_motif_index)</td></tr>
<tr class="separator:a3bca082af1af5659761e4192342a3adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ad47654816bb4ac09b9c0b43f6dbaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a20ad47654816bb4ac09b9c0b43f6dbaa">SetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;vertex_symmetry_set, unsigned primary_motif_index)</td></tr>
<tr class="separator:a20ad47654816bb4ac09b9c0b43f6dbaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b155c7050b24fc8019468b68444bae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a81b155c7050b24fc8019468b68444bae">SetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;component_symmetry_set, unsigned primary_motif_index)</td></tr>
<tr class="separator:a81b155c7050b24fc8019468b68444bae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e70212443fcef88ca86206bf80489d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a54e70212443fcef88ca86206bf80489d">SetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_symmetry_set, size_t component_symmetry_set_count, unsigned primary_motif_index)</td></tr>
<tr class="separator:a54e70212443fcef88ca86206bf80489d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156b0a6f71b63c88448f2bcf81085c5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a156b0a6f71b63c88448f2bcf81085c5f">SetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *edge_symmetry_set, size_t edge_symmetry_set_count, unsigned primary_motif_index)</td></tr>
<tr class="separator:a156b0a6f71b63c88448f2bcf81085c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17107366fa06924ed5aa2af0cf28ed5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af17107366fa06924ed5aa2af0cf28ed5">SetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *face_symmetry_set, size_t face_symmetry_set_count, unsigned primary_motif_index)</td></tr>
<tr class="separator:af17107366fa06924ed5aa2af0cf28ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241b8f62e8d139c59728fdd91ff4597c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a241b8f62e8d139c59728fdd91ff4597c">SetSymmetrySet</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *vertex_symmetry_set, size_t vertex_symmetry_set_count, unsigned primary_motif_index)</td></tr>
<tr class="separator:a241b8f62e8d139c59728fdd91ff4597c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c06831a6172f6251c5d87888ac5baf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a98c06831a6172f6251c5d87888ac5baf">SetSymmetrySetNextForExperts</a> (bool bComponentIsPrimaryMotif, <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> component, <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> next_component)</td></tr>
<tr class="separator:a98c06831a6172f6251c5d87888ac5baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2edfe7f2647dff8f87a4e30a5d0c3dea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2edfe7f2647dff8f87a4e30a5d0c3dea">SetSymmetrySetNextForExperts</a> (bool bEdgeIsPrimaryMotif, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *next_edge)</td></tr>
<tr class="separator:a2edfe7f2647dff8f87a4e30a5d0c3dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a218dd4b2a690034c286b5dce052e26aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a218dd4b2a690034c286b5dce052e26aa">SetSymmetrySetNextForExperts</a> (bool bFaceIsPrimaryMotif, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *next_face)</td></tr>
<tr class="separator:a218dd4b2a690034c286b5dce052e26aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98053281138446a2ce64015699402803"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a98053281138446a2ce64015699402803">SetSymmetrySetNextForExperts</a> (bool bVertexIsPrimaryMotif, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *next_vertex)</td></tr>
<tr class="separator:a98053281138446a2ce64015699402803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a640b6a0de2f939b408a04e4f6ea7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a59a640b6a0de2f939b408a04e4f6ea7f">SetSymmetrySetsForExperts</a> (bool bUseCleanupTolerance)</td></tr>
<tr class="separator:a59a640b6a0de2f939b408a04e4f6ea7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8977da9839a8417cc2d377677c30c38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac8977da9839a8417cc2d377677c30c38">SetTextureCoordinateType</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a> texture_coordinate_type) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ac8977da9839a8417cc2d377677c30c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d66807128a3b50a72d05d67c300845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a61d66807128a3b50a72d05d67c300845">SetTextureMappingTag</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> &amp;) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a61d66807128a3b50a72d05d67c300845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bbd256072e9d3f8f061f230b7dbda8a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0bbd256072e9d3f8f061f230b7dbda8a">SetVertexTags</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count, <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag)</td></tr>
<tr class="separator:a0bbd256072e9d3f8f061f230b7dbda8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762df4837a7d0183fa5c71db11a5d565"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a762df4837a7d0183fa5c71db11a5d565">SetVertexTags</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *cptr_list, size_t cptr_count, <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag)</td></tr>
<tr class="separator:a762df4837a7d0183fa5c71db11a5d565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64b79873608711a9c28a6470e3c1caa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad64b79873608711a9c28a6470e3c1caa">ShareContentsFrom</a> (<a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd)</td></tr>
<tr class="separator:ad64b79873608711a9c28a6470e3c1caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f148e3e9c83b03471ffbd8c37dd878c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5f148e3e9c83b03471ffbd8c37dd878c">ShareDimple</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class ON_SubDMeshImpl &amp;)</td></tr>
<tr class="separator:a5f148e3e9c83b03471ffbd8c37dd878c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad284313958594074867433d84f9f6a60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad284313958594074867433d84f9f6a60">ShareDimple</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;)</td></tr>
<tr class="separator:ad284313958594074867433d84f9f6a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63166832c7481143c3ce7ae22f123f88"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a63166832c7481143c3ce7ae22f123f88">SizeOf</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:a63166832c7481143c3ce7ae22f123f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a63166832c7481143c3ce7ae22f123f88">More...</a><br /></td></tr>
<tr class="separator:a63166832c7481143c3ce7ae22f123f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923ad1077006530331100a971eccfebc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a923ad1077006530331100a971eccfebc">SizeOfActiveElements</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a923ad1077006530331100a971eccfebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fbb68941c62f35082b5fd172e12d122"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9fbb68941c62f35082b5fd172e12d122">SizeOfActiveMeshFragments</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a9fbb68941c62f35082b5fd172e12d122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc185f66a3babe71306acba723ddc8ef"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#abc185f66a3babe71306acba723ddc8ef">SizeOfAllElements</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:abc185f66a3babe71306acba723ddc8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a46cd73a40f53f0f4bc5d34feac346b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0a46cd73a40f53f0f4bc5d34feac346b">SizeOfAllMeshFragments</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a0a46cd73a40f53f0f4bc5d34feac346b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebdb447f713f20a880f0e96b8d90b2f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aebdb447f713f20a880f0e96b8d90b2f4">SizeOfUnusedElements</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aebdb447f713f20a880f0e96b8d90b2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa180112bfc9c40e962b7709ef41fa50"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aaa180112bfc9c40e962b7709ef41fa50">SizeOfUnusedMeshFragments</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aaa180112bfc9c40e962b7709ef41fa50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a574b138eedad001cece9648b81f7d5b3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a574b138eedad001cece9648b81f7d5b3">SnapPointsToPlane</a> (<a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a> plane_equation, double distance_tolerance)</td></tr>
<tr class="separator:a574b138eedad001cece9648b81f7d5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5df6a826b93bb3c8d61861429fa56aa"><td class="memItemLeft" align="right" valign="top">*int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab5df6a826b93bb3c8d61861429fa56aa">SolidOrientation</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ab5df6a826b93bb3c8d61861429fa56aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6fcb55c62a363333b4ac1fd05654b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4a6fcb55c62a363333b4ac1fd05654b7">SplitEdge</a> (class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> vertex_location)</td></tr>
<tr class="separator:a4a6fcb55c62a363333b4ac1fd05654b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476a0ec674b8b841ba6e1ba13cc55895"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a476a0ec674b8b841ba6e1ba13cc55895">SplitEdge</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> eptr, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> vertex_location, unsigned new_edge_end)</td></tr>
<tr class="separator:a476a0ec674b8b841ba6e1ba13cc55895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffbe51504da52e965543f17ed14dc58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5ffbe51504da52e965543f17ed14dc58">SplitFace</a> (class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v1)</td></tr>
<tr class="separator:a5ffbe51504da52e965543f17ed14dc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a88070ccf56241173759bb782b71759"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0a88070ccf56241173759bb782b71759">SplitFace</a> (class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v1, unsigned new_face_side)</td></tr>
<tr class="separator:a0a88070ccf56241173759bb782b71759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25aad61bc081919f353e6f1b53f06b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa25aad61bc081919f353e6f1b53f06b3">SplitFace</a> (class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, unsigned int fvi0, unsigned int fvi1)</td></tr>
<tr class="separator:aa25aad61bc081919f353e6f1b53f06b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2379bcc366ba6c2b0fd1297a12c687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1d2379bcc366ba6c2b0fd1297a12c687">SplitFace</a> (class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face, unsigned int fvi0, unsigned int fvi1, unsigned new_face_side)</td></tr>
<tr class="separator:a1d2379bcc366ba6c2b0fd1297a12c687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21038cd5c25155c24005e311b9c055e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a21038cd5c25155c24005e311b9c055e6">SubDAppearance</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a21038cd5c25155c24005e311b9c055e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb2ba99a61176cc622096c2ea4f3b969"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_mesh.html">ON_SubDMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aeb2ba99a61176cc622096c2ea4f3b969">SubDControlNetMesh</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aeb2ba99a61176cc622096c2ea4f3b969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753cbf6fa759787e06c54e4c76f6a702"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_hash.html">ON_SubDHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a753cbf6fa759787e06c54e4c76f6a702">SubDHash</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga7901fb222b1b25e32978f0b34ba7234a">ON_SubDHashType</a> hash_type, bool bForceUpdate) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a753cbf6fa759787e06c54e4c76f6a702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93935562ff8f61c0c180f2485a2419a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class ON_SubDimple *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a93935562ff8f61c0c180f2485a2419a7">SubDimple</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a93935562ff8f61c0c180f2485a2419a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0826c8dfef46b4794eadd8f67309c7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8b0826c8dfef46b4794eadd8f67309c7">SubDimpleUseCount</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a8b0826c8dfef46b4794eadd8f67309c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a114c218825fa31a4adbb22e4f5a21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a82a114c218825fa31a4adbb22e4f5a21">SubDModifiedNofification</a> ()</td></tr>
<tr class="separator:a82a114c218825fa31a4adbb22e4f5a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05378b66322188c768f1c60754afc4da"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_mesh.html">ON_SubDMesh</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a05378b66322188c768f1c60754afc4da">SubDSurfaceMesh</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a05378b66322188c768f1c60754afc4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38031c83f98cd09c9df32ca4adb2cce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab38031c83f98cd09c9df32ca4adb2cce">SwapCoordinates</a> (int i, int j) override</td></tr>
<tr class="memdesc:ab38031c83f98cd09c9df32ca4adb2cce"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#ab38031c83f98cd09c9df32ca4adb2cce">More...</a><br /></td></tr>
<tr class="separator:ab38031c83f98cd09c9df32ca4adb2cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a196e5c15a52a3a7bf909e1effc8593c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a196e5c15a52a3a7bf909e1effc8593c6">SwapDimple</a> (class ON_SubDMeshImpl &amp;)</td></tr>
<tr class="separator:a196e5c15a52a3a7bf909e1effc8593c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162c2720914800b1aeead7fca9860df5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a162c2720914800b1aeead7fca9860df5">SwapDimple</a> (<a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;)</td></tr>
<tr class="separator:a162c2720914800b1aeead7fca9860df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc74c233cbff4a0c62f07710128c2e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5cc74c233cbff4a0c62f07710128c2e3">Symmetry</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a5cc74c233cbff4a0c62f07710128c2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738471d2bb7144aed7efde9308562c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a738471d2bb7144aed7efde9308562c6a">SymmetrySetCount</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a738471d2bb7144aed7efde9308562c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb14dd64195fc5954c3e9bbff3bb0e8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afb14dd64195fc5954c3e9bbff3bb0e8f">SymmetrySetCount</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:afb14dd64195fc5954c3e9bbff3bb0e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af372b82afc16deb824322ca6b4641d42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af372b82afc16deb824322ca6b4641d42">SymmetrySetCount</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:af372b82afc16deb824322ca6b4641d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56972f83e690de4ba2da1300f6cb6cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad56972f83e690de4ba2da1300f6cb6cf">SymmetrySetCount</a> (<a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> cptr) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ad56972f83e690de4ba2da1300f6cb6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053c18962230daf6e175356c617541a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a053c18962230daf6e175356c617541a4">SymmetrySetNext</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a053c18962230daf6e175356c617541a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1448fe65c2ac8bd6e23d5e494594e99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac1448fe65c2ac8bd6e23d5e494594e99">SymmetrySetNext</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ac1448fe65c2ac8bd6e23d5e494594e99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b3833dd8afe21acd482e2f6eca18b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad7b3833dd8afe21acd482e2f6eca18b2">SymmetrySetNext</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ad7b3833dd8afe21acd482e2f6eca18b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e412fe149acd8b8215597f5c5cb982"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a92e412fe149acd8b8215597f5c5cb982">SymmetrySetNext</a> (<a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> cptr) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a92e412fe149acd8b8215597f5c5cb982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bf5156a8bf20197bb48137415faa4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af9bf5156a8bf20197bb48137415faa4a">SymmetrySetPrimaryMotif</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *edge) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:af9bf5156a8bf20197bb48137415faa4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba047f5fa44bb1c91f459e39ce79fb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afba047f5fa44bb1c91f459e39ce79fb1">SymmetrySetPrimaryMotif</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *face) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:afba047f5fa44bb1c91f459e39ce79fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b5e07a681341dd66cff32e86a4737c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3b5e07a681341dd66cff32e86a4737c1">SymmetrySetPrimaryMotif</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a3b5e07a681341dd66cff32e86a4737c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6642a5962f54c3b33048fea033b785"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6f6642a5962f54c3b33048fea033b785">SymmetrySetPrimaryMotif</a> (<a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> cptr) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a6f6642a5962f54c3b33048fea033b785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55efd114115ec1d2029b1a223c00d220"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a55efd114115ec1d2029b1a223c00d220">TextureCoordinateType</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a55efd114115ec1d2029b1a223c00d220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4fa8b5c8c6ee1ee64cf4c5a17fec5a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad4fa8b5c8c6ee1ee64cf4c5a17fec5a7">TextureMappingRequired</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ad4fa8b5c8c6ee1ee64cf4c5a17fec5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117e6bd61b7ce2b713582273af2923d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a117e6bd61b7ce2b713582273af2923d4">TextureMappingTag</a> (bool bIgnoreTextureCoordinateType) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a117e6bd61b7ce2b713582273af2923d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5862639f6aca7351b02b9d45b9eda205"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5862639f6aca7351b02b9d45b9eda205">TexturePointsAreSet</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a5862639f6aca7351b02b9d45b9eda205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae0311d57d652d267e14c2029b42f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8ae0311d57d652d267e14c2029b42f17">TextureSettingsHash</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a8ae0311d57d652d267e14c2029b42f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2710380a0b8a0fc81c752a7c99b1bbf1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2710380a0b8a0fc81c752a7c99b1bbf1">TopologyHash</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a2710380a0b8a0fc81c752a7c99b1bbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbf2e7a459c34f6ebaf254218d0e905"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2bbf2e7a459c34f6ebaf254218d0e905">Transform</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform) override</td></tr>
<tr class="memdesc:a2bbf2e7a459c34f6ebaf254218d0e905"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#a2bbf2e7a459c34f6ebaf254218d0e905">More...</a><br /></td></tr>
<tr class="separator:a2bbf2e7a459c34f6ebaf254218d0e905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d741e9c910175d62a81b345118dff8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a95d741e9c910175d62a81b345118dff8">TransformComponents</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *ci_list, size_t ci_count, <a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> component_location)</td></tr>
<tr class="separator:a95d741e9c910175d62a81b345118dff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad01eb36cc2d54649068129b9081680af"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad01eb36cc2d54649068129b9081680af">TransformComponents</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *cptr_list, size_t cptr_count, <a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> component_location)</td></tr>
<tr class="separator:ad01eb36cc2d54649068129b9081680af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa160ed35b21d978c133049442763deec"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa160ed35b21d978c133049442763deec">UnselectComponents</a> (bool bUnselectAllVertices, bool bUnselectAllEdges, bool bUnselectAllFaces) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa160ed35b21d978c133049442763deec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d5e08093907df26106d5c6b286231f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa8d5e08093907df26106d5c6b286231f">UpdateAllTagsAndSectorCoefficients</a> (bool bUnsetValuesOnly)</td></tr>
<tr class="separator:aa8d5e08093907df26106d5c6b286231f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b61884e42bdff1e5b4c86b21c20289c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4b61884e42bdff1e5b4c86b21c20289c">UpdateEdgeSectorCoefficients</a> (bool bUnsetSectorCoefficientsOnly) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a4b61884e42bdff1e5b4c86b21c20289c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c444b72b00a88cb24cbd12969f3fdf4"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6c444b72b00a88cb24cbd12969f3fdf4">UpdateEdgeTags</a> (bool bUnsetEdgeTagsOnly)</td></tr>
<tr class="separator:a6c444b72b00a88cb24cbd12969f3fdf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abc8cfa298276013a6a7b80bd911dd6"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6abc8cfa298276013a6a7b80bd911dd6">UpdateSurfaceMeshCache</a> (bool bLazyUpdate)</td></tr>
<tr class="separator:a6abc8cfa298276013a6a7b80bd911dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18de23ca2b73a3eb4dc8f1c91ce31a50"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a18de23ca2b73a3eb4dc8f1c91ce31a50">UpdateSurfaceMeshCache</a> (bool bLazyUpdate, bool bSetUnchangedFaceColor, <a class="el" href="class_o_n___color.html">ON_Color</a> unchanged_face_color, bool bSetUpdatedFaceColor, <a class="el" href="class_o_n___color.html">ON_Color</a> updated_face_color)</td></tr>
<tr class="separator:a18de23ca2b73a3eb4dc8f1c91ce31a50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40bc90f50d55be57189005f5272eca38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a40bc90f50d55be57189005f5272eca38">UpdateSymmetry</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;moved_vertices, bool bPermitTopologyChange)</td></tr>
<tr class="separator:a40bc90f50d55be57189005f5272eca38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57eea53ca915c794ed427e274779c69e"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a57eea53ca915c794ed427e274779c69e">UpdateVertexTags</a> (bool bUnsetVertexTagsOnly)</td></tr>
<tr class="separator:a57eea53ca915c794ed427e274779c69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9674c00c94246dac4344b81603591445"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_vertex_array.html">ON_SubDVertexArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9674c00c94246dac4344b81603591445">VertexArray</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a9674c00c94246dac4344b81603591445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18dfbfc1090b4d0f6755e73e034bdfa"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae18dfbfc1090b4d0f6755e73e034bdfa">VertexCount</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:ae18dfbfc1090b4d0f6755e73e034bdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4905b6f57be48ec6a7cf6ae62894b0b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4905b6f57be48ec6a7cf6ae62894b0b4">VertexFromComponentIndex</a> (<a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> component_index) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a4905b6f57be48ec6a7cf6ae62894b0b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c6558733168d3d191a9324255ddced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a22c6558733168d3d191a9324255ddced">VertexFromId</a> (unsigned int vertex_id) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a22c6558733168d3d191a9324255ddced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa33462de01a8e4c7d861ee476a61e84e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa33462de01a8e4c7d861ee476a61e84e">VertexHash</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga7901fb222b1b25e32978f0b34ba7234a">ON_SubDHashType</a> hash_type) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:aa33462de01a8e4c7d861ee476a61e84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6d675b296f4b80f7bce6becb5a9ece"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___sub_d_vertex_iterator.html">ON_SubDVertexIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2a6d675b296f4b80f7bce6becb5a9ece">VertexIterator</a> () <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a2a6d675b296f4b80f7bce6becb5a9ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa490f39b642d80aef693838cbffdc899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa490f39b642d80aef693838cbffdc899">Write</a> (<a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;archive) <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> override</td></tr>
<tr class="memdesc:aa490f39b642d80aef693838cbffdc899"><td class="mdescLeft">&#160;</td><td class="mdescRight">virtual  <a href="class_o_n___sub_d.html#aa490f39b642d80aef693838cbffdc899">More...</a><br /></td></tr>
<tr class="separator:aa490f39b642d80aef693838cbffdc899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_o_n___geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_o_n___geometry')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_o_n___geometry.html">ON_Geometry</a></td></tr>
<tr class="memitem:a65226d33b1c8c1e8289e37073566c953 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a65226d33b1c8c1e8289e37073566c953">ON_Geometry</a> ()=default</td></tr>
<tr class="separator:a65226d33b1c8c1e8289e37073566c953 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fbefc2a5f24da5f5fb4061d6849f17 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a71fbefc2a5f24da5f5fb4061d6849f17">ON_Geometry</a> (const <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> &amp;)=default</td></tr>
<tr class="separator:a71fbefc2a5f24da5f5fb4061d6849f17 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f2ca447610c622f3530944c764a3a67 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a4f2ca447610c622f3530944c764a3a67">~ON_Geometry</a> ()=default</td></tr>
<tr class="separator:a4f2ca447610c622f3530944c764a3a67 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1acdd7f0c350da696b402a9ac5edce0 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#ab1acdd7f0c350da696b402a9ac5edce0">BoundingBox</a> () const</td></tr>
<tr class="separator:ab1acdd7f0c350da696b402a9ac5edce0 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac123c564ea7a43c4406ac78954cf5266 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#ac123c564ea7a43c4406ac78954cf5266">GetBoundingBox</a> (<a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;bbox_min, <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;bbox_max, bool bGrowBox=false) const</td></tr>
<tr class="separator:ac123c564ea7a43c4406ac78954cf5266 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7259b0a7e7c663e55345788411352075 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a7259b0a7e7c663e55345788411352075">GetBoundingBox</a> (<a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;bbox, bool bGrowBox=false) const</td></tr>
<tr class="separator:a7259b0a7e7c663e55345788411352075 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e18c1d187cad2eb1c8f7e30a985c29 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#aa1e18c1d187cad2eb1c8f7e30a985c29">Morph</a> (const class <a class="el" href="class_o_n___space_morph.html">ON_SpaceMorph</a> &amp;morph)</td></tr>
<tr class="separator:aa1e18c1d187cad2eb1c8f7e30a985c29 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071e7617820ea38c40f4b3966e7daee0 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___geometry.html">ON_Geometry</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a071e7617820ea38c40f4b3966e7daee0">operator=</a> (const <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> &amp;)=default</td></tr>
<tr class="separator:a071e7617820ea38c40f4b3966e7daee0 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49629d8d427ee579d9b28c1e25818e0 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#af49629d8d427ee579d9b28c1e25818e0">Rotate</a> (double rotation_angle, const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;rotation_axis, const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;rotation_center)</td></tr>
<tr class="separator:af49629d8d427ee579d9b28c1e25818e0 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8306ab6d43886453a056160429bc0a inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a3c8306ab6d43886453a056160429bc0a">Rotate</a> (double sin_angle, double cos_angle, const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;rotation_axis, const <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;rotation_center)</td></tr>
<tr class="separator:a3c8306ab6d43886453a056160429bc0a inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b847d6dcda412468ab59f06328b2619 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a1b847d6dcda412468ab59f06328b2619">Scale</a> (double scale_factor)</td></tr>
<tr class="separator:a1b847d6dcda412468ab59f06328b2619 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b47e669fde50b5223a8017863598e89 inherit pub_methods_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a3b47e669fde50b5223a8017863598e89">Translate</a> (const <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;translation_vector)</td></tr>
<tr class="separator:a3b47e669fde50b5223a8017863598e89 inherit pub_methods_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_o_n___object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_o_n___object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_o_n___object.html">ON_Object</a></td></tr>
<tr class="memitem:af580c6199f4469c49a4e09a117626c10 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#af580c6199f4469c49a4e09a117626c10">ON_Object</a> () <a class="el" href="group__open_n_u_r_b_s.html#ga1b9bbb0fba1d3a5fae3accc23a26e990">ON_NOEXCEPT</a></td></tr>
<tr class="separator:af580c6199f4469c49a4e09a117626c10 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274166b34d06fc07a85997fd01b2dab1 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a274166b34d06fc07a85997fd01b2dab1">ON_Object</a> (const <a class="el" href="class_o_n___object.html">ON_Object</a> &amp;)</td></tr>
<tr class="separator:a274166b34d06fc07a85997fd01b2dab1 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad940aab7d51005c8732d76d1b188e332 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ad940aab7d51005c8732d76d1b188e332">~ON_Object</a> ()</td></tr>
<tr class="separator:ad940aab7d51005c8732d76d1b188e332 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5432b341051664c185b10712a6e5b79 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ad5432b341051664c185b10712a6e5b79">AttachUserData</a> (class <a class="el" href="class_o_n___user_data.html">ON_UserData</a> *pUserData)</td></tr>
<tr class="separator:ad5432b341051664c185b10712a6e5b79 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27893ff72ca7abbe985f8b5f4ccd900e inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a27893ff72ca7abbe985f8b5f4ccd900e">ClearAllComponentStates</a> () const</td></tr>
<tr class="separator:a27893ff72ca7abbe985f8b5f4ccd900e inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58958333257eba5575a6a1b09c366c1b inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a58958333257eba5575a6a1b09c366c1b">CopyUserData</a> (const <a class="el" href="class_o_n___object.html">ON_Object</a> &amp;source_object)</td></tr>
<tr class="separator:a58958333257eba5575a6a1b09c366c1b inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad044157e5c1efde9fce1c6ccf6e81ff3 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ad044157e5c1efde9fce1c6ccf6e81ff3">CopyUserData</a> (const <a class="el" href="class_o_n___object.html">ON_Object</a> &amp;source_object, <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> source_userdata_item_id, <a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956c">ON_Object::UserDataConflictResolution</a> userdata_conflict_resolution)</td></tr>
<tr class="separator:ad044157e5c1efde9fce1c6ccf6e81ff3 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbb0eff3b2287152b40991b3afca9ee inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a1dbb0eff3b2287152b40991b3afca9ee">DetachUserData</a> (class <a class="el" href="class_o_n___user_data.html">ON_UserData</a> *pUserData)</td></tr>
<tr class="separator:a1dbb0eff3b2287152b40991b3afca9ee inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad265ca0da2d751edaa9d2b5ab2540c6a inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ad265ca0da2d751edaa9d2b5ab2540c6a">EmergencyDestroy</a> ()</td></tr>
<tr class="separator:ad265ca0da2d751edaa9d2b5ab2540c6a inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb43bb324c44740c4bc2932e2f95c835 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___user_data.html">ON_UserData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#adb43bb324c44740c4bc2932e2f95c835">FirstUserData</a> () const</td></tr>
<tr class="separator:adb43bb324c44740c4bc2932e2f95c835 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f8d609e22008680581c6ca72ac47df inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">class <a class="el" href="class_o_n___user_data.html">ON_UserData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a29f8d609e22008680581c6ca72ac47df">GetUserData</a> (const <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> &amp;userdata_uuid) const</td></tr>
<tr class="separator:a29f8d609e22008680581c6ca72ac47df inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40b5e89b4766299e415593b31a3849c inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ab40b5e89b4766299e415593b31a3849c">GetUserString</a> (const wchar_t *key, <a class="el" href="class_o_n__w_string.html">ON_wString</a> &amp;string_value) const</td></tr>
<tr class="separator:ab40b5e89b4766299e415593b31a3849c inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac285fba1506b2b9b821e3655582939c4 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ac285fba1506b2b9b821e3655582939c4">GetUserStringKeys</a> (<a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n__w_string.html">ON_wString</a> &gt; &amp;user_string_keys) const</td></tr>
<tr class="separator:ac285fba1506b2b9b821e3655582939c4 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004ab49490f69fcdc7681919c3837a33 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a004ab49490f69fcdc7681919c3837a33">GetUserStrings</a> (<a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___user_string.html">ON_UserString</a> &gt; &amp;user_strings) const</td></tr>
<tr class="separator:a004ab49490f69fcdc7681919c3837a33 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266957f93639a598b0e1b6a89e0bb40d inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a266957f93639a598b0e1b6a89e0bb40d">IsCorrupt</a> (bool bRepair, bool bSilentError, class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *text_log) const</td></tr>
<tr class="separator:a266957f93639a598b0e1b6a89e0bb40d inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5367058a90545e81cd79b78103175d inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#afe5367058a90545e81cd79b78103175d">IsKindOf</a> (const <a class="el" href="class_o_n___class_id.html">ON_ClassId</a> *pClassId) const</td></tr>
<tr class="separator:afe5367058a90545e81cd79b78103175d inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c508d3b53458e252adbcd29e62ed09 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a21c508d3b53458e252adbcd29e62ed09">ModelObjectId</a> () const</td></tr>
<tr class="separator:a21c508d3b53458e252adbcd29e62ed09 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a891ae2cb2a25008a7a39cb19dfcea inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a54a891ae2cb2a25008a7a39cb19dfcea">MoveUserData</a> (<a class="el" href="class_o_n___object.html">ON_Object</a> &amp;source_object)</td></tr>
<tr class="separator:a54a891ae2cb2a25008a7a39cb19dfcea inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b4ecb2eb36641e1ee6b4fc6129606e inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a78b4ecb2eb36641e1ee6b4fc6129606e">MoveUserData</a> (<a class="el" href="class_o_n___object.html">ON_Object</a> &amp;source_object, <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> source_userdata_item_id, <a class="el" href="class_o_n___object.html#a7f520e987ffa14e71b06493340f9956c">ON_Object::UserDataConflictResolution</a> userdata_conflict_resolution, bool bDeleteAllSourceItems)</td></tr>
<tr class="separator:a78b4ecb2eb36641e1ee6b4fc6129606e inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba6166c9aecef42639e684a2a3fda223 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_o_n___object.html">ON_Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#aba6166c9aecef42639e684a2a3fda223">operator=</a> (const <a class="el" href="class_o_n___object.html">ON_Object</a> &amp;)</td></tr>
<tr class="separator:aba6166c9aecef42639e684a2a3fda223 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b61cafc0024ecb7a4bd22da2718680 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a88b61cafc0024ecb7a4bd22da2718680">PurgeUserData</a> ()</td></tr>
<tr class="separator:a88b61cafc0024ecb7a4bd22da2718680 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074dc9e9b919853919564793c37f5143 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a074dc9e9b919853919564793c37f5143">SetUserString</a> (const wchar_t *key, const wchar_t *string_value)</td></tr>
<tr class="separator:a074dc9e9b919853919564793c37f5143 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7234af898c307a2c2f7931db7e627592 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a7234af898c307a2c2f7931db7e627592">SetUserStrings</a> (int count, const <a class="el" href="class_o_n___user_string.html">ON_UserString</a> *user_strings, bool bReplace)</td></tr>
<tr class="separator:a7234af898c307a2c2f7931db7e627592 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c747a7a2fe9a7481b55f0b631942ce inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a41c747a7a2fe9a7481b55f0b631942ce">ThisIsNullptr</a> (bool bSilentError) const</td></tr>
<tr class="separator:a41c747a7a2fe9a7481b55f0b631942ce inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881bd2f0d8515adba1c42c578bcb7052 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a881bd2f0d8515adba1c42c578bcb7052">TransformUserData</a> (const class <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;xform)</td></tr>
<tr class="separator:a881bd2f0d8515adba1c42c578bcb7052 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82188bbf97bbd149ac6fcb7cd8e989d1 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#a82188bbf97bbd149ac6fcb7cd8e989d1">UpdateReferencedComponents</a> (const class <a class="el" href="class_o_n___component_manifest.html">ON_ComponentManifest</a> &amp;source_manifest, const class <a class="el" href="class_o_n___component_manifest.html">ON_ComponentManifest</a> &amp;destination_manifest, const class <a class="el" href="class_o_n___manifest_map.html">ON_ManifestMap</a> &amp;manifest_map)</td></tr>
<tr class="separator:a82188bbf97bbd149ac6fcb7cd8e989d1 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab648403ebf4592831809710f378e9ac2 inherit pub_methods_class_o_n___object"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___object.html#ab648403ebf4592831809710f378e9ac2">UserStringCount</a> () const</td></tr>
<tr class="separator:ab648403ebf4592831809710f378e9ac2 inherit pub_methods_class_o_n___object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3dda37cd9bafdc77b338bcc63936fc4e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3dda37cd9bafdc77b338bcc63936fc4e">AutomaticMeshToSubD</a> (<a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b">ON_SubD::AutomaticMeshToSubDContext</a> context)</td></tr>
<tr class="separator:a3dda37cd9bafdc77b338bcc63936fc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab5a32a6648e36623f825e65974554e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3ab5a32a6648e36623f825e65974554e">AutomaticMeshToSubDRestoreDefaults</a> (<a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b">ON_SubD::AutomaticMeshToSubDContext</a> context)</td></tr>
<tr class="separator:a3ab5a32a6648e36623f825e65974554e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d971e3c8b8e1a8cc2878c7a2d1f2518"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5d971e3c8b8e1a8cc2878c7a2d1f2518">ComponentRingEdgeCount</a> (size_t component_ring_count)</td></tr>
<tr class="separator:a5d971e3c8b8e1a8cc2878c7a2d1f2518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf53e96f7ea28fd73ec437cada5e9537"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aaf53e96f7ea28fd73ec437cada5e9537">ComponentRingFaceCount</a> (size_t component_ring_count)</td></tr>
<tr class="separator:aaf53e96f7ea28fd73ec437cada5e9537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af939c7a93096559800d2c7e82aac4e9a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af939c7a93096559800d2c7e82aac4e9a">ComponentRingIsValid</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_ring, size_t component_ring_count)</td></tr>
<tr class="separator:af939c7a93096559800d2c7e82aac4e9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab26ee8a44d5011366c4b1b061d785a62"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab26ee8a44d5011366c4b1b061d785a62">ControlPointRadiusFromSurfacePointRadius</a> (unsigned int point_count, double surface_point_radius)</td></tr>
<tr class="separator:ab26ee8a44d5011366c4b1b061d785a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adb59e3e0e59e1582ccc5436fade9bc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1adb59e3e0e59e1582ccc5436fade9bc">CreateControlNetFromNurbsCurves</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;polylines, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a1adb59e3e0e59e1582ccc5436fade9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1d3dadbcd3eecfd604629da9afb5959"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac1d3dadbcd3eecfd604629da9afb5959">CreateControlNetFromNurbsCurves</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___object_array.html">ON_ObjectArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;polylines, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:ac1d3dadbcd3eecfd604629da9afb5959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324a97da2a5aa3c8123aae243a462ac7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a324a97da2a5aa3c8123aae243a462ac7">CreateControlNetFromNurbsCurves</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;polylines, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a324a97da2a5aa3c8123aae243a462ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acae5941c4293a6b1cf269238b6a79a54"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#acae5941c4293a6b1cf269238b6a79a54">CreateControlNetFromPolylines</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> &gt; &amp;polylines, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:acae5941c4293a6b1cf269238b6a79a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae597aee9dafc59adba8abf3d3092c592"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae597aee9dafc59adba8abf3d3092c592">CreateControlNetFromPolylines</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___polyline_curve.html">ON_PolylineCurve</a> &gt; &amp;polylines, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:ae597aee9dafc59adba8abf3d3092c592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a27a9d5857262adb81f202aa279d56"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a85a27a9d5857262adb81f202aa279d56">CreateControlNetFromPolylines</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___object_array.html">ON_ObjectArray</a>&lt; <a class="el" href="class_o_n___polyline_curve.html">ON_PolylineCurve</a> &gt; &amp;polylines, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a85a27a9d5857262adb81f202aa279d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8399b4b9a51b672af373045976f2caa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad8399b4b9a51b672af373045976f2caa">CreateControlNetFromPolylines</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; &amp;polylines, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:ad8399b4b9a51b672af373045976f2caa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a273ed1a4acabfe04d199d36f3d973a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0a273ed1a4acabfe04d199d36f3d973a">CreateControlNetFromPolylines</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___polyline_curve.html">ON_PolylineCurve</a> * &gt; &amp;polylines, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a0a273ed1a4acabfe04d199d36f3d973a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8927364fd5256139bf2dfd8d7b8d9b2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab8927364fd5256139bf2dfd8d7b8d9b2">CreateCylinder</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___cylinder.html">ON_Cylinder</a> &amp;cylinder, unsigned circumference_face_count, unsigned height_face_count, <a class="el" href="group__open_n_u_r_b_s.html#ga06c51562f7fa69ab3273a2d4a63f3c41">ON_SubDEndCapStyle</a> end_cap_style, <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> end_cap_edge_tag, <a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> radius_location, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:ab8927364fd5256139bf2dfd8d7b8d9b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e93a0b2e823c12081f6e3e6efe8ef2d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7e93a0b2e823c12081f6e3e6efe8ef2d">CreateFromBoundary</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___curve.html">ON_Curve</a> &amp;curve, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a7e93a0b2e823c12081f6e3e6efe8ef2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d64c8c2acf505dffbf977c0546d3b85"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2d64c8c2acf505dffbf977c0546d3b85">CreateFromLoftCurves</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;curves, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a2d64c8c2acf505dffbf977c0546d3b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc8a8c93ac9271aa3f0549de04f1d7b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2cc8a8c93ac9271aa3f0549de04f1d7b">CreateFromLoftCurves</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___object_array.html">ON_ObjectArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;curves, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a2cc8a8c93ac9271aa3f0549de04f1d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22092cb18ce644f718c38221cadd2262"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a22092cb18ce644f718c38221cadd2262">CreateFromLoftCurves</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;curves, bool bPeriodicClosedLoft, bool bCorners, unsigned int span_divisions, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a22092cb18ce644f718c38221cadd2262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64271fbccd945aceba18409ce1342c08"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a64271fbccd945aceba18409ce1342c08">CreateFromMesh</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *level_zero_mesh, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_from_mesh_parameters.html">ON_SubDFromMeshParameters</a> *from_mesh_parameters, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *subd)</td></tr>
<tr class="separator:a64271fbccd945aceba18409ce1342c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a015e1ff89dbd2c50ff6516488894fb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9a015e1ff89dbd2c50ff6516488894fb">CreateFromSurface</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___surface.html">ON_Surface</a> &amp;surface, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_from_surface_parameters.html">ON_SubDFromSurfaceParameters</a> *from_surface_parameters, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a9a015e1ff89dbd2c50ff6516488894fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbd2a9c4bb8bacfcdc98cd951f28b1b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a6dbd2a9c4bb8bacfcdc98cd951f28b1b">CreateSubDBox</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> corners[8], <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag, unsigned int facecount_x, unsigned int facecount_y, unsigned int facecount_z, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a6dbd2a9c4bb8bacfcdc98cd951f28b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31445715b80ffdda3999c1c380dff3bd"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a31445715b80ffdda3999c1c380dff3bd">CreateSubDFriendlyCurve</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___curve.html">ON_Curve</a> &amp;curve, class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve)</td></tr>
<tr class="separator:a31445715b80ffdda3999c1c380dff3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9715a1968ac70233f140541b899c569"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa9715a1968ac70233f140541b899c569">CreateSubDFriendlyCurve</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___curve.html">ON_Curve</a> &amp;curve, int cv_count, bool bPeriodicClosedCurve, class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve)</td></tr>
<tr class="separator:aa9715a1968ac70233f140541b899c569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47be7c4b5e96e48e7e9c7f9102787290"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a47be7c4b5e96e48e7e9c7f9102787290">CreateSubDFriendlyCurve</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___curve.html">ON_Curve</a> &amp;curve, int cv_count, class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve)</td></tr>
<tr class="separator:a47be7c4b5e96e48e7e9c7f9102787290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7de3d9c4ef19abf6f1ba05809b51d0d"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af7de3d9c4ef19abf6f1ba05809b51d0d">CreateSubDFriendlyCurve</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *points, size_t point_count, int point_stride, bool bInterpolatePoints, bool bPeriodicClosedCurve, class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve)</td></tr>
<tr class="separator:af7de3d9c4ef19abf6f1ba05809b51d0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fdf614b14a8657d91d5f48c6076fd6"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab9fdf614b14a8657d91d5f48c6076fd6">CreateSubDFriendlyCurve</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *points, size_t point_count, int point_stride, bool bInterpolatePoints, bool bPeriodicClosedCurve, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> bool *creases, class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve)</td></tr>
<tr class="separator:ab9fdf614b14a8657d91d5f48c6076fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a746e7f1fa98ad026fc3ce911166be"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a79a746e7f1fa98ad026fc3ce911166be">CreateSubDFriendlyCurve</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *points, size_t point_count, bool bInterpolatePoints, bool bPeriodicClosedCurve, class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve)</td></tr>
<tr class="separator:a79a746e7f1fa98ad026fc3ce911166be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1705a37c1ab6f4a6dce3ed8f7147650a"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a1705a37c1ab6f4a6dce3ed8f7147650a">CreateSubDFriendlyCurve</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;points, bool bInterpolatePoints, bool bPeriodicClosedCurve, class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve)</td></tr>
<tr class="separator:a1705a37c1ab6f4a6dce3ed8f7147650a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2198bbe0bf3c3f7901638c439aa97411"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a2198bbe0bf3c3f7901638c439aa97411">CreateSubDFriendlyCurve</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *edge_chain, size_t edge_count, class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve)</td></tr>
<tr class="separator:a2198bbe0bf3c3f7901638c439aa97411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac920bccf0353c3a8e8c573931e8c81fc"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ac920bccf0353c3a8e8c573931e8c81fc">CreateSubDFriendlyCurve</a> (<a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;edge_chain, class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *destination_curve)</td></tr>
<tr class="separator:ac920bccf0353c3a8e8c573931e8c81fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ef1861b9ea3c854380818a09799656"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad5ef1861b9ea3c854380818a09799656">CreateSubDFriendlyIsoCurves</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___surface.html">ON_Surface</a> &amp;surface, int iso_dir, <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;loft_curves, bool &amp;bPeriodicClosedLoft, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; bool &gt; &amp;loft_creases, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; double &gt; &amp;loft_parameters)</td></tr>
<tr class="separator:ad5ef1861b9ea3c854380818a09799656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90055f8dc99ea1d3308764dbe3d5eee3"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a90055f8dc99ea1d3308764dbe3d5eee3">CreateSubDFriendlySurface</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___surface.html">ON_Surface</a> &amp;surface, class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *destination_surface)</td></tr>
<tr class="separator:a90055f8dc99ea1d3308764dbe3d5eee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaff188797270d23af771cb94b017e594"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aaff188797270d23af771cb94b017e594">CreateSubDFriendlySurface</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;cubic_curves, bool bPeriodicClosedLoft, class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *destination_surface)</td></tr>
<tr class="separator:aaff188797270d23af771cb94b017e594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb73704774f0b1ae299dc1a5ed160bc0"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#abb73704774f0b1ae299dc1a5ed160bc0">CreateSubDFriendlySurface</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___object_array.html">ON_ObjectArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;cubic_curves, bool bPeriodicClosedLoft, class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *destination_surface)</td></tr>
<tr class="separator:abb73704774f0b1ae299dc1a5ed160bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff47daae372916cbb3a7e8d7f704b616"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aff47daae372916cbb3a7e8d7f704b616">CreateSubDFriendlySurface</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;cubic_curves, bool bPeriodicClosedLoft, class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *destination_surface)</td></tr>
<tr class="separator:aff47daae372916cbb3a7e8d7f704b616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35406e9c7cf6f1c0f1152bf966ab65da"><td class="memItemLeft" align="right" valign="top">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a35406e9c7cf6f1c0f1152bf966ab65da">CreateSubDFriendlySurface</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;cubic_curves, bool bPeriodicClosedLoft, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> bool *creases, class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *destination_surface)</td></tr>
<tr class="separator:a35406e9c7cf6f1c0f1152bf966ab65da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4276ceecf5d9da29219d521c9e897313"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4276ceecf5d9da29219d521c9e897313">EdgesAreConsecutive</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> eptr0, <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> eptr1)</td></tr>
<tr class="separator:a4276ceecf5d9da29219d521c9e897313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95092a4c2ad4c34b6fdfbad6f02b878f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a95092a4c2ad4c34b6fdfbad6f02b878f">EdgeTagFromContext</a> (unsigned int edge_face_count, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *v1)</td></tr>
<tr class="separator:a95092a4c2ad4c34b6fdfbad6f02b878f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd53a99331439ace74c0ac49b3918a86"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afd53a99331439ace74c0ac49b3918a86">EdgeTagFromContext</a> (unsigned int edge_face_count, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> v0_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> v1_tag)</td></tr>
<tr class="separator:afd53a99331439ace74c0ac49b3918a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fb05798d437723086ef93db64fefa2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af7fb05798d437723086ef93db64fefa2">EdgeTagFromUnsigned</a> (unsigned int edge_tag_as_unsigned)</td></tr>
<tr class="separator:af7fb05798d437723086ef93db64fefa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067478a57421c549bc95103706634947"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a067478a57421c549bc95103706634947">EdgeTagIsSet</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag)</td></tr>
<tr class="separator:a067478a57421c549bc95103706634947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4796f84493fc71b931ddbc9723a2db0"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__w_string.html">ON_wString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa4796f84493fc71b931ddbc9723a2db0">EdgeTagToString</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> edge_tag, bool bVertose)</td></tr>
<tr class="separator:aa4796f84493fc71b931ddbc9723a2db0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96e32c6c7de19b165f10f85a29f5af6"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#af96e32c6c7de19b165f10f85a29f5af6">GetBoundaryEdgeChain</a> (<a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> first_edge, bool bUseEdgeMarks, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;boundary_edge_chain)</td></tr>
<tr class="separator:af96e32c6c7de19b165f10f85a29f5af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705058bd9a47a3bec2ae81aa406f3ded"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a705058bd9a47a3bec2ae81aa406f3ded">GetQuadSectorPointRing</a> (bool bFirstPass, bool bSecondPass, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *vertex0, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_ring, size_t component_ring_count, double *point_ring, size_t point_ring_stride)</td></tr>
<tr class="separator:a705058bd9a47a3bec2ae81aa406f3ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1879f6e2db9595b151662f3d3abdb50"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aa1879f6e2db9595b151662f3d3abdb50">GetSectorComponentRing</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;sit, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;component_ring)</td></tr>
<tr class="separator:aa1879f6e2db9595b151662f3d3abdb50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6fa647489a336e4a646cc81bba8f9b"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aea6fa647489a336e4a646cc81bba8f9b">GetSectorComponentRing</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;sit, <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_ring, size_t component_ring_capacity)</td></tr>
<tr class="separator:aea6fa647489a336e4a646cc81bba8f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f81ea18d9ad1c91ae79fd49bd921d3"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ad3f81ea18d9ad1c91ae79fd49bd921d3">GetSectorPointRing</a> (bool bSubdivideIfNeeded, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;sit, double *point_ring, size_t point_ring_capacity, size_t point_ring_stride)</td></tr>
<tr class="separator:ad3f81ea18d9ad1c91ae79fd49bd921d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bbb84714f1d77312b9dedd3f65764bf"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4bbb84714f1d77312b9dedd3f65764bf">GetSectorPointRing</a> (bool bSubdivideIfNeeded, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;sit, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;point_ring)</td></tr>
<tr class="separator:a4bbb84714f1d77312b9dedd3f65764bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348cc3cde6a65b8dfac76796f02bb510"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a348cc3cde6a65b8dfac76796f02bb510">GetSectorPointRing</a> (bool bSubdivideIfNeeded, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_ring, size_t component_ring_count, double *subd_point_ring, size_t subd_point_ring_capacity, size_t subd_point_ring_stride)</td></tr>
<tr class="separator:a348cc3cde6a65b8dfac76796f02bb510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd32809ce5ea79039aa5ccf5251e0530"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afd32809ce5ea79039aa5ccf5251e0530">GetSectorPointRing</a> (bool bSubdivideIfNeeded, size_t component_ring_count, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_ring, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;point_ring)</td></tr>
<tr class="separator:afd32809ce5ea79039aa5ccf5251e0530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb682e5c3f906ddfb393418feea72a2c"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aeb682e5c3f906ddfb393418feea72a2c">GetSectorSubdivisionPointRing</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_ring, size_t component_ring_count, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;subd_point_ring)</td></tr>
<tr class="separator:aeb682e5c3f906ddfb393418feea72a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41f99166629e3a016610cde5e26e9ab5"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a41f99166629e3a016610cde5e26e9ab5">GetSectorSubdivsionPointRing</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_ring, size_t component_ring_count, double *point_ring, size_t point_ring_capacity, size_t point_ring_stride)</td></tr>
<tr class="separator:a41f99166629e3a016610cde5e26e9ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9d90c17fbb3de7f59a53032fa3fd70"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9b9d90c17fbb3de7f59a53032fa3fd70">IsBuiltInFacePackingId</a> (<a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> candidate_id)</td></tr>
<tr class="separator:a9b9d90c17fbb3de7f59a53032fa3fd70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92475c9058b052ae0b53e6c5bee80b4d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a92475c9058b052ae0b53e6c5bee80b4d">IsSubDFriendlyCurve</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___curve.html">ON_Curve</a> *curve)</td></tr>
<tr class="separator:a92475c9058b052ae0b53e6c5bee80b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e72349efa7555baab2680ec83293dd1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7e72349efa7555baab2680ec83293dd1">IsSubDFriendlySurface</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___surface.html">ON_Surface</a> *surface)</td></tr>
<tr class="separator:a7e72349efa7555baab2680ec83293dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8eb9196c3cc9f5fca17e1af2be9735"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a3e8eb9196c3cc9f5fca17e1af2be9735">IsValidSectorEdgeCount</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, unsigned int sector_edge_count)</td></tr>
<tr class="separator:a3e8eb9196c3cc9f5fca17e1af2be9735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18591efe5b4e4c54f2055aaac6feae88"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a18591efe5b4e4c54f2055aaac6feae88">IsValidSectorFaceCount</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, unsigned int sector_face_count)</td></tr>
<tr class="separator:a18591efe5b4e4c54f2055aaac6feae88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fe2a7a2f837731fefcb1be7f988a4a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6e">ON_SubD::SubDFriendlyKnotType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a34fe2a7a2f837731fefcb1be7f988a4a">NurbsKnotType</a> (int order, int cv_count, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *knots)</td></tr>
<tr class="separator:a34fe2a7a2f837731fefcb1be7f988a4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf8c05b048eac0ea6cd68cf541dba6a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6e">ON_SubD::SubDFriendlyKnotType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#afaf8c05b048eac0ea6cd68cf541dba6a">NurbsKnotType</a> (int order, int cv_count, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *knots, <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; double &gt; *triple_knots)</td></tr>
<tr class="separator:afaf8c05b048eac0ea6cd68cf541dba6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb5bbba924fd7eeb9f1114e9e1d4e35f"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aeb5bbba924fd7eeb9f1114e9e1d4e35f">ObsoleteTextureDomainTypeFromTextureCoordinateType</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a> texture_coordinate_type)</td></tr>
<tr class="separator:aeb5bbba924fd7eeb9f1114e9e1d4e35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f32cd4c67a3dde22722a3496cc1dbd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a68f32cd4c67a3dde22722a3496cc1dbd">SetAutomaticMeshToSubD</a> (<a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b">ON_SubD::AutomaticMeshToSubDContext</a> context, bool bAutomaticallyCreateSubD)</td></tr>
<tr class="separator:a68f32cd4c67a3dde22722a3496cc1dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a685e0d610153a2da25ebc2cdceeb0506"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a685e0d610153a2da25ebc2cdceeb0506">SubdivideSector</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *center_vertex, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *component_ring, size_t component_ring_count, class <a class="el" href="class_o_n___sub_d___fixed_size_heap.html">ON_SubD_FixedSizeHeap</a> &amp;fsh)</td></tr>
<tr class="separator:a685e0d610153a2da25ebc2cdceeb0506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3592b175f1d85167fb47bead2cb94cb"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab3592b175f1d85167fb47bead2cb94cb">SurfacePointRadiusFromControlPointRadius</a> (unsigned int point_count, double control_point_radius)</td></tr>
<tr class="separator:ab3592b175f1d85167fb47bead2cb94cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abe50d4a88701c0df1cd6df7bbb3a28"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8abe50d4a88701c0df1cd6df7bbb3a28">SwapContents</a> (<a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;a, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;b)</td></tr>
<tr class="separator:a8abe50d4a88701c0df1cd6df7bbb3a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8505b580a27ddf53b222b7ede1024a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a8e8505b580a27ddf53b222b7ede1024a">TextureCoordinateTypeFromObsoleteTextureDomainType</a> (unsigned int obsolete_texture_domain_type_as_unsigned)</td></tr>
<tr class="separator:a8e8505b580a27ddf53b222b7ede1024a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4709733867708cd9adf94504a19183df"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4709733867708cd9adf94504a19183df">TextureCoordinateTypeFromUnsigned</a> (unsigned int texture_coordinate_type_as_unsigned)</td></tr>
<tr class="separator:a4709733867708cd9adf94504a19183df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4a9535477f648edd823acbb06bea7a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__w_string.html">ON_wString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a4f4a9535477f648edd823acbb06bea7a">TextureCoordinateTypeToString</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a> texture_domain_type)</td></tr>
<tr class="separator:a4f4a9535477f648edd823acbb06bea7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a2bb58158274846a0cb947f5e1ad71"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__2udex.html">ON_2udex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a86a2bb58158274846a0cb947f5e1ad71">TextureDomainGridSize</a> (unsigned minimum_rectangle_count, double image_width, double image_height)</td></tr>
<tr class="separator:a86a2bb58158274846a0cb947f5e1ad71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cbe52b259de629d208d6310bab45014"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5cbe52b259de629d208d6310bab45014">TextureSettingsHash</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a> texture_coordinate_type, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> &amp;texture_mapping_tag)</td></tr>
<tr class="separator:a5cbe52b259de629d208d6310bab45014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a06c7826df2f6138eb6dde6cbd6a10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae0a06c7826df2f6138eb6dde6cbd6a10">ToggleSubDAppearanceValue</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> subd_appearance)</td></tr>
<tr class="separator:ae0a06c7826df2f6138eb6dde6cbd6a10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9814679b28aa6b8b427d4ec4b7bba86c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a9814679b28aa6b8b427d4ec4b7bba86c">ToSubD</a> (<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> *geometry, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_from_mesh_parameters.html">ON_SubDFromMeshParameters</a> *from_mesh_parameters, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_from_surface_parameters.html">ON_SubDFromSurfaceParameters</a> *from_surface_parameters, <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *destination_subd)</td></tr>
<tr class="separator:a9814679b28aa6b8b427d4ec4b7bba86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ff849a7ae2edb61a78ff6c2be74cb2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07e">ON_SubD::VertexFacetType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a43ff849a7ae2edb61a78ff6c2be74cb2">VertexFacetTypeFromUnsigned</a> (unsigned int vertex_facet_type_as_unsigned)</td></tr>
<tr class="separator:a43ff849a7ae2edb61a78ff6c2be74cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a042140d0f88f2bd8296c9204ac1d2c5d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a042140d0f88f2bd8296c9204ac1d2c5d">VertexTagFromUnsigned</a> (unsigned int vertex_tag_as_unsigned)</td></tr>
<tr class="separator:a042140d0f88f2bd8296c9204ac1d2c5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a3a3ecd63cb32092d68750e72ec9d9d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a5a3a3ecd63cb32092d68750e72ec9d9d">VertexTagIsSet</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag)</td></tr>
<tr class="separator:a5a3a3ecd63cb32092d68750e72ec9d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a333c6e6a3241e8f7c5e70e0f43f641"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__w_string.html">ON_wString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a0a333c6e6a3241e8f7c5e70e0f43f641">VertexTagToString</a> (<a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> vertex_tag, bool bVertose)</td></tr>
<tr class="separator:a0a333c6e6a3241e8f7c5e70e0f43f641"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7779274fc4314207f5c8d71accb180dd"><td class="memItemLeft" align="right" valign="top">**ON_RTreeRef ControlNetComponentTree bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a></td></tr>
<tr class="separator:a7779274fc4314207f5c8d71accb180dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ab50603eacdbc50beb23a88590df6e55c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab50603eacdbc50beb23a88590df6e55c">DefaultFacePackingId</a></td></tr>
<tr class="memdesc:ab50603eacdbc50beb23a88590df6e55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ADD NEW PackFaces ids above this comment and below FastAndSimplePackFacesId.  <a href="class_o_n___sub_d.html#ab50603eacdbc50beb23a88590df6e55c">More...</a><br /></td></tr>
<tr class="separator:ab50603eacdbc50beb23a88590df6e55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae697f8dd0197a793faefd5dd71c626dc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ae697f8dd0197a793faefd5dd71c626dc">DefaultSubDAppearance</a></td></tr>
<tr class="memdesc:ae697f8dd0197a793faefd5dd71c626dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">= <a class="el" href="group__open_n_u_r_b_s.html#gga0a25951e3c8f7324e2747162822b819aaaa0d528ba11ea1485d466dfe1ea40819">ON_SubDComponentLocation::Surface</a>  <a href="class_o_n___sub_d.html#ae697f8dd0197a793faefd5dd71c626dc">More...</a><br /></td></tr>
<tr class="separator:ae697f8dd0197a793faefd5dd71c626dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94a79d9f4138a75a94a04aa1632a134"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#ab94a79d9f4138a75a94a04aa1632a134">DefaultTextureCoordinateType</a></td></tr>
<tr class="memdesc:ab94a79d9f4138a75a94a04aa1632a134"><td class="mdescLeft">&#160;</td><td class="mdescRight">= <a class="el" href="group__open_n_u_r_b_s.html#gga6c7104f591f9fbf8f6ab27894df3e33faa1977c3f68d4d3bbfe14d0e51a575482">ON_SubDTextureCoordinateType::Packed</a>  <a href="class_o_n___sub_d.html#ab94a79d9f4138a75a94a04aa1632a134">More...</a><br /></td></tr>
<tr class="separator:ab94a79d9f4138a75a94a04aa1632a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadc6b3bd637b36f409114a91ef9c2a51"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#aadc6b3bd637b36f409114a91ef9c2a51">Empty</a></td></tr>
<tr class="separator:aadc6b3bd637b36f409114a91ef9c2a51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778015a5a25baa18fef1c821f325a1f2"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a778015a5a25baa18fef1c821f325a1f2">ErrorCount</a></td></tr>
<tr class="separator:a778015a5a25baa18fef1c821f325a1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd29ac82d1fa8c05858cfb0e20d84880"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#acd29ac82d1fa8c05858cfb0e20d84880">FastAndSimpleFacePackingId</a></td></tr>
<tr class="memdesc:acd29ac82d1fa8c05858cfb0e20d84880"><td class="mdescLeft">&#160;</td><td class="mdescRight">The fast and simple face packing uses topology, vertex tags, and edge tags to group quads into rectangular grids. It does not perform geometric feature analysis. {C3D8DD54-F8C8-4455-BB0E-2A2F4988EC81}  <a href="class_o_n___sub_d.html#acd29ac82d1fa8c05858cfb0e20d84880">More...</a><br /></td></tr>
<tr class="separator:acd29ac82d1fa8c05858cfb0e20d84880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_class_o_n___geometry"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_class_o_n___geometry')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="class_o_n___geometry.html">ON_Geometry</a></td></tr>
<tr class="memitem:a03dcd2409adc639499e0ca07944dfd0c inherit pub_static_attribs_class_o_n___geometry"><td class="memItemLeft" align="right" valign="top">const static <a class="el" href="class_o_n___geometry.html">ON_Geometry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___geometry.html#a03dcd2409adc639499e0ca07944dfd0c">Unset</a></td></tr>
<tr class="separator:a03dcd2409adc639499e0ca07944dfd0c inherit pub_static_attribs_class_o_n___geometry"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a431e8061728e7cfcb0c903e5aaf71c71"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_o_n___sub_d.html#a431e8061728e7cfcb0c903e5aaf71c71">ON_SubDRef</a></td></tr>
<tr class="separator:a431e8061728e7cfcb0c903e5aaf71c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a89d6c70eef1e83ec2a0889fd2bea9e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d6c70eef1e83ec2a0889fd2bea9e7e">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a89d6c70eef1e83ec2a0889fd2bea9e7eaaaafc6d2b5efd3c1d3214afbaa46c9bc"></a>maximum_subd_level&#160;</td><td class="fielddoc"><p>uses as a sanity check on input parameters </p>
</td></tr>
</table>

</div>
</div>
<a id="a6356d9ba7b424672377a4722efd09b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6356d9ba7b424672377a4722efd09b3c">&#9670;&nbsp;</a></span>anonymous enum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum : unsigned int</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a6356d9ba7b424672377a4722efd09b3cab72d6681c2028801f5b78c651928692d"></a>TextureImageSuggestedMinimumSize&#160;</td><td class="fielddoc"><p>ON_SUbDFace packing rectangle information is calculated so that there is at least one unused pixel between adjacent packing rectangles when a texture image size is TextureImageSuggestedMinimumSize x TextureImageSuggestedMinimumSize pixels or larger. Core subd code assumes TextureImageSuggestedMinimumSize is a power of 2 and &gt;= 512. </p>
</td></tr>
</table>

</div>
</div>
<a id="aef51f2ea460e4edd104e4216bc197f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef51f2ea460e4edd104e4216bc197f5b">&#9670;&nbsp;</a></span>AutomaticMeshToSubDContext</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b">ON_SubD::AutomaticMeshToSubDContext</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b" title="ON_SubD::AutomaticMeshToSubDContext indentifies a context where meshes can automatically be converted...">ON_SubD::AutomaticMeshToSubDContext</a> indentifies a context where meshes can automatically be converted to subds. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aef51f2ea460e4edd104e4216bc197f5bac9f88e098f6fe4e4e112eeb05ccb9671"></a>Unset&#160;</td><td class="fielddoc"><p>summary&gt; Indicates the context has not been initialized. /summary&gt; summary&gt; A mesh in a Rhino 5 3dm file that is a representation of a box mode T-spline. By default, these meshes are automatically converted to subds. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="aef51f2ea460e4edd104e4216bc197f5ba81705f4f7e91e6b42f211b35ff10269f"></a>Rhino5BoxModeTSpline&#160;</td><td class="fielddoc"><p>summary&gt; A mesh in an FBX file that has nonzero values for either preview division levels or render division levels. Some FBX files created by Maya save subdivision objects as meshes with nonzero division level values. By default, FBX division levels are ignored. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="aef51f2ea460e4edd104e4216bc197f5ba4fa22b0ffaacc4a064817da0d307c614"></a>FBXMeshWithDivisionLevels&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a3e50466f1c3768aa762510fcd0fe69e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e50466f1c3768aa762510fcd0fe69e8">&#9670;&nbsp;</a></span>ChainType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SubD::ChainType specifies what edge and vertex tag tests are used when creating edge chains. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3e50466f1c3768aa762510fcd0fe69e8ac9f88e098f6fe4e4e112eeb05ccb9671"></a>Unset&#160;</td><td class="fielddoc"><p>summary&gt; Unset. /summary&gt; summary&gt; All types of edges and vertices can be in the chain. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e50466f1c3768aa762510fcd0fe69e8a3c8a5f42bf19ef0a3bb3cc711b306fe0"></a>MixedTag&#160;</td><td class="fielddoc"><p>summary&gt; Every edge in an edge chain has the same smooth/crease property. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e50466f1c3768aa762510fcd0fe69e8a459e8ddf41da27acf50b4a3dd67f5403"></a>EqualEdgeTag&#160;</td><td class="fielddoc"><p>summary&gt; Every edge in an edge chain has the same smooth/crease edge tag and interior vertices have the corresponding smooth/crease vertex tag. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e50466f1c3768aa762510fcd0fe69e8a2dddc3785878ddb038ef340c32ff6365"></a>EqualEdgeAndVertexTag&#160;</td><td class="fielddoc"><p>summary&gt; Every edge in an edge chain has the same smooth/crease property and every edge has the same number of faces. If the edges have 1 face, then interior vertices have valence = 3. If the edges have 2 faces, then interior vertices have valence = 4. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e50466f1c3768aa762510fcd0fe69e8a026664e24577e394192b2445ff3ada49"></a>EqualEdgeTagAndOrdinary&#160;</td><td class="fielddoc"><p>summary&gt; Every edge in an edge chain has the same smooth/crease edge tag, every edge has the same number of faces, and interior vertices have the corresponding smooth/crease vertex tag. If the edges have 1 face, then interior vertices have valence = 3. If the edges have 2 faces, then interior vertices have valence = 4. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a3e50466f1c3768aa762510fcd0fe69e8a316113003bff84ff40bd586026604e9a"></a>EqualEdgeAndVertexTagAndOrdinary&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a846f70b68ad8e33519d6e1293470e42b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a846f70b68ad8e33519d6e1293470e42b">&#9670;&nbsp;</a></span>NurbsSurfaceType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b">ON_SubD::NurbsSurfaceType</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b" title="ON_SubD::NurbsSurfaceType specifies what type of NURBS surfaces are returned by ON_SubD....">ON_SubD::NurbsSurfaceType</a> specifies what type of NURBS surfaces are returned by <a class="el" href="class_o_n___sub_d.html#ae302078b9174b39d1332120b5c56c74a">ON_SubD.GetSurfaceNurbsFragments()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a846f70b68ad8e33519d6e1293470e42bac9f88e098f6fe4e4e112eeb05ccb9671"></a>Unset&#160;</td><td class="fielddoc"><p>summary&gt; Not a valid type. Used to indicate the type has not been set and to encourage developers to explicitly specify a type. When in doubt, specify <a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42ba3a69b34ce86dacb205936a8094f6c743">NurbsSurfaceType::Large</a>. /summary&gt; summary&gt; Onee NURBS surface will be generated for each SubD quad. N NURBS surfaces will be generated for each SubD N-gon (N = 3, 5 or more). ON_Brepface may cover multiple Near extraordinary vertices, the surfaces may have lots of knots. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a846f70b68ad8e33519d6e1293470e42ba3a69b34ce86dacb205936a8094f6c743"></a>Large&#160;</td><td class="fielddoc"><p>summary&gt; NURBS surfaces will be as large as possible without the addition of extra knots. Near extraordinary vertices, the surfaces may have lots of knots. This option is prefered when a user wants larger NURBS surfaces but not at the cost of addtional NURBS control points. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a846f70b68ad8e33519d6e1293470e42ba87f8a6ab85c9ced3702b4ea641ad4bb5"></a>Medium&#160;</td><td class="fielddoc"><p>summary&gt; NURBS surfaces will not be merged and will have clamped knots. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a846f70b68ad8e33519d6e1293470e42ba2660064e68655415da2628c2ae2f7592"></a>Small&#160;</td><td class="fielddoc"><p>summary&gt; NURBS surfaces will not be merged and will have unclamped uniform knots. This is useful as a starting point for customized merging and modifying continuity at extraordinary vertices. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="a846f70b68ad8e33519d6e1293470e42baed68856c2a7dd273f073f3403ef08934"></a>Unprocessed&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="add35ac1773196f338b2b53e0e5ffdf50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add35ac1773196f338b2b53e0e5ffdf50">&#9670;&nbsp;</a></span>PatchStyle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50">ON_SubD::PatchStyle</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SubD::PatchStyle identifies the style of patch used to fill holes. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="add35ac1773196f338b2b53e0e5ffdf50ac9f88e098f6fe4e4e112eeb05ccb9671"></a>Unset&#160;</td><td class="fielddoc"><p>summary&gt; Not a valid style. This encourages developers to thoughtfully select a patch style and can be used to indicate a UI control is not initialized. /summary&gt; summary&gt; Automatically choose a patch style that will generally create a good looking result. If a hole boundary is not convex, it is triangulated. Otherwise: If a hole has 3 edges, a single triangle face is used. If a hole has 4 edges, a single quad face is used. If a hole has 5 or more edges and an odd number of edges, a triangle fan is used. If a hole has 6 or more edges and an even number of edges, a quad fan is used. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="add35ac1773196f338b2b53e0e5ffdf50a086247a9b57fde6eefee2a0c4752242d"></a>Automatic&#160;</td><td class="fielddoc"><p>summary&gt; A single face is used under all conditions. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="add35ac1773196f338b2b53e0e5ffdf50ae16a58ecfe5f43f85c33c4967cc0f1d2"></a>SingleFace&#160;</td><td class="fielddoc"><p>summary&gt; A triangle fan used under all conditions. The center of the fan is the average of the hole boundary vertex control net points. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="add35ac1773196f338b2b53e0e5ffdf50a18d58fde618e4a30e2dfdc122e693047"></a>TriangleFan&#160;</td><td class="fielddoc"><p>summary&gt; If the hole boundary has an even mumber of edges, a quad fan is used. Otherwise a triangle fan is used. The center of the fan is the average of the hole boundary vertex control net points. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="add35ac1773196f338b2b53e0e5ffdf50ab79b9fa2d98f59af3e135e2745754d31"></a>QuadOrTriangleFan&#160;</td><td class="fielddoc"><p>summary&gt; The hole boundary is triangluated. Typically this style is selected when a boundary not convex and the other styles produce faces with overlapping regions. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="add35ac1773196f338b2b53e0e5ffdf50ac696e04dab021dfe28bfcee5ad4590ce"></a>Triangulated&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="acf1f951df917b01dcf8e01af028c2e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf1f951df917b01dcf8e01af028c2e6e">&#9670;&nbsp;</a></span>SubDFriendlyKnotType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6e">ON_SubD::SubDFriendlyKnotType</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6e" title="ON_SubD::SubDFriendlyKnotType identifies the types of subd friendly NURBS knot vectors....">ON_SubD::SubDFriendlyKnotType</a> identifies the types of subd friendly NURBS knot vectors. SubD friendly NURBS curves and surfacaes are always cubic and nonrational. Any time there is a multiple knot, the 2nd derivative is zero at the corresponding parameter. SubD friendly NURBS curves are either periodic or have zero 2nd derivative at the ends. </p>
<p><br  />
 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acf1f951df917b01dcf8e01af028c2e6eac9f88e098f6fe4e4e112eeb05ccb9671"></a>Unset&#160;</td><td class="fielddoc"><p>summary&gt; Not a valid type. Used to indicate the type has not been set and to encourage developers to explicitly specify a type. /summary&gt; summary&gt; NURBS knot vector is an unclamped uniform cubic knot vector. Every knot interval has the same length. Every knot has multiplicity 1. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="acf1f951df917b01dcf8e01af028c2e6ea1812d32016245e0374a9ad0e0038b465"></a>UnclampedUniform&#160;</td><td class="fielddoc"><p>summary&gt; NURBS knot vector is a clamped uniform cubic knot vector. Every interior knot interval has the same length. End knots have multiplicity 3 and interior knots have multiplicity 1. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="acf1f951df917b01dcf8e01af028c2e6ea4eefc61c5cfe160c18751ab1eb05e191"></a>ClampedUniform&#160;</td><td class="fielddoc"><p>summary&gt; NURBS knot vector is a clamped piecewise uniform cubic knot vector. All nonzero knot intervals have the same length. End knots have multiplicity 3 and interior knots have multiplicity 1 or 3. Interior knots with multiplicity 3 correspond to interior SubD creases. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="acf1f951df917b01dcf8e01af028c2e6ea134a520e90d073f7ee15cef5d381a666"></a>ClampedPiecewiseUniform&#160;</td><td class="fielddoc"><p>summary&gt; NURBS knot vector is not subd friendly. /summary&gt; </p>
</td></tr>
<tr><td class="fieldname"><a id="acf1f951df917b01dcf8e01af028c2e6eab3b0d3e7139cadb1d3336c1465eb1703"></a>Unfriendly&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a669d9987c2605ae8d914ca28a1b6a07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a669d9987c2605ae8d914ca28a1b6a07e">&#9670;&nbsp;</a></span>VertexFacetType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07e">ON_SubD::VertexFacetType</a> : unsigned char</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Summarizes the number of edges in faces in the whole object. </p>
<p>enum class VertexEdgeOrder : unsigned char { unset = 0, radial, ///&lt; The <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> edge and face information satisfies: ///&lt; 1) m_face_count = m_edge_count or m_face_count+1 == m_edge_count ///&lt; 2) m_faces[i] is between m_edges[i] and m_edges[(i+1)m_edge_count] ///&lt; 3) When 0 &lt; i &lt; m_edge_count-1, m_edges[i].m_edge_count = 2 ///&lt; and m_edges[i].m_face2[] references m_faces[i-1] and m_faces[i] ///&lt; in an unspecified order. notradial ///&lt; one of the conditions conditions for radial is not satisfied. }; static ON_SubD::VertexEdgeOrder VertexEdgeOrderFromUnsigned( unsigned int vertex_edge_order_as_unsigned );</p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a669d9987c2605ae8d914ca28a1b6a07eac9f88e098f6fe4e4e112eeb05ccb9671"></a>Unset&#160;</td><td class="fielddoc"><p>summary&gt;Not a valid vertex face type. </p>
<p>summary&gt;All faces are triangular. </p>
</td></tr>
<tr><td class="fieldname"><a id="a669d9987c2605ae8d914ca28a1b6a07eab8c4c2cd6e0f11e2fbb894caeaeccef3"></a>Tri&#160;</td><td class="fielddoc"><p>summary&gt;All faces are quads. </p>
</td></tr>
<tr><td class="fieldname"><a id="a669d9987c2605ae8d914ca28a1b6a07eae9017664588010860a92ceb5f8fcb824"></a>Quad&#160;</td><td class="fielddoc"><p>summary&gt;Edge count of faces is constant and &gt; 4. </p>
</td></tr>
<tr><td class="fieldname"><a id="a669d9987c2605ae8d914ca28a1b6a07ea4371d32113ff78b6d6ed2da59b10b2f5"></a>Ngon&#160;</td><td class="fielddoc"><p>summary&gt;Edge count of faces is not constant. </p>
</td></tr>
<tr><td class="fieldname"><a id="a669d9987c2605ae8d914ca28a1b6a07ea699b4f79215d191584653efebf156e52"></a>Mixed&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a688da634c4a1257feaddf867a73c1c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688da634c4a1257feaddf867a73c1c70">&#9670;&nbsp;</a></span>ON_SubD() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubD::ON_SubD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ddde20f234ae734078c8ad54a26374b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddde20f234ae734078c8ad54a26374b">&#9670;&nbsp;</a></span>~ON_SubD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ON_SubD::~ON_SubD </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a32fe9c0950281d076c018669942012b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fe9c0950281d076c018669942012b3">&#9670;&nbsp;</a></span>ON_SubD() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ON_SubD::ON_SubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Creates an independent copy of src. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afaf6fb833f43db460ba7a7da6bd8ef24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf6fb833f43db460ba7a7da6bd8ef24">&#9670;&nbsp;</a></span>ActiveLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class ON_SubDLevel&amp; ON_SubD::ActiveLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30361600ed58615c9624775665468692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30361600ed58615c9624775665468692">&#9670;&nbsp;</a></span>ActiveLevelIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ActiveLevelIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: If the SubD is not empty, then the index of the active level is returned. This value will be &lt; <a class="el" href="class_o_n___sub_d.html#a2a4d589a902cc1c69148aaa20ff14615">LevelCount()</a>. If the SubD is empty, then ON_UNSET_UINT_INDEX is returned. </p>

</div>
</div>
<a id="a4ad615fb238dd50d7777a59f669616d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad615fb238dd50d7777a59f669616d8">&#9670;&nbsp;</a></span>AddEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::AddEdge </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add an edge with tag = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a> to the subd. Parameters: v0 - [in] v1 - [in] The edge begins at v0 and ends at v1. The edge will be on the same level as the vertices. Returns: Pointer to the allocated edge. Remarks: <a class="el" href="class_o_n___sub_d.html#afd53a99331439ace74c0ac49b3918a86">ON_SubD::EdgeTagFromContext()</a> can be used to determine edge tag values in simple situations. </p>

</div>
</div>
<a id="a7dac9465bdfefec1c5d6411c7362c536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dac9465bdfefec1c5d6411c7362c536">&#9670;&nbsp;</a></span>AddEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::AddEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add an edge to the subd. Parameters: edge_tag - [in] <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a> Edge tag is not known at this time. <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> Smooth edge. If both vertices are tagged as not smooth, the tag on the returned edge will be <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a>. This tag is changed to <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> on the first subdivision step. <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>. Crease edge. Both vertices must be tagged as not smooth. v0 - [in] v1 - [in] The edge begins at v0 and ends at v1. The edge will be on the same level as the vertices. Returns: Pointer to the allocated edge. Remarks: <a class="el" href="class_o_n___sub_d.html#afd53a99331439ace74c0ac49b3918a86">ON_SubD::EdgeTagFromContext()</a> can be used to determine edge tag values in simple situations. </p>

</div>
</div>
<a id="a2f1632fe118521690d210566212b2285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1632fe118521690d210566212b2285">&#9670;&nbsp;</a></span>AddEdgeForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::AddEdgeForExperts </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>candidate_edge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0_sector_coefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1_sector_coefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>initial_face_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to add an edge with specified information. This function is useful when copying portions of an existing SubD to a new SubD. Parameters: candidate_edge_id - [in] If candidate_edge_id is &gt; 0 and is available, the returned edge with have id = candidate_edge_id. Otherwise a new id will be assigned. edge_tag - [in] Pass <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a> if not known. v0 - [in] The edge begins at v0 and ends at v1. v0_sector_coefficient - [in] Pass <a class="el" href="class_o_n___sub_d_sector_type.html#a95adb9f9e356893850b3cb5dc7b3b5e6" title="= -8883.0;">ON_SubDSectorType::UnsetSectorCoefficient</a> if unknown. v1 - [in] The edge begins at v0 and ends at v1. v1_sector_coefficient - [in] Pass <a class="el" href="class_o_n___sub_d_sector_type.html#a95adb9f9e356893850b3cb5dc7b3b5e6" title="= -8883.0;">ON_SubDSectorType::UnsetSectorCoefficient</a> if unknown. initial_face_capacity - [in] Initial face capacity. Pass 0 if unknown. </p>

</div>
</div>
<a id="a0c10c401b54f35fa62be73d7b0062e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c10c401b54f35fa62be73d7b0062e89">&#9670;&nbsp;</a></span>AddEdgeWithSectorCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::AddEdgeWithSectorCoefficients </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v0_sector_coefficient</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>v1_sector_coefficient</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert use tool to add an edge with precomputed sector coefficients. Parameters: edge_tag - [in] This expert user function does not automatically set the edge tag. v0 - [in] The edge begins at v0 and ends at v1. v0_sector_coefficient - [in] Pass <a class="el" href="class_o_n___sub_d_sector_type.html#a95adb9f9e356893850b3cb5dc7b3b5e6" title="= -8883.0;">ON_SubDSectorType::UnsetSectorCoefficient</a> if unknown. v1 - [in] The edge begins at v0 and ends at v1. v1_sector_coefficient - [in] Pass <a class="el" href="class_o_n___sub_d_sector_type.html#a95adb9f9e356893850b3cb5dc7b3b5e6" title="= -8883.0;">ON_SubDSectorType::UnsetSectorCoefficient</a> if unknown. </p>

</div>
</div>
<a id="a3b3a6a44a0aeebf7592c4a28cb094306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3a6a44a0aeebf7592c4a28cb094306">&#9670;&nbsp;</a></span>AddFace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::AddFace </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge_count - [in] Must be &gt;= 3. edges[] - [in] edges[i] and edges[(i+1)edge_count] must have a single common vertex. The face will be oriented so the boundary has the edges in the order (edges[0], edges[1], ..., edges[edge_count-1]). The orientations of the <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> elements in the face's edge list are automatically calculated. Returns: A pointer to the added face. The returned face is managed by the subd. </p>

</div>
</div>
<a id="a311fc42a57d47419e86ad66b869ef783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311fc42a57d47419e86ad66b869ef783">&#9670;&nbsp;</a></span>AddFace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::AddFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge_count - [in] Must be &gt;= 3. edges[] - [in] The <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> parameters must be oriented so that edges[i].RelativeVertex(1) and edges[(i+1)edge_count].RelativeVertex(0) are the same vertex. The face will be oriented so the boundary has the edges in the order (edges[0], edges[1], ..., edges[edge_count-1]). Returns: A pointer to the added face. The returned face is managed by the subd. </p>

</div>
</div>
<a id="a34671d71cc51ac676e42eba10322c118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34671d71cc51ac676e42eba10322c118">&#9670;&nbsp;</a></span>AddFace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::AddFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edges[] - [in] edges[] must have 3 or more elements. edges[i] and edges[(i+1)edge_count] must have a single common vertex. The face will be oriented so the boundary has the edges in the order (edges[0], edges[1], ..., edges[edge_count-1]). The orientations of the <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> elements in the face's edge list are automatically calculated. Returns: A pointer to the added face. The returned face is managed by the subd. </p>

</div>
</div>
<a id="a20e811779cd172ba23845434449f2e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20e811779cd172ba23845434449f2e50">&#9670;&nbsp;</a></span>AddFace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::AddFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edges[] - [in] edges[] must have 3 or more elements. The <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> parameters must be oriented so that edges[i].RelativeVertex(1) and edges[(i+1)edge_count].RelativeVertex(0) are the same vertex. The face will be oriented so the boundary has the edges in the order (edges[0], edges[1], ..., edges[edge_count-1]). Returns: A pointer to the added face. The returned face is managed by the subd. </p>

</div>
</div>
<a id="ab1f72e04db5bdc9c19f2d57aa1a0b644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1f72e04db5bdc9c19f2d57aa1a0b644">&#9670;&nbsp;</a></span>AddFaceEdgeConnection() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::AddFaceEdgeConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ON__UINT_PTR&#160;</td>
          <td class="paramname"><em>edge_direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to insert an edge in the face's edge array. Parameters: face - [in] edge - [in] edge_direction -[in] i - [in] index where the edge should be inserted. Returns: true if successful. Remarks: This tool is used during construction or editing of a SubD and the connection is added even if the result is an invalid face or edge. It is up to the expert user to make enough changes to create a valid SubD. </p>

</div>
</div>
<a id="a1501eb3bce73a47f548ade5cc989ef27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1501eb3bce73a47f548ade5cc989ef27">&#9670;&nbsp;</a></span>AddFaceEdgeConnection() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::AddFaceEdgeConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>eptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to insert an edge in the face's edge array. Parameters: face - [in] eptr - [in] direction must be set correctly i - [in] index where the edge should be inserted. Returns: true if successful. Remarks: This tool is used during construction or editing of a SubD and the connection is added even if the result is an invalid face or edge. It is up to the expert user to make enough changes to create a valid SubD. </p>

</div>
</div>
<a id="a98fef592fc10f2a92b6080e68460770b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98fef592fc10f2a92b6080e68460770b">&#9670;&nbsp;</a></span>AddFaceEdgeConnection() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::AddFaceEdgeConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>eptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAddbAddFaceToRelativeVertex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAddbAddFaceToRelativeVertex1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to insert an edge in the face's edge array. Parameters: face - [in] i - [in] index where the edge should be inserted. eptr - [in] direction must be set correctly bAddFaceToRelativeVertex0 - [in] If true, face is appended to the eptr.RelativeVertex(0)'s face array. bAddFaceToRelativeVertex1 - [in] If true, face is appended to the eptr.RelativeVertex(0)'s face array. Returns: true if successful. Remarks: This tool is used during construction or editing of a SubD and the connection is added even if the result is an invalid face or edge. It is up to the expert user to make enough changes to create a valid SubD. </p>

</div>
</div>
<a id="a8e6f050e9af542a171a6112a5b5069db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6f050e9af542a171a6112a5b5069db">&#9670;&nbsp;</a></span>AddFaceForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::AddFaceForExperts </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>candidate_face_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: candidate_face_id - [in] If candidate_face_id is &gt; 0 and is available, the returned face with have id = candidate_face_id. Otherwise a new id will be assigned. edge[] - [in] The edge[] array must be sorted and correct oriented (edge[i].RelativeVertex(1) == edge[(i+1)edge_count].RelativeVertex(0)). edge_count - [in] Must be &gt;= 3. </p>

</div>
</div>
<a id="a410c91d323081284b1b65be824ddbd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410c91d323081284b1b65be824ddbd42">&#9670;&nbsp;</a></span>AddFaceTexturePoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::AddFaceTexturePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *&#160;</td>
          <td class="paramname"><em>texture_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>texture_points_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add texture points to a face. Parameters: texture_points - [in] An array of face-&gt;<a class="el" href="class_o_n___sub_d.html#ae5da40c3ae92bcbc1c0c9aac31a3d1dc">EdgeCount()</a> points. texture_points_count - [in] number of elements in texture_points[]. Must be &gt;= face-&gt;<a class="el" href="class_o_n___sub_d.html#ae5da40c3ae92bcbc1c0c9aac31a3d1dc">EdgeCount()</a>. Returns: True if texture points were set. Remarks: This function automatically handles the management of face texture point storage. Texture points are a mutable property on <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>. </p>

</div>
</div>
<a id="acbe732ecfb19ee77ac3214a13a86d64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe732ecfb19ee77ac3214a13a86d64b">&#9670;&nbsp;</a></span>AddQuadFace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::AddQuadFace </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge0 - [in] edge1 - [in] edge2 - [in] edge3 - [in] The face will be oriented so the boundary has the edges in the order (edge0, edge1, edge2. edge3). Consecutive edges must have a single common vertex. The orientations of the <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> elements in the face's edge list are automatically calculated. Returns: A pointer to the added face. The returned face is managed by the subd. </p>

</div>
</div>
<a id="aa38f61503e500f28e109f8b40d767fc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38f61503e500f28e109f8b40d767fc8">&#9670;&nbsp;</a></span>AddQuadFace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::AddQuadFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge_count - [in] Must be &gt;= 3. edge0 - [in] edge1 - [in] edge2 - [in] edge3 - [in] The <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> parameters must be oriented so that for consecutive pairs of edges, edge0.RelativeVertex(1) and edges1.RelativeVertex(0) are same vertex. The face will be oriented so the boundary has the edges in the order (edge0, edge1, edge2,edge3). Returns: A pointer to the added face. The returned face is managed by the subd. </p>

</div>
</div>
<a id="a83083a407f9ca2ba5e9388a5b4a99139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83083a407f9ca2ba5e9388a5b4a99139">&#9670;&nbsp;</a></span>AddSymmetrySetsToComponentList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ON_SubD::AddSymmetrySetsToComponentList </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAddVertexSymmetrySets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAddEdgeSymmetrySets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAddFaceSymmetrySets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If this SubD is symmetric (this-&gt;<a class="el" href="class_o_n___sub_d.html#afda5bb6a04c93f681cf672ca9208abc4">ContentIsSymmetric()</a> is true), and a component is referenced in the input component_list[], then every element in that component's symmetry set will be in the returned component_list[]. component_list - [in/out] Returns: Number of components added to component_list[]. </p>

</div>
</div>
<a id="a71e727fba565a6a529561834d13dfa67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e727fba565a6a529561834d13dfa67">&#9670;&nbsp;</a></span>AddSymmetrySetsToComponentList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ON_SubD::AddSymmetrySetsToComponentList </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAddVertexSymmetrySets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAddEdgeSymmetrySets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAddFaceSymmetrySets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If this SubD is symmetric (this-&gt;<a class="el" href="class_o_n___sub_d.html#afda5bb6a04c93f681cf672ca9208abc4">ContentIsSymmetric()</a> is true), and a component is referenced in the input component_list[], then every element in that component's symmetry set will be in the returned component_list[]. component_list - [in/out] Returns: Number of components added to component_list[]. </p>

</div>
</div>
<a id="a69e4995fa0ffcb9e2490a3e4d848e6da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69e4995fa0ffcb9e2490a3e4d848e6da">&#9670;&nbsp;</a></span>AddTriangleFace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::AddTriangleFace </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge0 - [in] edge1 - [in] edge2 - [in] The face will be oriented so the boundary has the edges in the order (edge0, edge1, edge2). Consecutive edges must have a single common vertex. The orientations of the <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> elements in the face's edge list are automatically calculated. Returns: A pointer to the added face. The returned face is managed by the subd. </p>

</div>
</div>
<a id="ad1e1026f4ebbafb1424178d6106ada59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1e1026f4ebbafb1424178d6106ada59">&#9670;&nbsp;</a></span>AddTriangleFace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::AddTriangleFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge_count - [in] Must be &gt;= 3. edge0 - [in] edge1 - [in] edge2 - [in] The <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> parameters must be oriented so that for consecutive pairs of edges, edge0.RelativeVertex(1) and edges1.RelativeVertex(0) are same vertex. The face will be oriented so the boundary has the edges in the order (edge0, edge1, edge2). Returns: A pointer to the added face. The returned face is managed by the subd. </p>

</div>
</div>
<a id="ad2800bf03755d17eaa868c1a77766aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2800bf03755d17eaa868c1a77766aec">&#9670;&nbsp;</a></span>AddVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::AddVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *&#160;</td>
          <td class="paramname"><em>P</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Adds a vertex with tag = <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDVertexTag::Unset</a>. </p>

</div>
</div>
<a id="a4e376f017ca46acd583b105fc4172e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e376f017ca46acd583b105fc4172e5a">&#9670;&nbsp;</a></span>AddVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::AddVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Adds a vertex with specified tag. </p>

</div>
</div>
<a id="afcb65dfb0da98c2f5a42c92e107725f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb65dfb0da98c2f5a42c92e107725f8">&#9670;&nbsp;</a></span>AddVertexForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::AddVertexForExperts </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>candidate_vertex_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *&#160;</td>
          <td class="paramname"><em>P</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>initial_edge_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>initial_face_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to add a vertex with specified information. This function is useful when copying portions of an existing SubD to a new SubD. Parameters: candidate_vertex_id - [in] If candidate_vertex_id is &gt; 0 and is available, the returned value with have id = candidate_vertex_id. Otherwise a new id will be assigned. vertex_tag - [in] Pass <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDVertexTag::Unset</a> if not known. P - [in] nullptr or a 3d point. initial_edge_capacity - [in] Initial capacity of the m_edges[] array. Pass 0 if unknown. initial_face_capacity - [in] Initial capacity of the m_faces[] array. Pass 0 if unknown. </p>

</div>
</div>
<a id="a811e33d12d90d557f0d435aa3da99d39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a811e33d12d90d557f0d435aa3da99d39">&#9670;&nbsp;</a></span>AggregateComponentStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___aggregate_component_status.html">ON_AggregateComponentStatus</a> ON_SubD::AggregateComponentStatus </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a8a1cfab63437a2d03cc50fdc6734f2a5">ON_Object</a>.</p>

</div>
</div>
<a id="a36ccae911c49f201733d34dc379ed07b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ccae911c49f201733d34dc379ed07b">&#9670;&nbsp;</a></span>AggregateEdgeAttributes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::AggregateEdgeAttributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get aggregate edge demographics for the subd. Returns: Bitwise or of <a class="el" href="class_o_n___component_attributes.html#a2d29d48bc4024598cba93dc7903abd8a">ON_ComponentAttributes::EdgeAttributes</a> values for every edge in the subd. </p>

</div>
</div>
<a id="a29d5a5be12479684e104c73dd22c2fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d5a5be12479684e104c73dd22c2fd2">&#9670;&nbsp;</a></span>AllocateFaceTexturePoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::AllocateFaceTexturePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Add texture point storage capacity to a face. Parameters: face - [in] The ability to store at least face-&gt;<a class="el" href="class_o_n___sub_d.html#ae5da40c3ae92bcbc1c0c9aac31a3d1dc">EdgeCount()</a> texture points will be added to this face. Returns: Number of texture points that can be set (&gt;= face-&gt;<a class="el" href="class_o_n___sub_d.html#ae5da40c3ae92bcbc1c0c9aac31a3d1dc">EdgeCount()</a>). </p>

</div>
</div>
<a id="a881917f73d7881ff87251bfda8fab370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881917f73d7881ff87251bfda8fab370">&#9670;&nbsp;</a></span>Append() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::Append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>prefered_merged_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeAllCoincidentVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkMergedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkAddedComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Appends a copy of subd to this and updates Coincident vertices and edges are merged.</p>
<p>Parameters: subd - [in] SubD to append to this.</p>
<p>tolerance - [in] When in doubt, pass 0. Distance tolerance used to consider which vertices in to merge.</p>
<p>prefered_merged_edge_tag - [in] This parameter controls what edge tag is assigned when two boundary edges are merged into a single interior edge. In this case the default is smooth but can be overridden by setting prefered_merged_edge_tag to <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>.</p>
<p>bMergeAllCoincidentVertices - [in] When in doubt, pass false. If true, all coincident vertices will be merged. If false, only conincident corner vertices and conindident crease edges with at most one face will be merged.</p>
<p>bMarkMergedComponents - [in] If true, then merged components have RuntimeMark() set to true. <br  />
</p>
<p>bMarkAddedComponents - [in] If true, then added components have RuntimeMark() set to true. <br  />
</p>
<p>Returns: Number of components (vertices, edges, and faces) added to this.</p>
<p>Remarks: Existing compenent marks on this are erased. Then bMarkMergedComponents and bMarkAddedComponents determine which components get marked. </p>

</div>
</div>
<a id="a7f23c088a5a14856941571291cad8a94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f23c088a5a14856941571291cad8a94">&#9670;&nbsp;</a></span>Append() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::Append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>prefered_merged_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeAllCoincidentVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkMergedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkAddedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermitDisjointAppend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>merge_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Appends a copy of subd to this and updates Coincident vertices and edges are merged.</p>
<p>Parameters: subd - [in] SubD to append to this.</p>
<p>tolerance - [in] When in doubt, pass 0. Distance tolerance used to consider which vertices in to merge.</p>
<p>prefered_merged_edge_tag - [in] This parameter controls what edge tag is assigned when two boundary edges are merged into a single interior edge. In this case the default is smooth but can be overridden by setting prefered_merged_edge_tag to <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>.</p>
<p>bMergeAllCoincidentVertices - [in] When in doubt, pass false. If true, all coincident vertices will be merged. If false, only conincident corner vertices and conindident crease edges with at most one face will be merged.</p>
<p>bMarkMergedComponents - [in] If true, then merged components have RuntimeMark() set to true.</p>
<p>bMarkAddedComponents - [in] If true, then added components have RuntimeMark() set to true.</p>
<p>bPermitDisjointAppend - [in] If true, subd is always appended. If false, subd is appended only when there are vertices that can be merged.</p>
<p>merge_map - [out] If not nullptr, merge_map[] is a list of (vertex in this,vertex from subd) pairs.</p>
<p>Returns: Number of components (vertices, edges, and faces) added to this.</p>
<p>Remarks: Existing compenent marks on this are erased. Then bMarkMergedComponents and bMarkAddedComponents determine which components get marked. </p>

</div>
</div>
<a id="a384f9d7e6ec6cf11df503eea0ad0a96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384f9d7e6ec6cf11df503eea0ad0a96c">&#9670;&nbsp;</a></span>Append() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::Append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>prefered_merged_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeAllCoincidentVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;&#160;</td>
          <td class="paramname"><em>this_vertex_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;&#160;</td>
          <td class="paramname"><em>subd_vertex_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkMergedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkAddedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermitDisjointAppend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>merge_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Appends a copy of subd to this and updates Coincident vertices and edges are merged.</p>
<p>Parameters: subd - [in] SubD to append to this.</p>
<p>tolerance - [in] When in doubt, pass 0. Distance tolerance used to consider which vertices in to merge.</p>
<p>prefered_merged_edge_tag - [in] This parameter controls what edge tag is assigned when two boundary edges are merged into a single interior edge. In this case the default is smooth but can be overridden by setting prefered_merged_edge_tag to <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>.</p>
<p>bMergeAllCoincidentVertices - [in] When in doubt, pass false. If true, all coincident vertices will be merged. If false, only conincident corner vertices and conindident crease edges with at most one face will be merged.</p>
<p>this_vertex_filter - [in] When in doubt, pass <a class="el" href="class_o_n___sub_d_component_test.html#aacd3d7da4624138beaac845f99100899" title="Passes() returns true for every non nullptr component.">ON_SubDComponentTest::AllPass</a>. If this_vertex_filter::Passes(v)==false for a vertex in this, then v will not be merged with any vertex from subd.</p>
<p>subd_vertex_filter - [in] When in doubt, pass ON_SubDComponentTester::AllPass. If subd_vertex_filter::Passes(v)==false for a vertex in subd, then v will not be merged with any vertex from this.</p>
<p>bMarkMergedComponents - [in] If true, then merged components have RuntimeMark() set to true.</p>
<p>bMarkAddedComponents - [in] If true, then added components have RuntimeMark() set to true.</p>
<p>bPermitDisjointAppend - [in] If true, subd is always appended. If false, subd is appended only when there are vertices that can be merged.</p>
<p>merge_map - [out] If not nullptr, merge_map[] is a list of (vertex in this,vertex from subd) pairs.</p>
<p>Returns: Number of components (vertices, edges, and faces) added to this.</p>
<p>Remarks: Existing compenent marks on this are erased. Then bMarkMergedComponents and bMarkAddedComponents determine which components get marked. </p>

</div>
</div>
<a id="ad0f0c261911cf32f4810d062eab06b0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f0c261911cf32f4810d062eab06b0d">&#9670;&nbsp;</a></span>AppendDisjoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::AppendDisjoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>disjoint_subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkOriginalComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkAddedComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Appends a copy of disjoint_subd to this. No conincidence checking or merging is performed.</p>
<p>Parameters: disjoint_subd - [in] SubD to append to this.</p>
<p>bMarkAddedComponents - [in] If true, then added components have RuntimeMark() set to true. <br  />
</p>
<p>bMarkOriginalComponents - [in] If true, then the original components have RuntimeMark() set to true. <br  />
</p>
<p>Returns: Number of components (vertices, edges, and faces) added to this.</p>
<p>Remarks: Existing compenent marks on this are erased. Then bMarkMergedComponents and bMarkAddedComponents determine which components get marked. </p>

</div>
</div>
<a id="a3be19cb4701a0dc494f4867f902c9c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be19cb4701a0dc494f4867f902c9c18">&#9670;&nbsp;</a></span>AppendDisjoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::AppendDisjoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>disjoint_subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkOriginalComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkAddedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>merge_map</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe601ddd0b4a9c188da6f26b369cee09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe601ddd0b4a9c188da6f26b369cee09">&#9670;&nbsp;</a></span>AutoBridge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::AutoBridge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>bridge_boundary_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>start_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>end_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkNewFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Automatically add a collection of faces that patches a hole. Parameters: bridge_boundary_edge_tag - [in] If <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>, the bridge boundary edges will be creased whenever possible. Otherwise, the patch boundary edges will be smooth whenever possible. <br  />
 edge_count - [in] Number of edges in the start_edges[] and end_edges[] arrays. start_edges - [in] end_edges - [in] bMarkNewFaces - [in] If true, new faces have their runtime mark set to true. Otherwise new faces are not marked. In all cases, the runtime marks of input faces are not changed. Returns: The number of added faces. </p>

</div>
</div>
<a id="aba867f3b66fc1f1953e7c21d3f933133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba867f3b66fc1f1953e7c21d3f933133">&#9670;&nbsp;</a></span>AutoBridge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::AutoBridge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>bridge_boundary_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>start_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>end_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkNewFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3dda37cd9bafdc77b338bcc63936fc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dda37cd9bafdc77b338bcc63936fc4e">&#9670;&nbsp;</a></span>AutomaticMeshToSubD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::AutomaticMeshToSubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b">ON_SubD::AutomaticMeshToSubDContext</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: true if SubDs are automatically created when an <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> is found in the specified context. false otherwise. </p>

</div>
</div>
<a id="a3ab5a32a6648e36623f825e65974554e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ab5a32a6648e36623f825e65974554e">&#9670;&nbsp;</a></span>AutomaticMeshToSubDRestoreDefaults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ON_SubD::AutomaticMeshToSubDRestoreDefaults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b">ON_SubD::AutomaticMeshToSubDContext</a>&#160;</td>
          <td class="paramname"><em>context</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: context - [in] If context is <a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5bac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubD::AutomaticMeshToSubDContext::Unset</a>, all defaults will be restored. Otherwise, the default for the specific context will be restored. </p>

</div>
</div>
<a id="a68bc8d532412456d1660621b23853765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bc8d532412456d1660621b23853765">&#9670;&nbsp;</a></span>AutoMultiPatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::AutoMultiPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50">ON_SubD::PatchStyle</a>&#160;</td>
          <td class="paramname"><em>patch_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>patch_boundary_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkNewFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Automatically add a collection of faces that patches a hole. Parameters: patch_style - [in] patch_boundary_edge_tag - [in] If <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>, the patch boundary edges will be creased whenever possible. Otherwise, the patch boundary edges will be smooth whenever possible. <br  />
 unsorted_edges[] - [in] An unsorted collection of edges that will be used to generate patch boundaries. bMarkNewFaces - [in] If true, new faces have their runtime mark set to true. Otherwise new faces are not marked. In all cases, the runtime marks of input faces are not changed. Returns: Number of patches added. </p>

</div>
</div>
<a id="a3240150bfa23a5ee6009c853f87a8dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3240150bfa23a5ee6009c853f87a8dcf">&#9670;&nbsp;</a></span>AutoMultiPatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::AutoMultiPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50">ON_SubD::PatchStyle</a>&#160;</td>
          <td class="paramname"><em>patch_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>patch_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkNewFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad9e7c02ef85f24b041f3b6c9b572f520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e7c02ef85f24b041f3b6c9b572f520">&#9670;&nbsp;</a></span>AutoPatch()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> ON_SubD::AutoPatch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#add35ac1773196f338b2b53e0e5ffdf50">ON_SubD::PatchStyle</a>&#160;</td>
          <td class="paramname"><em>patch_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>patch_boundary_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkNewFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Automatically add a collection of faces that patches a hole. Parameters: patch_style - [in] patch_boundary_edge_tag - [in] If <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>, the patch boundary edges will be creased whenever possible. Otherwise, the patch boundary edges will be smooth whenever possible. <br  />
 edges[] - [in] A closed loop of edges that wil become the patch boundary. bMarkNewFaces - [in] If true, new faces have their runtime mark set to true. Otherwise new faces are not marked. In all cases, the runtime marks of input faces are not changed. Returns: If the patch is a single face, the face is returned. If the patch is a ring of quads or triangles around a central vertex, the central vertex is returned. If the patch is a set of faces in some other configuration, a face from that set is returned. If no patch was added, <a class="el" href="class_o_n___sub_d_component_ptr.html#ae0309416fca150bc9e9b1569b9e4d493" title="// nullptr, type = unset, mark = 0">ON_SubDComponentPtr::Null</a> is returned. </p>

</div>
</div>
<a id="afd25483350c3704ec0cce3451ee055c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd25483350c3704ec0cce3451ee055c6">&#9670;&nbsp;</a></span>BrepForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___brep.html">ON_Brep</a>* ON_SubD::BrepForm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td>
          <td class="paramname"><em>brep</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>
<p>Returns: GetSurfaceBrep( ON_SubDToBrepParameters::Default, nullptr ); </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#aeb8d6122b6285e4ab819fa50bd442c23">ON_Geometry</a>.</p>

</div>
</div>
<a id="ae31e75e9f0cbdd8c55e725a30e36de20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31e75e9f0cbdd8c55e725a30e36de20">&#9670;&nbsp;</a></span>ChangeGeometryContentSerialNumberForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a> ON_SubD::ChangeGeometryContentSerialNumberForExperts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bChangePreservesSymmetry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Change the geoemtry content serial number to indicate something affecting the geometric shape of the subd has changed. This includes topologial changes, vertex and edge tag changes, and changes to vertex control net locations. Parameters: bChangePreservesSymmetry - [in] When in doubt, pass false. If the change preserves global symmtery, then pass true. (For example, a global subdivide preserves all types of symmetry.) Note well: Transformations do not preserve symmetries that are set with respect to world coordinate systems. Returns: The new value of GeometryConentSerialNumber(). Remarks: The value can change by any amount. Changing the geometry content serial number automatically changes the render content serial number. </p>

</div>
</div>
<a id="a18c62a3f7eacb09e487ef7215a13633a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c62a3f7eacb09e487ef7215a13633a">&#9670;&nbsp;</a></span>ChangeRenderContentSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a> ON_SubD::ChangeRenderContentSerialNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Change the render content serial number to indicate something affecting only rendered appearance has changed. This includes changes to per face colors, per face materials, texture coordinates, and texture mappings. Remarks: Changing the geometry content serial number automatically changes the render content serial number. If you call <a class="el" href="class_o_n___sub_d.html#ae31e75e9f0cbdd8c55e725a30e36de20">ChangeGeometryContentSerialNumberForExperts()</a>, there is no need to also call <a class="el" href="class_o_n___sub_d.html#a18c62a3f7eacb09e487ef7215a13633a">ChangeRenderContentSerialNumber()</a>. </p>

</div>
</div>
<a id="a0dcb94e4ee32e9e8e9820d7801f50e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dcb94e4ee32e9e8e9820d7801f50e29">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Discard all contents of this <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. Remarks: More efficient than <a class="el" href="class_o_n___sub_d.html#a5f8074d561bee1dc38fcef3cb2e8b19b">Destroy()</a> if this <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> will be reused soon. </p>

</div>
</div>
<a id="a44bdc135bc3376821f925f14a36d2680"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bdc135bc3376821f925f14a36d2680">&#9670;&nbsp;</a></span>ClearBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ClearBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>
<p>Description: Clears all saved information that depends on vertex locations, subdivision algorithms, vertex or edge tags, or control net topology. <br  />
 If you modify any of the above, then call <a class="el" href="class_o_n___sub_d.html#a44bdc135bc3376821f925f14a36d2680" title="virtual">ClearBoundingBox()</a>. Remarks: For <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> objects, <a class="el" href="class_o_n___sub_d.html#a44bdc135bc3376821f925f14a36d2680" title="virtual">ClearBoundingBox()</a> and <a class="el" href="class_o_n___sub_d.html#a2cc3756ee7209297f559f4f48d82ccbe" title="virtual">DestroyRuntimeCache()</a> are identical. </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#af8dfbd8534986bbd327a6ad812e374be">ON_Geometry</a>.</p>

</div>
</div>
<a id="a610db54c408232cad99e9959c6090f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a610db54c408232cad99e9959c6090f79">&#9670;&nbsp;</a></span>ClearComponentGroupIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearComponentGroupIds </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearVertexGroupIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearEdgeGroupIds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearFaceGroupIds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_group_id value to 0 for the specified components. Parameters: bClearVertexGroupIds - [in] If true, m_group_id for every vertex is set to zero. bClearEdgeGroupIds - [in] If true, m_group_id for every edge is set to zero. bClearFaceGroupIds - [in] If true, m_group_id for every face is set to zero. Returns: Number of group id values that were changed. </p>

</div>
</div>
<a id="a7ab564d777e645245960c4dbad816208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ab564d777e645245960c4dbad816208">&#9670;&nbsp;</a></span>ClearComponentMarkBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearComponentMarkBits </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearVertexMarkBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearEdgeMarkBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearFaceMarkBits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_status.MarkBits() value to 0 for the specified components. Parameters: bClearVertexMarkBits - [in] If true, m_status.MarkBits() for every vertex is set to zero. bClearEdgeMarkBits - [in] If true, m_status.MarkBits() for every edge is set to zero. bClearFaceMarkBits - [in] If true, m_status.MarkBits() for every face is set to zero. Returns: Number of group id values that were changed. </p>

</div>
</div>
<a id="aad8a137f38839d415a98c6306b1e39bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad8a137f38839d415a98c6306b1e39bc">&#9670;&nbsp;</a></span>ClearComponentMarks() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearComponentMarks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Clears the m_status.RuntimeMark() for every vertex, edge and face. Returns: Number of marks that were cleared. </p>

</div>
</div>
<a id="afa2434435be3a0eca6e1e51a986b9d4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2434435be3a0eca6e1e51a986b9d4a">&#9670;&nbsp;</a></span>ClearComponentMarks() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearComponentMarks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearVertexMarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearEdgeMarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearFaceMarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; *&#160;</td>
          <td class="paramname"><em>marked_component_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Selectively clear m_status.RuntimeMark() Parameters: bClearVertexMarks - [in] If true, m_status.ClearRuntimeMark() is called for every vertex. bClearEdgeMarks - [in] If true, m_status.ClearRuntimeMark() is called for every edge. bClearFaceMarks - [in] If true, m_status.ClearRuntimeMark() is called for every face. marked_component_list - [out] If not nullptr, then pointer to components that were marked are returned in this marked_component_list[] Returns: Number of marks that were cleared. </p>

</div>
</div>
<a id="ad1954538284e3331fd83a1012a284398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1954538284e3331fd83a1012a284398">&#9670;&nbsp;</a></span>ClearComponentStates() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearComponentStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>component_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>states_to_clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#aeadf76a46f3f1a661bbf41e1b754fe89">ON_Object</a>.</p>

</div>
</div>
<a id="aef1c99fc75feba4249117256e6ba24ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1c99fc75feba4249117256e6ba24ca">&#9670;&nbsp;</a></span>ClearComponentStates() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearComponentStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>states_to_clear</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a1af75ebe418edff4a11985f8fca7d83b">ON_Object</a>.</p>

</div>
</div>
<a id="a7d2c50a7e3006488c4f1400e728cd5c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d2c50a7e3006488c4f1400e728cd5c0">&#9670;&nbsp;</a></span>ClearComponentStates() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearComponentStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>component_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>states_to_clear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Clear states on an individual component. Parameters: component_ptr - [in] The states will be cleared on this component. states_to_clear - [in] If a state is set in the states_to_clear parameter, the same state will be cleared on the component. <br  />
 Returns: 0: no state settings changed on the component. 1: some state setting changed on the component. </p>

</div>
</div>
<a id="a798bbf724f95bcc7d5d0dc10d8525d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798bbf724f95bcc7d5d0dc10d8525d0f">&#9670;&nbsp;</a></span>ClearControlNetComponentTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* * void ON_SubD::ClearControlNetComponentTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c2403537aa954dc6c09a750959cc6e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c2403537aa954dc6c09a750959cc6e7">&#9670;&nbsp;</a></span>ClearEdgeGroupIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearEdgeGroupIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_group_id value to 0 for every edge. Returns: Number of group id values that were changed. </p>

</div>
</div>
<a id="a7e9f4432b4391c046bda3e86db1fe232"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9f4432b4391c046bda3e86db1fe232">&#9670;&nbsp;</a></span>ClearEdgeMarkBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearEdgeMarkBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_status.MarkBits() value to 0 for every edge. Returns: Number of group id values that were changed. </p>

</div>
</div>
<a id="a67aa038ebc116d7b951d8ead490f61b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67aa038ebc116d7b951d8ead490f61b9">&#9670;&nbsp;</a></span>ClearEdgeMarks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearEdgeMarks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Clears the m_status.RuntimeMark() for every edge. Returns: Number of marks that were cleared. </p>

</div>
</div>
<a id="a5e1cd072b07905979be7f0fc453b11cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1cd072b07905979be7f0fc453b11cc">&#9670;&nbsp;</a></span>ClearEvaluationCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ClearEvaluationCache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Clear all cached evaluation information (meshes, surface points, boundiang boxes, ...) that depends on edge tags, vertex tags, and the location of vertex control points. </p>

</div>
</div>
<a id="a7469bafd0acc8f54da80c0a310b8ac48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7469bafd0acc8f54da80c0a310b8ac48">&#9670;&nbsp;</a></span>ClearFaceGroupIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearFaceGroupIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_group_id value to 0 for every face. Returns: Number of group id values that were changed. </p>

</div>
</div>
<a id="a452daafb274f648b547220f25f8e3bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452daafb274f648b547220f25f8e3bc2">&#9670;&nbsp;</a></span>ClearFaceMarkBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearFaceMarkBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_status.MarkBits() value to 0 for every face. Returns: Number of group id values that were changed. </p>

</div>
</div>
<a id="aaf941338bad8d3e23b75f5d576a27c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf941338bad8d3e23b75f5d576a27c36">&#9670;&nbsp;</a></span>ClearFaceMarks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearFaceMarks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Clears the m_status.RuntimeMark() for every face. Returns: Number of marks that were cleared. </p>

</div>
</div>
<a id="a53e6e7feaadfde6d7a8de414b1dcf25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e6e7feaadfde6d7a8de414b1dcf25e">&#9670;&nbsp;</a></span>ClearFacePackIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ClearFacePackIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Clear all face pack ids and related information. </p>

</div>
</div>
<a id="aaac88e1a2f207ab6cacba712ae0d8357"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac88e1a2f207ab6cacba712ae0d8357">&#9670;&nbsp;</a></span>ClearFacePackingTopologyHashForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ClearFacePackingTopologyHashForExperts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Sets the <a class="el" href="class_o_n___sub_d.html#ae32373a2c26ae53a008f9f717919d9a7">FacePackingTopologyHash()</a> property to Empty. Experts may need to do this when modifying a face packing. After calling <a class="el" href="class_o_n___sub_d.html#aaac88e1a2f207ab6cacba712ae0d8357">ClearFacePackingTopologyHashForExperts()</a>, call FacePackingIsValid(true) to make sure the modified packing was actually valid and update the <a class="el" href="class_o_n___sub_d.html#ae32373a2c26ae53a008f9f717919d9a7">FacePackingTopologyHash()</a>. </p>

</div>
</div>
<a id="a2584647056fe328150cfcc91a504776f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2584647056fe328150cfcc91a504776f">&#9670;&nbsp;</a></span>ClearFragmentColors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ClearFragmentColors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearFragmentColorsMappingTag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descrption: Clear all fragment vertex colors Parameters: bClearFragmentColorsMappingTag - [in] When in doubt, pass true. If true, the mapping tag associated with the fragment vertex colors is unset as well. </p>

</div>
</div>
<a id="abacccdce5b56d8690e760b262f7c0798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacccdce5b56d8690e760b262f7c0798">&#9670;&nbsp;</a></span>ClearFragmentTextureCoordinatesTextureSettingsHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ClearFragmentTextureCoordinatesTextureSettingsHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If a change requires existing fragment texture coordinates to be recalculated, then call <a class="el" href="class_o_n___sub_d.html#abacccdce5b56d8690e760b262f7c0798">ClearFragmentTextureCoordinatesTextureSettingsHash()</a>. </p>

</div>
</div>
<a id="af3182a3f78c700bef1bbdf42f469477d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3182a3f78c700bef1bbdf42f469477d">&#9670;&nbsp;</a></span>ClearFragmentTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* * void ON_SubD::ClearFragmentTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6451bb5d144ad787d21a5d3fda519798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6451bb5d144ad787d21a5d3fda519798">&#9670;&nbsp;</a></span>ClearGroupIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearGroupIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_group_id value to 0 for every vertex, edge and face. Returns: Number of marks that were cleared. </p>

</div>
</div>
<a id="ad0ad622bf4ffd961e703fb8b775ada0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ad622bf4ffd961e703fb8b775ada0f">&#9670;&nbsp;</a></span>ClearHigherSubdivisionLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearHigherSubdivisionLevels </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_level_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Remove subdivision levels Paramters: max_level_index - [in] Remove all levels after max_level_index Returns: Number of removed levels. </p>

</div>
</div>
<a id="a7797500986d963d8db4bb3b67781c397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7797500986d963d8db4bb3b67781c397">&#9670;&nbsp;</a></span>ClearInactiveLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned ON_SubD::ClearInactiveLevels </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all levels except the active level. Returns: Number of removed levels. </p>

</div>
</div>
<a id="adb389cd1ec487746e818b7e3be79d435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb389cd1ec487746e818b7e3be79d435">&#9670;&nbsp;</a></span>ClearLowerSubdivisionLevels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearLowerSubdivisionLevels </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min_level_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Remove subdivision levels Paramters: min_level_index - [in] Remove all levels before min_level_index Returns: Number of removed levels. </p>

</div>
</div>
<a id="a9e6ec96fb185289e07b1f43a867dc903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6ec96fb185289e07b1f43a867dc903">&#9670;&nbsp;</a></span>ClearMarkBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearMarkBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_status.MarkBits() value to 0 for every vertex, edge and face. Returns: Number of marks that were cleared. </p>

</div>
</div>
<a id="a76ab2ee7a336c569564f21ce10975cb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ab2ee7a336c569564f21ce10975cb3">&#9670;&nbsp;</a></span>ClearPerFaceColors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearPerFaceColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Removes all per face color overrides on the active level. Returns: Number of changed faces. Remarks: Per face colors are a mutable property on <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> and are set with <a class="el" href="class_o_n___sub_d_face.html#a8683c5052083fd5bad83a980373e2432">ON_SubDFace.SetPerFaceColor()</a>. </p>

</div>
</div>
<a id="a4de6e40238e6110215a6ee5b021dce43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4de6e40238e6110215a6ee5b021dce43">&#9670;&nbsp;</a></span>ClearPerFaceMaterialChannelIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearPerFaceMaterialChannelIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Removes all per face material channel index overrides on the active level. Returns: Number of changed faces. Remarks: Per face material channel indices are a mutable property on <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> and are set with <a class="el" href="class_o_n___sub_d_face.html#a7f9b3a39f87d794bfc492c49faf8fba0">ON_SubDFace.SetMaterialChannelIndex()</a>. </p>

</div>
</div>
<a id="a5d7bfbe956fdfc9ddcf1eab6be822026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7bfbe956fdfc9ddcf1eab6be822026">&#9670;&nbsp;</a></span>ClearSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ClearSymmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Removes all symmetry and component symmetry set information from this subd. </p>

</div>
</div>
<a id="aa366f471d28fdda4831a9d3cbabaee0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa366f471d28fdda4831a9d3cbabaee0d">&#9670;&nbsp;</a></span>ClearSymmetrySetForExperts() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::ClearSymmetrySetForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Deletes the symmetry set the edge belongs to. Returns: The number of elements in the deleted symmetry set. </p>

</div>
</div>
<a id="a7aa7df2bf0a7c430c3207a818d46a6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa7df2bf0a7c430c3207a818d46a6b3">&#9670;&nbsp;</a></span>ClearSymmetrySetForExperts() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::ClearSymmetrySetForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Deletes the symmetry set the face belongs to. Returns: The number of elements in the deleted symmetry set. </p>

</div>
</div>
<a id="a355c1e1a657fde002c604d517f520e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355c1e1a657fde002c604d517f520e30">&#9670;&nbsp;</a></span>ClearSymmetrySetForExperts() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::ClearSymmetrySetForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Deletes the symmetry set the vertex belongs to. Returns: The number of elements in the deleted symmetry set. </p>

</div>
</div>
<a id="a9027a4ff9027687fa6673c659facde54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9027a4ff9027687fa6673c659facde54">&#9670;&nbsp;</a></span>ClearSymmetrySetForExperts() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::ClearSymmetrySetForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>cptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Deletes the symmetry set the component belongs to. Returns: The number of elements in the deleted symmetry set. </p>

</div>
</div>
<a id="ae3fb133f4e932fd5d6e20f23bd7c6457"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3fb133f4e932fd5d6e20f23bd7c6457">&#9670;&nbsp;</a></span>ClearSymmetrySetNextForExperts() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void ON_SubD::ClearSymmetrySetNextForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool is for expert users with a complete and detailed understanding of creating valid symmetry sets and who carefully and thoroughly test every line of code. If that is not the case, use ClearSymmetrySet() to delete symmetry sets. Parameters: edge - [in] The edge to unconditionally modify. Returns: True if input was valid. False if input was not valid (see description above). </p>

</div>
</div>
<a id="aed46aa02e8c55fe47c8a2ee4d356d452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed46aa02e8c55fe47c8a2ee4d356d452">&#9670;&nbsp;</a></span>ClearSymmetrySetNextForExperts() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void ON_SubD::ClearSymmetrySetNextForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool is for expert users with a complete and detailed understanding of creating valid symmetry sets and who carefully and thoroughly test every line of code. If that is not the case, use ClearSymmetrySet() to delete symmetry sets. Parameters: face - [in] The face to unconditionally modify. Returns: True if input was valid. False if input was not valid (see description above). </p>

</div>
</div>
<a id="a9ba48467e87f296776f7684deeb74ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ba48467e87f296776f7684deeb74ff6">&#9670;&nbsp;</a></span>ClearSymmetrySetNextForExperts() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void ON_SubD::ClearSymmetrySetNextForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool is for expert users with a complete and detailed understanding of creating valid symmetry sets and who carefully and thoroughly test every line of code. If that is not the case, use ClearSymmetrySet() to delete symmetry sets. Parameters: vertex - [in] The vertex to unconditionally modify. Returns: True if input was valid. False if input was not valid (see description above). </p>

</div>
</div>
<a id="aeeaa049e65f0ab7aed082efabb4107b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeaa049e65f0ab7aed082efabb4107b6">&#9670;&nbsp;</a></span>ClearSymmetrySetNextForExperts() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void ON_SubD::ClearSymmetrySetNextForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>component</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool is for expert users with a complete and detailed understanding of creating valid symmetry sets and who carefully and thoroughly test every line of code. If that is not the case, use ClearSymmetrySet() to delete symmetry sets. Parameters: component - [in] The component to unconditionally modify. Returns: True if input was valid. False if input was not valid (see description above). </p>

</div>
</div>
<a id="a915fd32959b98d44c68ac4df536bdb3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a915fd32959b98d44c68ac4df536bdb3e">&#9670;&nbsp;</a></span>ClearSymmetrySetsForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> void ON_SubD::ClearSymmetrySetsForExperts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Removes the component symmetry set information. The <a class="el" href="class_o_n___sub_d.html#a5cc74c233cbff4a0c62f07710128c2e3">Symmetry()</a> property is not changed. </p>

</div>
</div>
<a id="a0541fa1dd9f679206bce1abdbe670003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0541fa1dd9f679206bce1abdbe670003">&#9670;&nbsp;</a></span>ClearTexturePoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearTexturePoints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Delete texture points from faces. Returns: Number of faces that had texture points. </p>

</div>
</div>
<a id="aa6dfebd7c397831d32ba389ea17a239c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6dfebd7c397831d32ba389ea17a239c">&#9670;&nbsp;</a></span>ClearVertexGroupIds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearVertexGroupIds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_group_id value to 0 for every vertex. Returns: Number of group id values that were changed. </p>

</div>
</div>
<a id="afc886c1d71f9e871fafd4013f57a4cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc886c1d71f9e871fafd4013f57a4cb9">&#9670;&nbsp;</a></span>ClearVertexMarkBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearVertexMarkBits </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Sets the m_status.MarkBits() value to 0 for every vertex. Returns: Number of group id values that were changed. </p>

</div>
</div>
<a id="aedeaaa535804d339195bf24747ef0df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedeaaa535804d339195bf24747ef0df5">&#9670;&nbsp;</a></span>ClearVertexMarks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ClearVertexMarks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Descripiton: Clears the m_status.RuntimeMark() for every vertex. Returns: Number of marks that were cleared. </p>

</div>
</div>
<a id="a8358c77769549add432045b791330243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8358c77769549add432045b791330243">&#9670;&nbsp;</a></span>CombineBoundaryEdgeChains() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::CombineBoundaryEdgeChains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>combined_edge_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>combined_edge_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combine (merge / weld) two boundary edges in this subd into a single edge. Parameters: edge_chain0 - [in] A chain of boundary edges. These will survive as the combined edges. edge_chain1 - [in] A chain of boundary edges. These edges will be deleted. edge_chain1 and edge_chain2 must have the same number of edges. combined_edge_location - [in] a value between 0 and 1. 0 = combined edge location = edge0 1 = combined edge location = edge1 combined_edge_tag - [in] Prefered tag for the combined edge Returns: Number of combined edges. </p>

</div>
</div>
<a id="a4df65caf4556ea0adab42aa14c0f1fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df65caf4556ea0adab42aa14c0f1fa5">&#9670;&nbsp;</a></span>CombineBoundaryEdgeChains() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::CombineBoundaryEdgeChains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>combined_edge_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>combined_edge_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combine (merge / weld) two boundary edges in this subd into a single edge. Parameters: edge_chain0 - [in] A chain of boundary edges. These will survive as the combined edges. edge_chain1 - [in] A chain of boundary edges. These edges will be deleted. edge_chain1 and edge_chain2 must have the same number of edges. combined_edge_location - [in] a value between 0 and 1. 0 = combined edge location = edge0 1 = combined edge location = edge1 combined_edge_tag - [in] Prefered tag for the combined edge Returns: Number of combined edges. </p>

</div>
</div>
<a id="a377f2a7170542414f2cf5863532ae20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377f2a7170542414f2cf5863532ae20c">&#9670;&nbsp;</a></span>CombineBoundaryEdgeChains() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::CombineBoundaryEdgeChains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>combined_edge_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>combined_edge_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combine (merge / weld) two boundary edges in this subd into a single edge. Parameters: edge_chain0 - [in] A chain of boundary edges. These will survive as the combined edges. edge_chain1 - [in] A chain of boundary edges. These edges will be deleted. edge_chain1 and edge_chain2 must have the same number of edges. combined_edge_location - [in] a value between 0 and 1. 0 = combined edge location = edge0 1 = combined edge location = edge1 combined_edge_tag - [in] Prefered tag for the combined edge Returns: Number of combined edges. </p>

</div>
</div>
<a id="a40ae8d928ec36daff324c26e86727395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ae8d928ec36daff324c26e86727395">&#9670;&nbsp;</a></span>CombineBoundaryEdgeChains() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::CombineBoundaryEdgeChains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>combined_edge_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>combined_edge_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combine (merge / weld) two boundary edges in this subd into a single edge. Parameters: edge_chain0 - [in] A chain of boundary edges. These will survive as the combined edges. edge_chain1 - [in] A chain of boundary edges. These edges will be deleted. edge_chain1 and edge_chain2 must have the same number of edges. combined_edge_location - [in] a value between 0 and 1. 0 = combined edge location = edge0 1 = combined edge location = edge1 combined_edge_tag - [in] Prefered tag for the combined edge Returns: Number of combined edges. </p>

</div>
</div>
<a id="ac0811d8d493cdf77130775f29630bd25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0811d8d493cdf77130775f29630bd25">&#9670;&nbsp;</a></span>CombineBoundaryEdges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::CombineBoundaryEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>merged_edge_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>merged_edge_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combine (merge / weld) two boundary edges in this subd into a single edge. Parameters: edge0 - [in] A boundary edge. This edge will become the combined edge. edge1 - [in] A boundary edge. This edge will be deleted. combined_edge_location - [in] a value between 0 and 1. 0 = combined edge location = edge0 1 = combined edge location = edge1 combined_edge_tag - [in] Prefered tag for the combined edge Returns: If successful, true is returned. Remarks: The relative orientation of the edges is determined by inspecting the topology and control net directions. If you want more control over edge orientation, the use the version that has <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> parameters. </p>

</div>
</div>
<a id="ab1df3bee27d24d07a86db08316cbcf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1df3bee27d24d07a86db08316cbcf73">&#9670;&nbsp;</a></span>CombineBoundaryEdges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::CombineBoundaryEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>edge1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>merged_edge_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>merged_edge_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combine (merge / weld) two boundary edges in this subd into a single edge. Parameters: edge0 - [in] A boundary edge. This edge will become the combined edge. edge1 - [in] A boundary edge. This edge will be deleted. combined_edge_location - [in] a value between 0 and 1. 0 = combined edge location = edge0 1 = combined edge location = edge1 combined_edge_tag - [in] Prefered tag for the combined edge Returns: If successful, true is returned. </p>

</div>
</div>
<a id="ad4097fc1b7edc7e899467bd17851a316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4097fc1b7edc7e899467bd17851a316">&#9670;&nbsp;</a></span>CombineBoundaryVertices() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::CombineBoundaryVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>combined_vertex_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combine (merge / weld) conincident vertices into single vertex. Parameters: ci_list - [in] A list of vertices to consider for combining. combined_vertex_tag - [in] Sugggested vertex tag for combined vertices. Returns: Number of combined vertices that were created. </p>

</div>
</div>
<a id="ab569b7d09a215065c2222bd61c720889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab569b7d09a215065c2222bd61c720889">&#9670;&nbsp;</a></span>CombineBoundaryVertices() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::CombineBoundaryVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>combined_vertex_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combine (merge / weld) conincident vertices into single vertices. Parameters: vertex_list - [in] A list of vertices to consider for combining. combined_vertex_tag - [in] Sugggested vertex tag for combined vertices. Returns: Number of merges performed. </p>

</div>
</div>
<a id="a2ec68eaf8aaea7464da391e811a1cf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec68eaf8aaea7464da391e811a1cf4b">&#9670;&nbsp;</a></span>CombineBoundaryVertices() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::CombineBoundaryVertices </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>combined_vertex_control_net_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>combined_vertex_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Combine (merge / weld) two boundary vertices in this subd into a single vertex. Parameters: vertex0 - [in] A boundary vertex - will survive as the merged vertex vertex1 - [in] A boundary vertex - will be deleted combined_vertex_control_net_point - [in] combined vertex's control net point Pass <a class="el" href="class_o_n__3d_point.html#aa68906e3e7650b01ce88c527f6088d7d" title="(ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)">ON_3dPoint::UnsetPoint</a> to use the average of the input control net points. combined_vertex_tag - [in] Sugggested vertex tag. Returns: If the vertices are combined, true is returned. Othwise, false is returned. </p>

</div>
</div>
<a id="aff1cca32b3c5ec738dcead27ce15584e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff1cca32b3c5ec738dcead27ce15584e">&#9670;&nbsp;</a></span>ComponentIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> ON_SubD::ComponentIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#a20e5d1aeada9545127329a8699c702b9">ON_Geometry</a>.</p>

</div>
</div>
<a id="a49517e4c8b172bdfa7cf78f3711fb997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49517e4c8b172bdfa7cf78f3711fb997">&#9670;&nbsp;</a></span>ComponentPtrFromComponentIndex() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ComponentPtrFromComponentIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cptr_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adedd46d29370a5a8885dba3830fbf8df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adedd46d29370a5a8885dba3830fbf8df">&#9670;&nbsp;</a></span>ComponentPtrFromComponentIndex() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ComponentPtrFromComponentIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cptr_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a12cbee173aeab61f2b894403b6c18db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12cbee173aeab61f2b894403b6c18db6">&#9670;&nbsp;</a></span>ComponentPtrFromComponentIndex() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> ON_SubD::ComponentPtrFromComponentIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>component_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Component (Vertex, Edge, Face) access </p>

</div>
</div>
<a id="a5d971e3c8b8e1a8cc2878c7a2d1f2518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d971e3c8b8e1a8cc2878c7a2d1f2518">&#9670;&nbsp;</a></span>ComponentRingEdgeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::ComponentRingEdgeCount </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: Number of edges in an component ring returned by ON_SubD::GetVertexComponentRing(); </p>

</div>
</div>
<a id="aaf53e96f7ea28fd73ec437cada5e9537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf53e96f7ea28fd73ec437cada5e9537">&#9670;&nbsp;</a></span>ComponentRingFaceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::ComponentRingFaceCount </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: Number of faces in an component ring returned by ON_SubD::GetVertexComponentRing(); </p>

</div>
</div>
<a id="af939c7a93096559800d2c7e82aac4e9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af939c7a93096559800d2c7e82aac4e9a">&#9670;&nbsp;</a></span>ComponentRingIsValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::ComponentRingIsValid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4254106e4a203dfb14dac06e84371708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4254106e4a203dfb14dac06e84371708">&#9670;&nbsp;</a></span>ComponentStatusSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a> ON_SubD::ComponentStatusSerialNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: A runtime serial number that is incremented every time a component status (locked, hidden, selected, highlighted, ...) is changed. </p>

</div>
</div>
<a id="afda5bb6a04c93f681cf672ca9208abc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda5bb6a04c93f681cf672ca9208abc4">&#9670;&nbsp;</a></span>ContentIsSymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::ContentIsSymmetric </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if this subd has the symmetry specified by this-&gt;<a class="el" href="class_o_n___sub_d.html#a5cc74c233cbff4a0c62f07710128c2e3">Symmetry()</a>. </p>

</div>
</div>
<a id="ab26ee8a44d5011366c4b1b061d785a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab26ee8a44d5011366c4b1b061d785a62">&#9670;&nbsp;</a></span>ControlPointRadiusFromSurfacePointRadius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubD::ControlPointRadiusFromSurfacePointRadius </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>point_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>surface_point_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: point_count - [in] &gt;= 3 Number of control points in a regular planar SubD ngon with creased edges. surface_radius - [in] Distance from an ngon surface point to the ngon center. Returns: Distance from an ngon control point to the ngon center. See Also: <a class="el" href="class_o_n___sub_d.html#ab26ee8a44d5011366c4b1b061d785a62">ON_SubD::ControlPointRadiusFromSurfacePointRadius()</a> </p>

</div>
</div>
<a id="a0c3292d353aaf0f19a816f83bfc9d1b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c3292d353aaf0f19a816f83bfc9d1b0">&#9670;&nbsp;</a></span>CopyEvaluationCacheForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::CopyEvaluationCacheForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This function copies cached evaluations of component subdivision points and limit surface information from src to this. Typically this is done for performance critical sitations like control point editing. </p>

</div>
</div>
<a id="a1adb59e3e0e59e1582ccc5436fade9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adb59e3e0e59e1582ccc5436fade9bc">&#9670;&nbsp;</a></span>CreateControlNetFromNurbsCurves() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateControlNetFromNurbsCurves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Loft a subd control net through a list of nurbs curve control nets. </p>

</div>
</div>
<a id="ac1d3dadbcd3eecfd604629da9afb5959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1d3dadbcd3eecfd604629da9afb5959">&#9670;&nbsp;</a></span>CreateControlNetFromNurbsCurves() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateControlNetFromNurbsCurves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___object_array.html">ON_ObjectArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Loft a subd control net through a list of nurbs curve control nets. </p>

</div>
</div>
<a id="a324a97da2a5aa3c8123aae243a462ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324a97da2a5aa3c8123aae243a462ac7">&#9670;&nbsp;</a></span>CreateControlNetFromNurbsCurves() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateControlNetFromNurbsCurves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Loft a subd control net through a list of nurbs curve control nets. </p>

</div>
</div>
<a id="acae5941c4293a6b1cf269238b6a79a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acae5941c4293a6b1cf269238b6a79a54">&#9670;&nbsp;</a></span>CreateControlNetFromPolylines() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateControlNetFromPolylines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Loft a subd control net through a list of polylines. </p>

</div>
</div>
<a id="ae597aee9dafc59adba8abf3d3092c592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae597aee9dafc59adba8abf3d3092c592">&#9670;&nbsp;</a></span>CreateControlNetFromPolylines() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateControlNetFromPolylines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___polyline_curve.html">ON_PolylineCurve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Loft a subd control net through a list of polylines. </p>

</div>
</div>
<a id="a85a27a9d5857262adb81f202aa279d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a27a9d5857262adb81f202aa279d56">&#9670;&nbsp;</a></span>CreateControlNetFromPolylines() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateControlNetFromPolylines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___object_array.html">ON_ObjectArray</a>&lt; <a class="el" href="class_o_n___polyline_curve.html">ON_PolylineCurve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Loft a subd control net through a list of polylines. </p>

</div>
</div>
<a id="ad8399b4b9a51b672af373045976f2caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8399b4b9a51b672af373045976f2caa">&#9670;&nbsp;</a></span>CreateControlNetFromPolylines() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateControlNetFromPolylines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___polyline.html">ON_Polyline</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Loft a subd control net through a list of polylines. </p>

</div>
</div>
<a id="a0a273ed1a4acabfe04d199d36f3d973a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a273ed1a4acabfe04d199d36f3d973a">&#9670;&nbsp;</a></span>CreateControlNetFromPolylines() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateControlNetFromPolylines </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___polyline_curve.html">ON_PolylineCurve</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>polylines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Loft a subd control net through a list of polylines. </p>

</div>
</div>
<a id="ab8927364fd5256139bf2dfd8d7b8d9b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8927364fd5256139bf2dfd8d7b8d9b2">&#9670;&nbsp;</a></span>CreateCylinder()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateCylinder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___cylinder.html">ON_Cylinder</a> &amp;&#160;</td>
          <td class="paramname"><em>cylinder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>circumference_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>height_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga06c51562f7fa69ab3273a2d4a63f3c41">ON_SubDEndCapStyle</a>&#160;</td>
          <td class="paramname"><em>end_cap_style</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>end_cap_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>radius_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e93a0b2e823c12081f6e3e6efe8ef2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e93a0b2e823c12081f6e3e6efe8ef2d">&#9670;&nbsp;</a></span>CreateFromBoundary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateFromBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___curve.html">ON_Curve</a> &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Uses the input surface to define a SubD. Parameters: curve - [in] A closed curve. If the closed curve is a uniform cubic periodic NURBS curve, then the boundary of the returned SubD will exactly match that curve. Otherwise, ON_SubD::CreateSubDFriendlyCurve(curve) will be the boundary. destination_subd - [in] Can be nullptr Returns: SubD with specified boundary or nullptr if input is not valid. <br  />
 </p>

</div>
</div>
<a id="a2d64c8c2acf505dffbf977c0546d3b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d64c8c2acf505dffbf977c0546d3b85">&#9670;&nbsp;</a></span>CreateFromLoftCurves() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateFromLoftCurves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cc8a8c93ac9271aa3f0549de04f1d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc8a8c93ac9271aa3f0549de04f1d7b">&#9670;&nbsp;</a></span>CreateFromLoftCurves() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateFromLoftCurves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___object_array.html">ON_ObjectArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a22092cb18ce644f718c38221cadd2262"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22092cb18ce644f718c38221cadd2262">&#9670;&nbsp;</a></span>CreateFromLoftCurves() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateFromLoftCurves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bCorners</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>span_divisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Loft a subd through curves Parameters: curves - [in] A list of compatible SubD-friendly NURBS curves. bPeriodicClosedLoft - [in] bCorners - [in] If true, and bPeriodicClosedLoft is false, and the curves are open, then the 4 corners will will be tagged <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a>. span_divisions - [in] number of subd divisions between input shape locations </p>

</div>
</div>
<a id="a64271fbccd945aceba18409ce1342c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64271fbccd945aceba18409ce1342c08">&#9670;&nbsp;</a></span>CreateFromMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateFromMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>level_zero_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_from_mesh_parameters.html">ON_SubDFromMeshParameters</a> *&#160;</td>
          <td class="paramname"><em>from_mesh_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Uses the input mesh to define the level zero control polygon. Parameters: level_zero_mesh - [in] from_mesh_parameters - [in] To get the smoothest possible result, pass nullptr or <a class="el" href="class_o_n___sub_d_from_mesh_parameters.html#ad63caa4eead95353b234c9aac783fca1" title="No interior creases and no corners.">ON_SubDFromMeshParameters::Smooth</a>. To get a sub-D with interior creases use other static <a class="el" href="class_o_n___sub_d_from_mesh_parameters.html">ON_SubDFromMeshParameters</a> values or create one with custom settings. </p>

</div>
</div>
<a id="a9a015e1ff89dbd2c50ff6516488894fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a015e1ff89dbd2c50ff6516488894fb">&#9670;&nbsp;</a></span>CreateFromSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateFromSurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___surface.html">ON_Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_from_surface_parameters.html">ON_SubDFromSurfaceParameters</a> *&#160;</td>
          <td class="paramname"><em>from_surface_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a subd that approximates the surface. If the surface is a subd friendly NURBS surface and bCorners is true, then the subd and input surface will have the same geometry. Parameters: surface - [in] method - [in] Selects the method used to calculate the subd. bCorners - [in] If the surface is open, then the corner vertices with be tagged as ON_SubD::VertexTagCorner. This makes the resulting subd have sharp corners to match the appearance of the input surface. </p>

</div>
</div>
<a id="a97ca314d3522042865ab415447128703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97ca314d3522042865ab415447128703">&#9670;&nbsp;</a></span>CreateRotateSymmetryFromTwoFacesAndAxis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a> ON_SubD::CreateRotateSymmetryFromTwoFacesAndAxis </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>primary_face_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>secondary_face_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___line.html">ON_Line</a>&#160;</td>
          <td class="paramname"><em>rotation_axis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>cleanup_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Make the primary motif from this and a symmetry. Parameters: first_face_id - [in] Id of a face in the primary motif. secondary_face_id - [in] Id of the face that that primary_face rotates to or that rotates to primary face. rotate_axis - [in] Axis for the rotate symmetry cleanup_tolerance - [in] Symmetric object cleanup tolerance. When in doubt, pass 0. Returns: If successful, a symmetry with type ON_Symmetry::Type::NewRotate is returned and the faces in the primary motif have Mark() = true. Otherwise, <a class="el" href="class_o_n___symmetry.html#af5c21d2eb8013194dcc8da5a380808e5">ON_Symmetry::Unset</a> is returned and all components have Mark() = false. </p>

</div>
</div>
<a id="a6dbd2a9c4bb8bacfcdc98cd951f28b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbd2a9c4bb8bacfcdc98cd951f28b1b">&#9670;&nbsp;</a></span>CreateSubDBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateSubDBox </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>corners</em>[8], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>facecount_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>facecount_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>facecount_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Creates a SubD box Parameters: corners - [in] Box corners. The bottom quad is specified by the first 4 points and the top quad specified by the last 4 points. edge_tag - [in] If edge_tag = <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>, then the box will have creases and corners. Otherwise the box will be smooth. facecount_x - [in] Number of faces in x direction facecount_y - [in] Number of faces in y direction facecount_z - [in] Number of faces in z direction destination_subd [out] - If destination_subd is not null, make the SubD box there Returns: Pointer to the resulting SubD if successful Null for error </p>

</div>
</div>
<a id="a31445715b80ffdda3999c1c380dff3bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31445715b80ffdda3999c1c380dff3bd">&#9670;&nbsp;</a></span>CreateSubDFriendlyCurve() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubD::CreateSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___curve.html">ON_Curve</a> &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9715a1968ac70233f140541b899c569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9715a1968ac70233f140541b899c569">&#9670;&nbsp;</a></span>CreateSubDFriendlyCurve() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubD::CreateSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___curve.html">ON_Curve</a> &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedCurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description:</p>
<p>Parameters: curve - [in] curve to rebuild as a SubD friendly curve. cv_count - [in] Desired number of control points. 0: automatic &gt;0: Number of control points in the SubD friendly curve. If bPeriodicClosedCurve is true, the number must be &gt;= 6, otherwise the number must be &gt;= 4. bPeriodicClosedCurve - [in] True if the SubD friendly curve should be closed and periodic. False in all other cases. destination_curve - [in] If destination_curve is not nullptr, the SubD friendly curve is created in destination_curve. Otherwise the SubD friendly curve is allocated on heap. Returns: A pointer to the SubD friendly curve. Remarks: A "natural" spline has zero 2nd derivatives (and hence zero curvature) at the start and end. A "periodic" spline has unclampled periodic knots and periodic control points. </p>

</div>
</div>
<a id="a47be7c4b5e96e48e7e9c7f9102787290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47be7c4b5e96e48e7e9c7f9102787290">&#9670;&nbsp;</a></span>CreateSubDFriendlyCurve() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubD::CreateSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___curve.html">ON_Curve</a> &amp;&#160;</td>
          <td class="paramname"><em>curve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af7de3d9c4ef19abf6f1ba05809b51d0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7de3d9c4ef19abf6f1ba05809b51d0d">&#9670;&nbsp;</a></span>CreateSubDFriendlyCurve() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubD::CreateSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>point_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInterpolatePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedCurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Expert user tool to create a NURBS curve that is suitable for calculations like lofting SubD objects through a sequence of curves. Parameters: point_count - [in] &gt;= 2 point_stride - [in] abs(point_stride) &gt;= 3 points[] - [in] Adjacent points must not be equal. If bPeriodicClosedCurve is false, there must be at least two points. If bPeriodicClosedCurve is true, there must be at least three points and it is not necessary to duplicate the first and last points. When bPeriodicClosedCurve is true and the first and last points are equal, the duplicate last point is automatically ignored. bInterpolatePoints -[in] True if the curve should interpolate the points. False if points[] specify control point locations. In either case, the curve will begin at the first point and end at the last point. bPeriodicClosedCurve - [in] true to create a periodic closed curve. Do not duplicate the start/end point in the point[] input. destination_curve - [in] If destination_curve is not nullptr, then the resulting curve will be created in destination_curve. Returns: If the input is valid, then a uniform cubic NURBS curve with point_count+2 control points and unclamped knots is returned. If the input is not valid, nullptr is returned. Remarks: When destination_curve is nullptr, the returned curve is on the heap and the caller must manage it. </p>

</div>
</div>
<a id="ab9fdf614b14a8657d91d5f48c6076fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fdf614b14a8657d91d5f48c6076fd6">&#9670;&nbsp;</a></span>CreateSubDFriendlyCurve() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubD::CreateSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>point_stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInterpolatePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedCurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> bool *&#160;</td>
          <td class="paramname"><em>creases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Expert user tool to create a NURBS curve that is suitable for calculations like lofting SubD objects through a sequence of curves. Parameters: point_count - [in] &gt;= 2 point_stride - [in] abs(point_stride) &gt;= 3 points[] - [in] Adjacent points must not be equal. If bPeriodicClosedCurve is false, there must be at least two points. If bPeriodicClosedCurve is true, there must be at least three points and it is not necessary to duplicate the first and last points. When bPeriodicClosedCurve is true and the first and last points are equal, the duplicate last point is automatically ignored. bInterpolatePoints -[in] True if the curve should interpolate the points. False if points[] specify control point locations. In either case, the curve will begin at the first point and end at the last point. bPeriodicClosedCurve - [in] true to create a periodic closed curve. Do not duplicate the start/end point in the point[] input. creases[] - [in] If creases is nullptr, this parameter is ignored. If bPeriodicClosedCurve is true, this parameter is ignored. Otherwise creases[] is an array of point_count bools and when creases[i] is true there will be a natural crease/kink at the corresponding point. The values of creases[0] and creases[point_count-1] are ignored. destination_curve - [in] If destination_curve is not nullptr, then the resulting curve will be created in destination_curve. Returns: If the input is valid, then a uniform cubic NURBS curve with point_count+2 control points and unclamped knots is returned. If the input is not valid, nullptr is returned. Remarks: When destination_curve is nullptr, the returned curve is on the heap and the caller must manage it. </p>

</div>
</div>
<a id="a79a746e7f1fa98ad026fc3ce911166be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a746e7f1fa98ad026fc3ce911166be">&#9670;&nbsp;</a></span>CreateSubDFriendlyCurve() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubD::CreateSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInterpolatePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedCurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a NURBS curve that is suitable for calculations like lofting SubD objects through a sequence of curves. Parameters: point_count - [in] Must be &gt;= 2. points[] - [in] Adjacent points must not be equal. If bPeriodicClosedCurve is false, there must be at least two points. If bPeriodicClosedCurve is true, there must be at least three points and it is not necessary to duplicate the first and last points. When bPeriodicClosedCurve is true and the first and last points are equal, the duplicate last point is automatically ignored. bInterpolatePoints -[in] True if the curve should interpolate the points. False if points[] specify control point locations. In either case, the curve will begin at the first point and end at the last point. bPeriodicClosedCurve - [in] true to create a periodic closed curve. Do not duplicate the start/end point in the point[] input. destination_curve - [in] If destination_curve is not nullptr, then the resulting curve will be created in destination_curve. Returns: If the input is valid, then a uniform cubic NURBS curve with unclamped knots is returned. If the input is not valid, nullptr is returned. Remarks: When destination_curve is nullptr, the returned curve is on the heap and the caller must manage it. </p>

</div>
</div>
<a id="a1705a37c1ab6f4a6dce3ed8f7147650a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1705a37c1ab6f4a6dce3ed8f7147650a">&#9670;&nbsp;</a></span>CreateSubDFriendlyCurve() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubD::CreateSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bInterpolatePoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedCurve</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a NURBS curve that is suitable for calculations like lofting SubD objects through a sequence of curves. Parameters: points[] - [in] Adjacent points must not be equal. If bPeriodicClosedCurve is false, there must be at least two points. If bPeriodicClosedCurve is true, there must be at least three points and it is not necessary to duplicate the first and last points. When bPeriodicClosedCurve is true and the first and last points are equal, the duplicate last point is automatically ignored. bInterpolatePoints -[in] True if the curve should interpolate the points. False if points[] specify control point locations. In either case, the curve will begin at the first point and end at the last point. bPeriodicClosedCurve - [in] true to create a periodic closed curve. destination_curve - [in] If destination_curve is not nullptr, then the resulting curve will be created in destination_curve. Returns: If the input is valid, then a uniform cubic NURBS curve with unclamped knots is returned. If the input is not valid, nullptr is returned. Remarks: When destination_curve is nullptr, the returned curve is on the heap and the caller must manage it. </p>

</div>
</div>
<a id="a2198bbe0bf3c3f7901638c439aa97411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2198bbe0bf3c3f7901638c439aa97411">&#9670;&nbsp;</a></span>CreateSubDFriendlyCurve() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubD::CreateSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a NURBS curve that close to being on the SubD surface. Parameters: edge_count edge_chain[] - [in] An edge chain. edge[i].RelativeVertex(1) == edge[i+1].RelativeVertex(0). destination_curve - [in] If destination_curve is not nullptr, then the resulting curve will be created in destination_curve. Returns: If the input is valid, then a cubic NURBS curve is returned. Any time there is a vertex that is a crease with a smooth edge or any type of corner, then corresponding location on the curve will have a triple knot. If the input is not valid, nullptr is returned. Remarks: When destination_curve is nullptr, the returned curve is on the heap and the caller must manage it. </p>

</div>
</div>
<a id="ac920bccf0353c3a8e8c573931e8c81fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac920bccf0353c3a8e8c573931e8c81fc">&#9670;&nbsp;</a></span>CreateSubDFriendlyCurve() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a>* ON_SubD::CreateSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> *&#160;</td>
          <td class="paramname"><em>destination_curve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5ef1861b9ea3c854380818a09799656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ef1861b9ea3c854380818a09799656">&#9670;&nbsp;</a></span>CreateSubDFriendlyIsoCurves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::CreateSubDFriendlyIsoCurves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___surface.html">ON_Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iso_dir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>loft_curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>loft_creases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>loft_parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Creates a list of SubD friendly nurbs curves that can be used to loft a SubD fit to the input surface. Parameters: surface - [in] iso_dir - [in] surface parameter direction for the loft_curves[] loft_curves - [out] A list of non-rational NURBS curves that can be lofted into a SubD friendly surface. Each curve must be either a degree 3 subd-friendly curve or a degree 1 polyline. bPeriodicClosedLoft - [out] True if a closed periodic lofted surface should be created throught loft_curves[]. In this case loft_creases.Count() = 0. loft_creases -[out] If the surface has creases, then a loft_creases.Count() = loft_curves.Count() and loft_curves[i] is a crease when loft_crease[i] is true. Otherwise loft_creases.Count() = 0. loft_parameters - [out] The curve loft_curves[i] is a SubD friendly fit to the curve surface.IsoCurve(iso_dir, loft_parameters[i]); These values are for use to build a correspondence between surface and any resulting loft. Up to an domain change, the SubD friendly loft will have its parameters completely determined by loft_creases.Count(), loft_creases[], and bPeriodicClosedLoft. Returns: true if loft_curves[] and related information was successfully calculated. </p>

</div>
</div>
<a id="a90055f8dc99ea1d3308764dbe3d5eee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90055f8dc99ea1d3308764dbe3d5eee3">&#9670;&nbsp;</a></span>CreateSubDFriendlySurface() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a>* ON_SubD::CreateSubDFriendlySurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___surface.html">ON_Surface</a> &amp;&#160;</td>
          <td class="paramname"><em>surface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td>
          <td class="paramname"><em>destination_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a bicubic subd friendly surface by lofting through subd friendly cubic curves. Parameters: cubic_curves - [in] SubD friendly cubic curves. bPeriodicClosedLoft - [in] If true, the returned surface will be a periodic loft through the curves. destination_surface - [in] If not nullptr, the SubD friendly surface will be created in destination_surface </p>

</div>
</div>
<a id="aaff188797270d23af771cb94b017e594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaff188797270d23af771cb94b017e594">&#9670;&nbsp;</a></span>CreateSubDFriendlySurface() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a>* ON_SubD::CreateSubDFriendlySurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___class_array.html">ON_ClassArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cubic_curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td>
          <td class="paramname"><em>destination_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a bicubic subd friendly surface by lofting through subd friendly cubic curves. Parameters: cubic_curves - [in] SubD friendly cubic curves. bPeriodicClosedLoft - [in] If true, the returned surface will be a periodic loft through the curves. destination_surface - [in] If not nullptr, the SubD friendly surface will be created in destination_surface </p>

</div>
</div>
<a id="abb73704774f0b1ae299dc1a5ed160bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb73704774f0b1ae299dc1a5ed160bc0">&#9670;&nbsp;</a></span>CreateSubDFriendlySurface() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a>* ON_SubD::CreateSubDFriendlySurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___object_array.html">ON_ObjectArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cubic_curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td>
          <td class="paramname"><em>destination_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a bicubic subd friendly surface by lofting through subd friendly cubic curves. Parameters: cubic_curves - [in] SubD friendly cubic curves. bPeriodicClosedLoft - [in] If true, the returned surface will be a periodic loft through the curves. destination_surface - [in] If not nullptr, the SubD friendly surface will be created in destination_surface </p>

</div>
</div>
<a id="aff47daae372916cbb3a7e8d7f704b616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff47daae372916cbb3a7e8d7f704b616">&#9670;&nbsp;</a></span>CreateSubDFriendlySurface() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a>* ON_SubD::CreateSubDFriendlySurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>cubic_curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td>
          <td class="paramname"><em>destination_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a bicubic subd friendly surface by lofting through subd friendly cubic curves. Parameters: cubic_curves - [in] SubD friendly cubic curves. bPeriodicClosedLoft - [in] If true, the returned surface will be a periodic loft through the curves. destination_surface - [in] If not nullptr, the SubD friendly surface will be created in destination_surface </p>

</div>
</div>
<a id="a35406e9c7cf6f1c0f1152bf966ab65da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35406e9c7cf6f1c0f1152bf966ab65da">&#9670;&nbsp;</a></span>CreateSubDFriendlySurface() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a>* ON_SubD::CreateSubDFriendlySurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>cubic_curves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPeriodicClosedLoft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> bool *&#160;</td>
          <td class="paramname"><em>creases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *&#160;</td>
          <td class="paramname"><em>destination_surface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Create a bicubic subd friendly surface by lofting through subd friendly cubic curves. Parameters: cubic_curves - [in] SubD friendly cubic curves. bPeriodicClosedLoft - [in] If true, the returned surface will be a periodic loft through the curves. creases - [in] If bPeriodicClosedLoft is false and creases is not nullptr, then it must be an array of cubic_curves.Count() bools. In this case, if creases[i] is true, then the returned surface will have a crease along cubic_curves[i]. destination_surface - [in] If not nullptr, the SubD friendly surface will be created in destination_surface </p>

</div>
</div>
<a id="a1d9181a6e9f55eb6d8b5c3c6f74c9a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d9181a6e9f55eb6d8b5c3c6f74c9a04">&#9670;&nbsp;</a></span>CreateSymmetryPrimaryMotif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::CreateSymmetryPrimaryMotif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a>&#160;</td>
          <td class="paramname"><em>symmetry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_id_list.html">ON_SubDComponentIdList</a> &amp;&#160;</td>
          <td class="paramname"><em>motif_outer_vertex_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Make the primary motif from this and a symmetry. Parameters: symmetry - [in] desired symmetry. motif_outer_vertex_list - [out] motif_outer_vertex_list.InList() and motif_outer_vertex_list.Passes() is true if a motif vertex is on the outer region of the motif and it is elibable to be merged with another vertex when a symmetric SubD is made from the motif. Returns: If successful, a pointer to the primary motif is returned. If the primary motif is symmetric (see Remarks below for examples), then then <a class="el" href="class_o_n___sub_d.html#afda5bb6a04c93f681cf672ca9208abc4">ContentIsSymmetric()</a> will be true on the returned primary motif. Otherwise <a class="el" href="class_o_n___sub_d.html#afda5bb6a04c93f681cf672ca9208abc4">ContentIsSymmetric()</a> will be false and transformed copies of the primary motif need to be joined to create a symmetric SubD.</p>
<p>The components on the primary motif that can be merged are returned with Mark() = true. When a motif isn't fully symmetric and copies will be transformed and appended, it is a good idea to exclude unmarked vertice from being merged. Passing an override of <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> to append that looks at a sorted list of ids is one way to accomplish this. Remarks: For example a quad face centered at the origin is symmetric under 4 reflections, symmetric under 90 and 120 degree rotations about the origin, and reflect and rotate symmetric under 4 reflection with a 180 degree rotation. </p>

</div>
</div>
<a id="a956cafc1882293ecefaa615959c001c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956cafc1882293ecefaa615959c001c4">&#9670;&nbsp;</a></span>DataCRC()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#gaea03c6f4bab106103ada72c766f7fe5c">ON__UINT32</a> ON_SubD::DataCRC </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gaea03c6f4bab106103ada72c766f7fe5c">ON__UINT32</a>&#160;</td>
          <td class="paramname"><em>current_remainder</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#af51d5fcec9379ad9b7a56ac4dfc9a8b2">ON_Object</a>.</p>

</div>
</div>
<a id="a5d47a7372b1663e5440d1009b77d4807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d47a7372b1663e5440d1009b77d4807">&#9670;&nbsp;</a></span>DeleteComponents() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::DeleteComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#aa67be7d8cc76ec82ae22a30093ecf98f">ON_Object</a>.</p>

</div>
</div>
<a id="ae33929c32bbeff4275c5c3cf75ae747b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33929c32bbeff4275c5c3cf75ae747b">&#9670;&nbsp;</a></span>DeleteComponents() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::DeleteComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkDeletedFaceEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a259284c37d1af92e9f811f99720ee355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259284c37d1af92e9f811f99720ee355">&#9670;&nbsp;</a></span>DeleteComponents() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::DeleteComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cptr_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkDeletedFaceEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Delete components in cptr_list[]. If a vertex is in cptr_list[], the vertex and every edge and face attached to the vertex are deleted. If an edge is in cptr_list[], the edge and every face attached to the edge are deleted. If a face is in cptr_list[], the face is deleted. Parameters: cptr_list - [in] cptr_count - [in] length of cptr_list[] array. bMarkDeletedFaceEdges - [in] If true, surviving edges attached to delete faces have their runtmime mark set. Returns: 1: some state settings changed on the component. 1: some state setting changed on the component. </p>

</div>
</div>
<a id="afc05d8d257e41d364a3a24730000eef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc05d8d257e41d364a3a24730000eef1">&#9670;&nbsp;</a></span>DeleteComponentsForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::DeleteComponentsForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cptr_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDeleteIsolatedEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUpdateTagsAndCoefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkDeletedFaceEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4aead0ac8554846604f41d6a022c783c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aead0ac8554846604f41d6a022c783c">&#9670;&nbsp;</a></span>DeleteFacesOnPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::DeleteFacesOnPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a>&#160;</td>
          <td class="paramname"><em>plane_equation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Delete faces that are on a plane in preparation for mirroring the subd or joining to somethinng across the plane Parameters: plane_equation - [in] distance_tolerance - [in] If the maximum distance from a face's control points to the plane is &lt;= distance_tolerance, then that face is deleted. Returns: number of faces deleted </p>

</div>
</div>
<a id="aab30470bf102b7c6388ee3b62bfa57e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab30470bf102b7c6388ee3b62bfa57e7">&#9670;&nbsp;</a></span>DeleteMarkedComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::DeleteMarkedComponents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDeleteMarkedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga3b6aca42cfeb22b5315f542d04ba024c">ON__UINT8</a>&#160;</td>
          <td class="paramname"><em>mark_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkDeletedFaceEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Delete marked components. Parameters: bDeleteMarkedComponents - [in] If true, marked components are deleted. If false, unmarked components are deleted. <br  />
 mark_bits - [in] A component is marked if component.m_status.IsMarked(mark_bits) is true. </p>

</div>
</div>
<a id="ae68b7e6139ae014a80665878e80307d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae68b7e6139ae014a80665878e80307d2">&#9670;&nbsp;</a></span>DeleteMarkedComponentsForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::DeleteMarkedComponentsForExperts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDeleteMarkedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga3b6aca42cfeb22b5315f542d04ba024c">ON__UINT8</a>&#160;</td>
          <td class="paramname"><em>mark_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDeleteIsolatedEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUpdateTagsAndCoefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkDeletedFaceEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Delete marked components. Parameters: bDeleteMarkedComponents - [in] If true, marked components are deleted. If false, unmarked components are deleted. mark_bits - [in] A component is marked if component.m_status.IsMarked(mark_bits) is true. </p>

</div>
</div>
<a id="a5f8074d561bee1dc38fcef3cb2e8b19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8074d561bee1dc38fcef3cb2e8b19b">&#9670;&nbsp;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Delete all contents release all memory used by this <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. </p>

</div>
</div>
<a id="a2cc3756ee7209297f559f4f48d82ccbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc3756ee7209297f559f4f48d82ccbe">&#9670;&nbsp;</a></span>DestroyRuntimeCache()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::DestroyRuntimeCache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bDelete</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>
<p>Remarks: For <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> objects, <a class="el" href="class_o_n___sub_d.html#a44bdc135bc3376821f925f14a36d2680" title="virtual">ClearBoundingBox()</a> and <a class="el" href="class_o_n___sub_d.html#a2cc3756ee7209297f559f4f48d82ccbe" title="virtual">DestroyRuntimeCache()</a> are identical. </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#af8435c33ab53af41c22dac75e8917569">ON_Object</a>.</p>

</div>
</div>
<a id="a1c4b47df189a6ba5a8b1e60b2c5879f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4b47df189a6ba5a8b1e60b2c5879f1">&#9670;&nbsp;</a></span>Dimension()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ON_SubD::Dimension </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#a0d66ab16e2fddfd1b3e6cf3d6ebbd364">ON_Geometry</a>.</p>

</div>
</div>
<a id="a6a33810f2fae5af6f51a87ffc8d4184c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a33810f2fae5af6f51a87ffc8d4184c">&#9670;&nbsp;</a></span>DissolveOrDelete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::DissolveOrDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Use MergeFaceSets to dissolve edges and vertices and use DeleteComponents to delete faces. Parameters: ci_list - [in] Vertices, edges, and faces. Returns: Number of merged faces created by dissolving edges and vertices. </p>

</div>
</div>
<a id="a48ab98172ebd8edfa28fd78c53fd9094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48ab98172ebd8edfa28fd78c53fd9094">&#9670;&nbsp;</a></span>DissolveOrDelete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::DissolveOrDelete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cptr_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Use MergeFaceSets to dissolve edges and vertices and use DeleteComponents to delete faces. Parameters: cptr_list - [in] Vertices, edges, and faces. Returns: Number of merged faces created by dissolving edges and vertices. Runtime mark is set on merged faces and edges that were a boundary of a deleted face. </p>

</div>
</div>
<a id="a72c206f8957113a813a9a97b13eb4a08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c206f8957113a813a9a97b13eb4a08">&#9670;&nbsp;</a></span>Dump()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::Dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a21c7b04a80f1806c3a45f72d7c491a44">ON_Object</a>.</p>

</div>
</div>
<a id="ae125d90f0c3383a645ad8dda9a94b95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae125d90f0c3383a645ad8dda9a94b95c">&#9670;&nbsp;</a></span>DumpTopology() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::DumpTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__2udex.html">ON_2udex</a>&#160;</td>
          <td class="paramname"><em>vertex_id_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__2udex.html">ON_2udex</a>&#160;</td>
          <td class="paramname"><em>edge_id_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__2udex.html">ON_2udex</a>&#160;</td>
          <td class="paramname"><em>face_id_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace95b06b8a34ca6a1b1f4ceb72e6bca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace95b06b8a34ca6a1b1f4ceb72e6bca3">&#9670;&nbsp;</a></span>DumpTopology() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::DumpTopology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___text_log.html">ON_TextLog</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Creates a SubD sphere with 24 quad faces Parameters: sphere - [in] Location, size and orientation of the sphere destination_subd [out] - If destination_subd is not null, make the SubD box there Returns: Pointer to the resulting SubD if successful Null for error static ON_SubD* CreateSubDSphere( const <a class="el" href="class_o_n___sphere.html">ON_Sphere</a> sphere, ON_SubD* destination_subd); Description: Creates a SubD cylinder Parameters: box - [in] Location, size and orientation of the cylinder facecount_around - [in] Number of faces around the cylinder facecount_length - [in] Number of faces in the axis direction facecouont_z - [in] Number of faces in z direction destination_subd [out] - If destination_subd is not null, make the SubD box there Returns: Pointer to the resulting SubD if successful Null for error static ON_SubD* CreateSubDCylinder( const <a class="el" href="class_o_n___cylinder.html">ON_Cylinder</a>&amp; cylinder, unsigned int facecount_around, unsigned int facecount_length, ON_SubD* destination_subd); Description: Creates a SubD cone Parameters: cone - [in] Location, size and orientation of the cone facecount_around - [in] Number of faces around the cone facecount_length - [in] Number of faces in the axis direction destination_subd [out] - If destination_subd is not null, make the SubD cone there Returns: Pointer to the resulting SubD if successful Null for error static ON_SubD* CreateSubDCone( const <a class="el" href="class_o_n___cone.html">ON_Cone</a>&amp; cone, unsigned int facecount_around, unsigned int facecount_length, ON_SubD* destination_subd); Description: Creates a SubD truncated cone Parameters: cone - [in] Location, size and orientation of the cone truncate_param - [in] 0.0 &lt; truncate_param &lt;= 1.0 Normalized parameter for truncation 0.0: Base of cone 1.0: Tip of cone facecount_around - [in] Number of faces around the cone facecount_length - [in] Number of faces in the axis direction destination_subd [out] - If destination_subd is not null, make the SubD cone there Returns: Pointer to the resulting SubD if successful Null for error static ON_SubD* CreateSubDTruncatedCone( const <a class="el" href="class_o_n___cone.html">ON_Cone</a>&amp; cone, const double truncate_param, unsigned int facecount_around, unsigned int facecount_length, ON_SubD* destination_subd); Description: Creates a SubD torus Parameters: torus - [in] Location, size and orientation of the torus major_facecount - [in] Number of faces around the major axis minor_facecount - [in] Number of faces around the minor axis destination_subd [out] - If destination_subd is not null, make the SubD torus there Returns: Pointer to the resulting SubD if successful Null for error static ON_SubD* CreaptSubDTorus( <a class="el" href="class_o_n___torus.html">ON_Torus</a>&amp; torus, unsigned int major_facecount, unsigned int minor_facecount, ON_SubD* destination_subd); </p>

</div>
</div>
<a id="a8f7d67d77d74a6ad4a82fcc722599b4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7d67d77d74a6ad4a82fcc722599b4c">&#9670;&nbsp;</a></span>EdgeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_edge_array.html">ON_SubDEdgeArray</a> ON_SubD::EdgeArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Avoid using this class. It is more efficient to use an <a class="el" href="class_o_n___sub_d_edge_iterator.html">ON_SubDEdgeIterator</a> returned by <a class="el" href="class_o_n___sub_d.html#a304d043dcf7858d62c0859c7fa42865c">EdgeIterator()</a>. </p>

</div>
</div>
<a id="ae5da40c3ae92bcbc1c0c9aac31a3d1dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5da40c3ae92bcbc1c0c9aac31a3d1dc">&#9670;&nbsp;</a></span>EdgeCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::EdgeCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edge access Returns: Number of edges in the active level. </p>

</div>
</div>
<a id="a92f58d8724ce3201056354724f658bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92f58d8724ce3201056354724f658bc0">&#9670;&nbsp;</a></span>EdgeFromComponentIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::EdgeFromComponentIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>component_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e3856d4b06981f767afe787cf54577e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3856d4b06981f767afe787cf54577e">&#9670;&nbsp;</a></span>EdgeFromId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::EdgeFromId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge_id - [in] Returns: If edge_id identifies a valid edge in this <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>, then a pointer to that edge is returned. Otherwise, nullptr is returned. </p>

</div>
</div>
<a id="a8b96a1b8c9e000a297c59242910be6b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b96a1b8c9e000a297c59242910be6b1">&#9670;&nbsp;</a></span>EdgeHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubD::EdgeHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga7901fb222b1b25e32978f0b34ba7234a">ON_SubDHashType</a>&#160;</td>
          <td class="paramname"><em>hash_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: hash_type - [in] All hashes include edge id, edge vertex ids in order, the edge crease/smooth attribute. Geometry hashes include edge displacements. Returns: A SHA1 hash of the SubD's edges. </p>

</div>
</div>
<a id="a304d043dcf7858d62c0859c7fa42865c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304d043dcf7858d62c0859c7fa42865c">&#9670;&nbsp;</a></span>EdgeIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_edge_iterator.html">ON_SubDEdgeIterator</a> ON_SubD::EdgeIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Example: <a class="el" href="class_o_n___sub_d_edge_iterator.html">ON_SubDEdgeIterator</a> eit = subd.EdgeIterator(); for ( const ON_SubDEdge* e = eit.FirstEdge(); nullptr != e; e = eit.NextEdge()) { ... } </p>

</div>
</div>
<a id="a4276ceecf5d9da29219d521c9e897313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4276ceecf5d9da29219d521c9e897313">&#9670;&nbsp;</a></span>EdgesAreConsecutive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::EdgesAreConsecutive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>eptr0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>eptr1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: True if eptr0.RelativeVetex(1) == eptr1.RelativeVetex(0) and both edges have the same set of faces. </p>

</div>
</div>
<a id="a95092a4c2ad4c34b6fdfbad6f02b878f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95092a4c2ad4c34b6fdfbad6f02b878f">&#9670;&nbsp;</a></span>EdgeTagFromContext() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> ON_SubD::EdgeTagFromContext </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd53a99331439ace74c0ac49b3918a86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd53a99331439ace74c0ac49b3918a86">&#9670;&nbsp;</a></span>EdgeTagFromContext() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> ON_SubD::EdgeTagFromContext </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>v0_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>v1_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: edge_face_count - [in] Number of faces the edge will eventually have. Pass 0 if the value is not known. v0 - [in] starting vertex v1 - [in] ending vertex Returns: If edge_face_count &gt; 0x7FFFU, then <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a> is returned.</p>
<p>If edge_face_count is 1 or &gt;= 3, then <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a> is returned.</p>
<p>If both vertex tags are <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375ae510cdf33cd497134b47b9316314d4b4">ON_SubDVertexTag::Smooth</a>, then <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ae510cdf33cd497134b47b9316314d4b4">ON_SubDEdgeTag::Smooth</a> is returned.</p>
<p>If edge_face_count is 1 and both vertex tags are <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDVertexTag::Crease</a> or <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a>, then <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a> is returned.</p>
<p>If edge_face_count is 2 and both vertex tags are set and both are not <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375ae510cdf33cd497134b47b9316314d4b4">ON_SubDVertexTag::Smooth</a>, then <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325aa53bf30b0ae3ce0512e9e9e7705423a6">ON_SubDEdgeTag::SmoothX</a> is returned.</p>
<p>Otherwise, <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a> is returned. </p>

</div>
</div>
<a id="af7fb05798d437723086ef93db64fefa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7fb05798d437723086ef93db64fefa2">&#9670;&nbsp;</a></span>EdgeTagFromUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a> ON_SubD::EdgeTagFromUnsigned </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>edge_tag_as_unsigned</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a067478a57421c549bc95103706634947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067478a57421c549bc95103706634947">&#9670;&nbsp;</a></span>EdgeTagIsSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::EdgeTagIsSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: edge_tag - [in] Returns: True if edge_tag is Smooth, Crease, Sharp, or X. False otherwise. </p>

</div>
</div>
<a id="aa4796f84493fc71b931ddbc9723a2db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4796f84493fc71b931ddbc9723a2db0">&#9670;&nbsp;</a></span>EdgeTagToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__w_string.html">ON_wString</a> ON_SubD::EdgeTagToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVertose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Paramters: edge_tag - [in] bVerbose - [in] If verbose, the tag name is preceded with "ON_SubDEdgeTag::". Returns: edge_tag as a string. </p>

</div>
</div>
<a id="a1058f674502c9091370a2114412c08bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1058f674502c9091370a2114412c08bc">&#9670;&nbsp;</a></span>EvaluatePoint()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::EvaluatePoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___obj_ref.html">ON_ObjRef</a> &amp;&#160;</td>
          <td class="paramname"><em>objref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>P</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#adcb646d6ca698c092b73f2f05373bfc2">ON_Geometry</a>.</p>

</div>
</div>
<a id="accb8987f5ddefe2a8b4f70f813938008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accb8987f5ddefe2a8b4f70f813938008">&#9670;&nbsp;</a></span>ExpandEdges() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::ExpandEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_expand_edges_parameters.html">ON_SubDExpandEdgesParameters</a>&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Typically, quads are inserted adjacent to input edges. Areas where three or more input edges meet get specialzed treatment. Useful for creating fillet and bevel like features. Parameters: unsorted_edges - [in] An unsorted set of edges. parameters - [in] </p>

</div>
</div>
<a id="a3c0f4155000807ffd72aea0b1eac5f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0f4155000807ffd72aea0b1eac5f71">&#9670;&nbsp;</a></span>ExpandEdges() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::ExpandEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>unsorted_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_expand_edges_parameters.html">ON_SubDExpandEdgesParameters</a>&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Typically, quads are inserted adjacent to input edges. Areas where three or more input edges meet get specialzed treatment. Useful for creating fillet and bevel like features. Parameters: unsorted_edges - [in] An unsorted set of edges. parameters - [in] </p>

</div>
</div>
<a id="a7d3b8b7382167167201aab69c9621e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3b8b7382167167201aab69c9621e92">&#9670;&nbsp;</a></span>ExpandEdges() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::ExpandEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_expand_edges_parameters.html">ON_SubDExpandEdgesParameters</a>&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Typically, quads are inserted adjacent to input edges. Areas where three or more input edges meet get specialzed treatment. Useful for creating fillet and bevel like features. Parameters: edges - [in] If pararameters.FaceStyle() is HalfLeft or HalfRight, then the set of edges must form a single edge chain of interior manifold edges and be correctly oriented. Otherwise edges[] is treated as an unsorted set of edges and the orientations are ignored. parameters - [in] </p>

</div>
</div>
<a id="aae13ab63601e290727592397aa636610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae13ab63601e290727592397aa636610">&#9670;&nbsp;</a></span>ExtractMarkedComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::ExtractMarkedComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga3b6aca42cfeb22b5315f542d04ba024c">ON__UINT8</a>&#160;</td>
          <td class="paramname"><em>mark_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d86e948b85ff135ca1645a2b3703493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d86e948b85ff135ca1645a2b3703493">&#9670;&nbsp;</a></span>Extrude()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::Extrude </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Extrude entire subd bay adding a ring of faces around the boundary and moving the original subd. </p>

</div>
</div>
<a id="a1ff38b984cc9b5877da935d3ef95a3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff38b984cc9b5877da935d3ef95a3b2">&#9670;&nbsp;</a></span>ExtrudeComponents() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ExtrudeComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0da5c9e01508044cc5db2772e2eceeee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da5c9e01508044cc5db2772e2eceeee">&#9670;&nbsp;</a></span>ExtrudeComponents() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ExtrudeComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bExtrudeBoundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermitNonManifoldEdgeCreation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67cf910bffc3fd80e873f360081caa7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cf910bffc3fd80e873f360081caa7d">&#9670;&nbsp;</a></span>ExtrudeComponents() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ExtrudeComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cptr_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a673961e3b9a2a8f6d68a4974e93766f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673961e3b9a2a8f6d68a4974e93766f0">&#9670;&nbsp;</a></span>ExtrudeComponents() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ExtrudeComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cptr_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bExtrudeBoundaries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermitNonManifoldEdgeCreation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa587d66b116360d6e6e8b109aa6ff43a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa587d66b116360d6e6e8b109aa6ff43a">&#9670;&nbsp;</a></span>FaceArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face_array.html">ON_SubDFaceArray</a> ON_SubD::FaceArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Avoid using this class. It is more efficient to use an <a class="el" href="class_o_n___sub_d_face_iterator.html">ON_SubDFaceIterator</a> returned by <a class="el" href="class_o_n___sub_d.html#a1584fe08574d979d876404880971d3cd">FaceIterator()</a>. </p>

</div>
</div>
<a id="afd0b2ca2e120a29e35d1a7cb2ae3a349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0b2ca2e120a29e35d1a7cb2ae3a349">&#9670;&nbsp;</a></span>FaceCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::FaceCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Face access Returns: Number of faces in the active level. </p>

</div>
</div>
<a id="ac70d637396bd1256f0bc82b125dc0171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70d637396bd1256f0bc82b125dc0171">&#9670;&nbsp;</a></span>FaceFromComponentIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::FaceFromComponentIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>component_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a986798efe2b246bf3d10f7083ba2c015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986798efe2b246bf3d10f7083ba2c015">&#9670;&nbsp;</a></span>FaceFromId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::FaceFromId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>face_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: face_id - [in] Returns: If face_id identifies a valid face in this <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>, then a pointer to that face is returned. Otherwise, nullptr is returned. </p>

</div>
</div>
<a id="aa95b59a21f20e65eda6bfeda262ee848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95b59a21f20e65eda6bfeda262ee848">&#9670;&nbsp;</a></span>FaceHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubD::FaceHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga7901fb222b1b25e32978f0b34ba7234a">ON_SubDHashType</a>&#160;</td>
          <td class="paramname"><em>hash_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: hash_type - [in] Returns: A SHA1 hash of the SubD's faces. </p>

</div>
</div>
<a id="a1584fe08574d979d876404880971d3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1584fe08574d979d876404880971d3cd">&#9670;&nbsp;</a></span>FaceIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face_iterator.html">ON_SubDFaceIterator</a> ON_SubD::FaceIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Example: <a class="el" href="class_o_n___sub_d_face_iterator.html">ON_SubDFaceIterator</a> fit = subd.FaceIterator(); for ( const ON_SubDFace* f = fit.FirstFace(); nullptr != f; f = fit.NextFace()) { ... } </p>

</div>
</div>
<a id="a35e1be9442ba79f4f717cad5d62b49c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e1be9442ba79f4f717cad5d62b49c9">&#9670;&nbsp;</a></span>FacePackingId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> ON_SubD::FacePackingId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: An id that identifies the algorithm used to pack the faces in this subd. </p>

</div>
</div>
<a id="a97d9159a92026d46817fcc09b8ac5229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d9159a92026d46817fcc09b8ac5229">&#9670;&nbsp;</a></span>FacePackingIsValid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::FacePackingIsValid </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIfValidThenUpdateFacePackingTopologyHash</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Validates the face packing.</p>
<p>If a face pack contains more than one face, then all of the following are required for that face pack to be valid.</p><ul>
<li>Every face in the pack is a quad.</li>
<li>The quads form a rectangular grid.</li>
<li>All faces in the rectangular grid are quads.</li>
<li>All interior edges in the rectangular grid are smooth.</li>
<li>All interior vertices in the rectangular grid are smooth and have 4 edge and 4 faces.</li>
<li>All edges on the sides of the rectangular grid are either creases or are attached to exactly one face in the rectangular grid.</li>
</ul>
<p>Parameters: bPermitWrapping - [in] If true, then the face pack is allowed to wrap. For example, if bPermitWrapping is true, then a SubD cylinder that is a regular quad grid can have a single face pack. bIfValidThenUpdateFacePackingTopologyHash - [in] When in doubt, pass false to test if all of the current face packing information is completely valid.</p>
<p>If you are using an add/remove creases edit approach to modify an initially valid packing, then pass true. Otherwise pass false.</p>
<p>If this parameter is true, the packing is valid, and this-&gt;FacePackingSubDTopologyHash() does not match this-&gt;SubDTopologyHash(), then this-&gt;FacePackingSubDTopologyHash() is updated to the current value of this-&gt;SubDTopologyHash().</p>
<p>If this paramter is false and and this-&gt;FacePackingSubDTopologyHash() does not match this-&gt;SubDTopologyHash(), then the function returns false. Returns: True if <a class="el" href="class_o_n___sub_d.html#a33584a16cca239644a5be3ab243f1d14">FacesArePacked()</a> is true, the quad grids meet all the conditions described above, this-&gt;<a class="el" href="class_o_n___sub_d.html#a35e1be9442ba79f4f717cad5d62b49c9">FacePackingId()</a> is not nil, and either this-&gt;FacePackingSubDTopologyHash() is equal to this-&gt;SubDTopologyHash() or bIfValidThenUpdateFacePackingTopologyHash is true. </p>

</div>
</div>
<a id="ae32373a2c26ae53a008f9f717919d9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae32373a2c26ae53a008f9f717919d9a7">&#9670;&nbsp;</a></span>FacePackingTopologyHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_hash.html">ON_SubDHash</a> ON_SubD::FacePackingTopologyHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: The value of ON_SubDHash::Create(ON_SubDHashType::TopologyAndEdgeCrease, *this) when the faces were packed. </p>

</div>
</div>
<a id="a33584a16cca239644a5be3ab243f1d14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33584a16cca239644a5be3ab243f1d14">&#9670;&nbsp;</a></span>FacesArePacked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::FacesArePacked </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if every face has a nonzero PackId and a set PackRect. </p>

</div>
</div>
<a id="aa2083fce55da4501da8c2df12f8811f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2083fce55da4501da8c2df12f8811f7">&#9670;&nbsp;</a></span>FindEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubD::FindEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Search for an edge connecting v0 and v1. Parameters: v0 - [in] v1 - [in] The edge begins at v0 and ends at v1. The edge will be on the same level as the vertices. Returns: An <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> to a connecting edge or <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> if none exists. </p>

</div>
</div>
<a id="ae83f35ec8dcb63f07a198b209d6046c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae83f35ec8dcb63f07a198b209d6046c3">&#9670;&nbsp;</a></span>FindOrAddEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubD::FindOrAddEdge </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Search for an edge connecting v0 and v1. If none exists, then add one. Parameters: v0 - [in] v1 - [in] The edge begins at v0 and ends at v1. The edge will be on the same level as the vertices. Returns: An <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> to a connecting edge or <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> if none exists. </p>

</div>
</div>
<a id="a8c40b95139bd90083c50393d78b0a3ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c40b95139bd90083c50393d78b0a3ed">&#9670;&nbsp;</a></span>FindOrAddFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::FindOrAddFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>new_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>face_vertices</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>face_vertex_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Finds an existing face or adds a new face with corners at face_vertices[]. Parameters: new_edge_tag - [in] If an edge needs to be added, this tag is assigned to the new edge. When in doubt, pass <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a> and call this-&gt;UpdateAllTagsAndSectorCoefficients(true) after you are finished modifying the SubD. face_vertices - [in] Array of vertices at the face corners in counter-clockwise order. face_vertex_count - [in] Number of vertices in face_vertices[] Returns: If the input is not valid, nullptr is returned. If there is a face with the specified corners exists, then it is returned. Otherwise a new face is added and returned. </p>

</div>
</div>
<a id="a64138b0bcf8e0b791a2c526114941ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64138b0bcf8e0b791a2c526114941ed8">&#9670;&nbsp;</a></span>FindOrAddVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::FindOrAddVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *&#160;</td>
          <td class="paramname"><em>control_net_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Search for a vertex with a specificed control net point. If one does not exist, add a new one. Parameters: control_net_point - [in] Look for a vertex with this value for ControlNetPoint(). tolerance - [in] Use 0.0 when in doubt. If &gt; 0.0, then the vertex closest to control_net_point will be returned if the distance from that vertex to control_net_point is &lt;= distance_tolerance. Returns: An <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> pointer or nullptr if none exists. </p>

</div>
</div>
<a id="aee8210fce6b1e365c51b623ab2c2e9f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8210fce6b1e365c51b623ab2c2e9f4">&#9670;&nbsp;</a></span>FindVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::FindVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *&#160;</td>
          <td class="paramname"><em>control_net_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Search for a vertex with a specificed control net point. Parameters: control_net_point - [in] Look for a vertex with this value for ControlNetPoint(). tolerance - [in] Use 0.0 when in doubt. If &gt; 0.0, then the vertex closest to control_net_point will be returned if the distance from that vertex to control_net_point is &lt;= distance_tolerance. Returns: An <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> pointer or nullptr if none exists. </p>

</div>
</div>
<a id="a650426a4aec98892ea13ea36328082e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650426a4aec98892ea13ea36328082e3">&#9670;&nbsp;</a></span>FirstEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::FirstEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37fdfc8a70690725734fb6dee5ff3e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37fdfc8a70690725734fb6dee5ff3e54">&#9670;&nbsp;</a></span>FirstFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::FirstFace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90f419c300415321b26bb9b40647df86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f419c300415321b26bb9b40647df86">&#9670;&nbsp;</a></span>FirstVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::FirstVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7465243080b065bff2748d7197a83f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7465243080b065bff2748d7197a83f58">&#9670;&nbsp;</a></span>FragmentColorsMappingTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> ON_SubD::FragmentColorsMappingTag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: The current fragment vertex colors mapping tag. </p>

</div>
</div>
<a id="ad7149920a9bed945f7e368b0e5cb21ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7149920a9bed945f7e368b0e5cb21ee">&#9670;&nbsp;</a></span>FragmentColorsSettingsHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubD::FragmentColorsSettingsHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: hash identifying the way the fragment vertex colors were set. </p>

</div>
</div>
<a id="a7df5adfe19107926126f077722831b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df5adfe19107926126f077722831b50">&#9670;&nbsp;</a></span>FragmentTextureCoordinatesTextureSettingsHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubD::FragmentTextureCoordinatesTextureSettingsHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: The value of ON_SubD::TextureSettingsHash(texture_coordinate_type,texture_mapping_tag) for the texture_coordinate_type and texture_mapping_tag used to set the current fragment texture coordinates. If no fragments exist or the coordinates are not set, then <a class="el" href="class_o_n___s_h_a1___hash.html#a5fbd8257f1b9c3fdfc929d3869113924" title="SHA-1 hash of zero bytes.">ON_SHA1_Hash::EmptyContentHash</a> is returned. </p>

</div>
</div>
<a id="ad1ad6d6d37db0ca96497b734526b42a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ad6d6d37db0ca96497b734526b42a6">&#9670;&nbsp;</a></span>FragmentTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* ON_RTreeRef ON_SubD::FragmentTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae07d885e05ed47e9ed99ef3428814c07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07d885e05ed47e9ed99ef3428814c07">&#9670;&nbsp;</a></span>GeometryContentSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a> ON_SubD::GeometryContentSerialNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: A runtime serial number that is changed every time a the active level, vertex location, vertex or edge flag, or subd topology is changed. </p>

</div>
</div>
<a id="a8ddfa18eda363a886e80542319129578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddfa18eda363a886e80542319129578">&#9670;&nbsp;</a></span>GeometryHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubD::GeometryHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If two SubDs have identical values of <a class="el" href="class_o_n___sub_d.html#a8ddfa18eda363a886e80542319129578">GeometryHash()</a>, then they have identical surface geometry. Returns: this-&gt;SubDHash(ON_SubDHashType::Geometry,false).<a class="el" href="class_o_n___sub_d.html#a753cbf6fa759787e06c54e4c76f6a702">SubDHash()</a>. Remarks: If the geometry hashes are equal, the topology hashes are equal. </p>

</div>
</div>
<a id="a3ce3c25318be659eff5607e1df04d008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce3c25318be659eff5607e1df04d008">&#9670;&nbsp;</a></span>GetBBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GetBBox </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>boxmin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>boxmax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGrowBox</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> GetBBox override <br  />
 </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#ad615e08fe92af659c8d10cbb4f8fc5e3">ON_Geometry</a>.</p>

</div>
</div>
<a id="af96e32c6c7de19b165f10f85a29f5af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96e32c6c7de19b165f10f85a29f5af6">&#9670;&nbsp;</a></span>GetBoundaryEdgeChain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::GetBoundaryEdgeChain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>first_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseEdgeMarks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_edge_chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Automatically get a boundary from a seed edge. Parameters: first_edge - [in] An edge with <a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> &lt;= 1. The search for the second edge occurs and first_edge.RelativeVertex(1) and all edges added to boundary_edge_chain[] have <a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> = first_edge.Edge()-&gt;<a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a>. bUseEdgeMarks -[in] If true, only unmarked edges will be added to boundary_edge_chain[] and they will be marked when added to boundary_edge_chain[]. boundary_edge_chain - [out] Edge chain beginning with first_edge. When true is returned, boundary_edge_chain[] has 3 or more edges and is a closed loop. When false is returned, boundary_edge_chain[] will contain an open chain with 0 or more edges. Returns: true if boundary_edge_chain[] is a closed loop of 3 or more boundary edges. </p>

</div>
</div>
<a id="a8bdbbe6aefba0a006a5e7ac097691882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bdbbe6aefba0a006a5e7ac097691882">&#9670;&nbsp;</a></span>GetBoundaryEdgeChains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetBoundaryEdgeChains </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maximum_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_edge_chains</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: minimum_face_count - [in] maximum_face_count - [in] Only edges with edge-&gt;<a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> &gt;= minimum_face_count and edge-&gt;<a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> &lt;= maximum_face_count will be converted into curves. Pass 0, <a class="el" href="class_o_n___sub_d_edge.html#a2c4a15dc103922ae27e00f45df854d15ab14a1da83370eeb51e6fec74230b4a74">ON_SubDEdge::MaximumFaceCount</a> if you want all possible boundary edge chains. boundary_edge_chains - [out] The boundary_edge_chains[] array is sorted into edge chains. Returns: Number of chains embedded in boundary_edge_chains[] </p>

</div>
</div>
<a id="ad67b9add6051da22ab993c305b002471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67b9add6051da22ab993c305b002471">&#9670;&nbsp;</a></span>GetComponentStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetComponentStatus </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGetVertexStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGetEdgeStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGetFaceStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>status_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>status_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Save the current component status of the indictated subd components. Parameters: bGetVertexStatus - [in] bGetEdgeStatus - [in] bGetFaceStatus - [in] bClearStatus - [in] If true, the bits in status_mask will also be cleared for the components. status_mask - [in] Status bits to save. component_list - [out] status_list - [out] component_list[] and status_list[] are parallel arrays for components with a matching status bit set. </p>

</div>
</div>
<a id="a719e30ea56a1b5ed36141f0a22c5ef6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719e30ea56a1b5ed36141f0a22c5ef6d">&#9670;&nbsp;</a></span>GetComponentsWithSetStates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetComponentsWithSetStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>states_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllEqualStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>components</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a691de6470e814973858aa5c51eaffa77">ON_Object</a>.</p>

</div>
</div>
<a id="af0c90f41c021cf62f1576f19d5b94175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0c90f41c021cf62f1576f19d5b94175">&#9670;&nbsp;</a></span>GetComponentsWithSetStates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetComponentsWithSetStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>states_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAllEqualStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>components_with_set_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Component (vertex, edge, face) state ( selected, highlighted, ... ) tools NOTE: All component status settings are mutable All are copied. None are saved. Parameters: states_filter - [in] bAllEqualStates - [in] If a state is set in states_filter, all active level components with the same state set will be included in the components_with_set_states[] array. <br  />
 If bAllEqualStates is true, then <a class="el" href="class_o_n___component_status.html#a07a7df4fb56e8d9a0f894078e95800d5">ON_ComponentStatus::AllEqualStates()</a> is used to test for inclusion. <br  />
 If bAllEqualStates is false, then <a class="el" href="class_o_n___component_status.html#ae0fdd7626cf0af0eee9c1a6bb68768a2">ON_ComponentStatus::SomeEqualStates()</a> is used to test for inclusion. components_with_set_states - [out] Returns: Number of returned components. </p>

</div>
</div>
<a id="aa142a25b13fa107f35eebcf57d81fd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa142a25b13fa107f35eebcf57d81fd54">&#9670;&nbsp;</a></span>GetConnectedRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetConnectedRegions </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bManifoldRegions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>connected_regions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If this subd has two or more connected regions, create a new subd for each connected region. Parameters: bManifoldRegions - [in] If true, the connected regions will stop at nonmanifold vertices and nonmanifold edges. connected_components - [out] If there are two or more connected regions, they are appended to connected_regions[] Returns: Number of connected components appended to connected_components[]. </p>

</div>
</div>
<a id="a1cd222f967bbbce9f430011e8f5636e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cd222f967bbbce9f430011e8f5636e4">&#9670;&nbsp;</a></span>GetControlNetMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_SubD::GetControlNetMesh </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga870f5c5708f131b6a2bdf3d138607fd9">ON_SubDGetControlNetMeshPriority</a>&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a mesh representation of the <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> control net. Parameters: mesh - [in] If not null, the returned mesh will be stored on the input class.</p>
<p>priority - [in] Specifies what type of SubD information is most important to transfer to the mesh. For more details, see the comments for ON_SubDGetControlNetMeshPriority.</p>
<p>Returns: A mesh representation of the <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> control net. </p>

</div>
</div>
<a id="a274c1b5f9e52b7d827f7e7071fca66b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274c1b5f9e52b7d827f7e7071fca66b6">&#9670;&nbsp;</a></span>GetMarkedComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetMarkedComponents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAddMarkedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga3b6aca42cfeb22b5315f542d04ba024c">ON__UINT8</a>&#160;</td>
          <td class="paramname"><em>mark_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; class <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: bAddMarkedComponents - [in] If true, marked components are added to component_list[]. If false, unmarked components are added to component_list[]. mark_bits - [in] If mark_bits is zero, then a component is "marked" if component.Mark() is true. Otherwise a component is "marked" if mark_bits = component.MarkBits(). </p>

</div>
</div>
<a id="a52e477b81ca2cff783f48532a2634f2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e477b81ca2cff783f48532a2634f2b">&#9670;&nbsp;</a></span>GetMarkedComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetMarkedComponents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIncludeFaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_component_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e6ebb34429c0c98d75c37e0dce9019e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e6ebb34429c0c98d75c37e0dce9019e">&#9670;&nbsp;</a></span>GetMeshFragments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetMeshFragments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_display_parameters.html">ON_SubDDisplayParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>display_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ON__UINT_PTR&#160;</td>
          <td class="paramname"><em>fragment_callback_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_mesh_fragment.html">ON_SubDMeshFragment</a> *)&#160;</td>
          <td class="paramname"><em>fragment_callback_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the limit surface mesh as a set of fragments. Parameters: display_parameters - [in]</p>
<p>fragment_callback_context - [in] first parameter for the FragmentCallback function</p>
<p>fragment_callback_function - [in] A function pointer with prototype:</p>
<p>bool fragment_callback_function( void <em>fragment_callback_context, const class <a class="el" href="class_o_n___sub_d_mesh_fragment.html">ON_SubDMeshFragment</a></em> fragment );</p>
<p>For each fragment that is produced, fragment_callback_function() is called. You must copy the retuned fragment if you want to keep it for future use. If fragment_callback_function returns false, the calculation is canceled. Returns: Number of fragments produced. </p>

</div>
</div>
<a id="a705058bd9a47a3bec2ae81aa406f3ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a705058bd9a47a3bec2ae81aa406f3ded">&#9670;&nbsp;</a></span>GetQuadSectorPointRing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::GetQuadSectorPointRing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFirstPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSecondPass</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>point_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: subd_type - [in] A quad based subdivision algorithm. bFirstPass - [in] If bFirstPass is true and the components are in standard form for the vertex and subdivision type, then locations of the component vertices opposite the center vertex are returned in the point ring. bSecondPass - [in] If bSecondtPass is true and the first pass is disable or does not succeed, then the component subdivision locations are returned in the point ring. vertex0 - [in] If not null, then vertex0-&gt;m_edges and vertex0-&gt;m_faces must be radially sorted and span a single sector and component_ring[] is ignored. component_ring_count - [in] If vertex0 is null, then component_ring_count specifies the number of components in the component_ring[] array. component_ring[] - [in] If vertex0 is null, then component_ring[0] is the central vertex, component_ring[1] and subsequent components with odd indices are sector edges, component_ring[2] and subsequent components with even indices are sector faces, all sorted radially. point_ring_stride - [in] point_ring - [out] point locations are returned here. Returns: Number of points in the subdivision ring or 0 if the call fails. The number of points is 1 + ON_SubD::ComponentRingEdgeCount(component_ring_count) + ON_SubD::ComponentRingFaceCount(component_ring_count). Remarks: No validation checking is performed. This function will crash if the input is not valid. Call GetSubdivisionPointRing() if you want a crash proof call. </p>

</div>
</div>
<a id="aa1879f6e2db9595b151662f3d3abdb50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1879f6e2db9595b151662f3d3abdb50">&#9670;&nbsp;</a></span>GetSectorComponentRing() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::GetSectorComponentRing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_ring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: sit - [in] vertex sector iterator component_ring - [out] A sorted listof <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> values are returned in component_ring[]</p>
<p>Returns: Number of components set in component_ring[].</p>
<p>0: failure</p>
<p>&gt;= 4 and even: component_ring[0] = vit.CenterVertex() component_ring[1] = starting crease edge component_ring[2] = starting face ... zero or more interior smooth edge, face pairs ... component_ring[component_count-1] = ending crease edge</p>
<p>&gt;= 5 and odd: component_ring[0] = center vertex component_ring[1] = first edge (smooth) component_ring[2] = first face ... zero or more smooth edge, face, pairs ... component_ring[component_count-2] = last edge (smooth) component_ring[component_count-1] = last face</p>
<p>Example: unsigned int component_ring_count = GetVertexComponentRing(vit,component_ring); unsigned int N = component_ring_count/2; ///&lt; number of edges in ring const bool bSectorHasCreaseBoundary = (0 == (component_ring_count % 2)); </p>

</div>
</div>
<a id="aea6fa647489a336e4a646cc81bba8f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6fa647489a336e4a646cc81bba8f9b">&#9670;&nbsp;</a></span>GetSectorComponentRing() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::GetSectorComponentRing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: sit - [in] vertex sector iterator component_ring - [out] A sorted list of <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> values are returned in component_ring[] component_ring[0] is the central vertex. component_ring[1] and subsequent components with odd indices are sector edges. component_ring[2] and subsequent components with even indices are sector faces. For edge components (i is odd), component_ring[i].ComponentMark() is the index of the center vertex in ON_SubDEge.m_vertex[]. component_ring_capacity - [in] capacity of component_ring[] array 1 + center_vertex.m_edge_count + center_vertex.m_face_count will be large enough. Returns: Number of components set in component_ring[].</p>
<p>0: failure</p>
<p>&gt;= 4 and even: component_ring[0] = center vertex component_ring[1] = starting crease edge component_ring[2] = starting face ... zero or more interior smooth edge, face pairs ... component_ring[component_count-1] = ending crease edge</p>
<p>&gt;= 5 and odd: component_ring[0] = vit.CenterVertex() component_ring[1] = first edge (smooth) component_ring[2] = first face ... zero or more smooth edge, face, pairs ... component_ring[component_count-2] = last edge (smooth) component_ring[component_count-1] = last face</p>
<p>Example: unsigned int component_ring_count = GetVertexComponentRing(vit,component_ring); unsigned int N = component_ring_count/2; ///&lt; number of edges in ring const bool bSectorHasCreaseBoundary = (0 == (component_ring_count % 2)); </p>

</div>
</div>
<a id="ad3f81ea18d9ad1c91ae79fd49bd921d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3f81ea18d9ad1c91ae79fd49bd921d3">&#9670;&nbsp;</a></span>GetSectorPointRing() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::GetSectorPointRing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSubdivideIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>point_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bbb84714f1d77312b9dedd3f65764bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bbb84714f1d77312b9dedd3f65764bf">&#9670;&nbsp;</a></span>GetSectorPointRing() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::GetSectorPointRing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSubdivideIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_sector_iterator.html">ON_SubDSectorIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>sit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_ring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a348cc3cde6a65b8dfac76796f02bb510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348cc3cde6a65b8dfac76796f02bb510">&#9670;&nbsp;</a></span>GetSectorPointRing() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::GetSectorPointRing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSubdivideIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>subd_point_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subd_point_ring_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>subd_point_ring_stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd32809ce5ea79039aa5ccf5251e0530"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd32809ce5ea79039aa5ccf5251e0530">&#9670;&nbsp;</a></span>GetSectorPointRing() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::GetSectorPointRing </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSubdivideIfNeeded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point_ring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb682e5c3f906ddfb393418feea72a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb682e5c3f906ddfb393418feea72a2c">&#9670;&nbsp;</a></span>GetSectorSubdivisionPointRing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::GetSectorSubdivisionPointRing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subd_point_ring</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a41f99166629e3a016610cde5e26e9ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f99166629e3a016610cde5e26e9ab5">&#9670;&nbsp;</a></span>GetSectorSubdivsionPointRing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int ON_SubD::GetSectorSubdivsionPointRing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>point_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>point_ring_stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: Number of points in the subdivision ring or 0 if the call fails. </p>

</div>
</div>
<a id="a64c6cb08739888547abb010c18a45a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64c6cb08739888547abb010c18a45a90">&#9670;&nbsp;</a></span>GetSurfaceBrep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___brep.html">ON_Brep</a>* ON_SubD::GetSurfaceBrep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_to_brep_parameters.html">ON_SubDToBrepParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>brep_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td>
          <td class="paramname"><em>destination_brep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a brep representation of the SubD. Parameters: brep_parameters - [in] </p>

</div>
</div>
<a id="a291fbf37c80259b898352d90d7b4d70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a291fbf37c80259b898352d90d7b4d70e">&#9670;&nbsp;</a></span>GetSurfaceMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a>* ON_SubD::GetSurfaceMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_display_parameters.html">ON_SubDDisplayParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>display_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> *&#160;</td>
          <td class="paramname"><em>mesh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get an <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> of the subdivision limit surface Parameters: display_parameters - [in] mesh - [in] If not null, the returned mesh will be stored on the input class. Returns: A mesh of the subdivision limit surface. </p>

</div>
</div>
<a id="ae00f960eb4cdb632a0b48eed19f0d292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00f960eb4cdb632a0b48eed19f0d292">&#9670;&nbsp;</a></span>GetSurfaceNurbs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetSurfaceNurbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b">ON_SubD::NurbsSurfaceType</a>&#160;</td>
          <td class="paramname"><em>nurbs_surface_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ON__UINT_PTR&#160;</td>
          <td class="paramname"><em>callback_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face_region.html">ON_SubDFaceRegion</a> &amp;, class <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> *)&#160;</td>
          <td class="paramname"><em>nurbs_callback_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the SubD limit surface as bicubic NURBS surfaces.</p>
<p>Parameters: nurbs_surface_type - [in] Controls the size and knot properties of the returned NURBS sufaces.</p>
<p>callback_context - [in] first parameter for the callback functions</p>
<p>nurbs_callback_function - [in] nullptr or a function pointer with prototype:</p>
<p>bool nurbs_callback_function( ON__UINT_PTR callback_context, const <a class="el" href="class_o_n___sub_d_component_region.html">ON_SubDComponentRegion</a>&amp; subd_face_region, const <a class="el" href="class_o_n___sub_d_component_region.html">ON_SubDComponentRegion</a> subd_edge_region[4], const class ON_NurbsSurface*&amp; nurbs_surface );</p>
<p>For each NURBS surface that is produced, nurbs_callback_function() is called.</p>
<p>subd_face_region identifies the region of the SubD that this NURBS surface models.</p>
<p>subd_edge_region[4] identifies the edges the NURBS surface abuts in the order South,East,North,West.</p>
<p>When an edge is a subdivision edge, then subd_edge_region[i].m_level0_component.ComponentType() is <a class="el" href="class_o_n___sub_d_component_ptr.html#a421eef62952e9be0de744341607a2c8dae4a297a0f76119a442c2595ac040673e">ON_SubDComponentPtr::Type::Edge</a>, subd_edge_region[i].m_level0_component.ComponentBase() is nullptr, and <a class="el" href="class_o_n___sub_d_component_region.html#ab143e85bc505d6eb3b956a8253f99c5e">ON_SubDComponentRegion::IsTransientId</a>(subd_edge_region[i].m_level0_component_id) is true</p>
<p>The nurbs_surface pointer points to an <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> on the heap. You must take responsibility for managing this surface and deleting it at the appropriate time.</p>
<p>Returns: Number of NURBS surfaces returned. </p>

</div>
</div>
<a id="ae9a484806f2c1bb5f03768a0f3d228c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a484806f2c1bb5f03768a0f3d228c3">&#9670;&nbsp;</a></span>GetSurfaceNurbs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetSurfaceNurbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b">ON_SubD::NurbsSurfaceType</a>&#160;</td>
          <td class="paramname"><em>nurbs_surface_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___nurbs_surface.html">ON_NurbsSurface</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the SubD limit surface as a list of bicubic NURBS patches. Parameters: nurbs_surface_type - [in] Controls the size and knot properties of the returned NURBS sufaces. patches - [out] The bicubic NURBS patches are appended to this array. Returns: Number of patches appended to patches[] </p>

</div>
</div>
<a id="ac290009042b3e05cbc26e2d8b5c3113f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac290009042b3e05cbc26e2d8b5c3113f">&#9670;&nbsp;</a></span>GetSurfaceNurbs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetSurfaceNurbs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a846f70b68ad8e33519d6e1293470e42b">ON_SubD::NurbsSurfaceType</a>&#160;</td>
          <td class="paramname"><em>nurbs_surface_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_face_region_and_nurbs.html">ON_SubDFaceRegionAndNurbs</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>patches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae302078b9174b39d1332120b5c56c74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae302078b9174b39d1332120b5c56c74a">&#9670;&nbsp;</a></span>GetSurfaceNurbsFragments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetSurfaceNurbsFragments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_display_parameters.html">ON_SubDDisplayParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>display_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ON__UINT_PTR&#160;</td>
          <td class="paramname"><em>callback_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face_region.html">ON_SubDFaceRegion</a> &amp;)&#160;</td>
          <td class="paramname"><em>begin_face_callback_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_surface_nurbs_fragment.html">ON_SubDSurfaceNurbsFragment</a> *)&#160;</td>
          <td class="paramname"><em>fragment_callback_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the limit surface as a set of bicubic patch fragments. Parameters: display_parameters - [in]</p>
<p>callback_context - [in] first parameter for the callback functions</p>
<p>begin_face_callback_function - [in] nullptr or a function pointer with prototype:</p>
<p>bool begin_face_callback_function( void *fragment_callback_context, const class <a class="el" href="class_o_n___sub_d_face_region.html">ON_SubDFaceRegion</a>&amp; face_region, );</p>
<p>At the beginning of each quad face, this function is called. If the original SubD face is a quad, then face_region identifies that quad. If the original SubD face is not a quad, then face_region identifies the level 1 subdivision quad. The face region information is useful in building a correspondence between the original SubD and the Nurbs patches. If begin_face_callback_function returns false, the calculation is canceled.</p>
<p>fragment_callback_function - [in] A function pointer with prototype:</p>
<p>bool fragment_callback_function( void <em>fragment_callback_context, const class <a class="el" href="class_o_n___sub_d_surface_nurbs_fragment.html">ON_SubDSurfaceNurbsFragment</a></em> fragment );</p>
<p>For each fragment that is produced, fragment_callback_function() is called. You must copy the retuned fragment if you want to keep it for future use. If fragment_callback_function returns false, the calculation is canceled. Returns: Number of fragments produced. </p>

</div>
</div>
<a id="a893599c3cc818e97f43cd1444b64e883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893599c3cc818e97f43cd1444b64e883">&#9670;&nbsp;</a></span>GetSurfacePointLinearSystem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GetSurfacePointLinearSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___matrix.html">ON_Matrix</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the system of linear equations that calculate vertex limit point locations from the corresponding ring vertices's control net points in matrix form. Parameters: m - [out] v - [out] v[i] limit point = sum( 0 &lt;= j &lt; v.Count() of m[i][j]*v[j]-&gt;ContolNetPoint() ) Returns: True if the linear system could be calculated and is square. </p>

</div>
</div>
<a id="a5c89b2ef8a43089d35021333833df2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c89b2ef8a43089d35021333833df2b2">&#9670;&nbsp;</a></span>GetSurfacePointLinearSystem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GetSurfacePointLinearSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_vertex_surface_point_coefficient.html">ON_SubDVertexSurfacePointCoefficient</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__2udex.html">ON_2udex</a> *&#160;</td>
          <td class="paramname"><em>coefficient_matrix_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the system of linear equations that calculate vertex limit point locations from the corresponding ring vertices's control net points. This information is useful when solving location interpolation problems. Parameters: coefficients - [out] The returned array is sorted by <a class="el" href="class_o_n___sub_d_vertex_surface_point_coefficient.html#ad2da3d40f34e0828ba31124d2cd6d1f9">ON_SubDVertexSurfacePointCoefficient::CompareSurfacePointAndRingVertexId()</a>. If (coefficients[i0],....,coefficients[i1]) is the set of all coefficients with the same value of <a class="el" href="class_o_n___sub_d_vertex_surface_point_coefficient.html#a725b0720bf9eda62179ce932f27076dd">ON_SubDVertexSurfacePointCoefficient.m_limit_point_vertex</a>, then the location of the limit point for that vertex is the sum of coefficients[i].m_c*coefficients[i].m_ring_vertex-&gt;ControlNetPoint() where (i0 &lt;= i &lt;= i1). coefficient_matrix_size - [out] If not nullptr, then coefficient_matrix_size-&gt;i = number of unique m_limit_point_vertex values in coefficients[] and coefficient_matrix_size-&gt;j = number of unique m_ring_vertex values in coefficients[]. If this SubD is valid, then both of these numbers are this-&gt;<a class="el" href="class_o_n___sub_d.html#ae18dfbfc1090b4d0f6755e73e034bdfa">VertexCount()</a>. Put another way, if this SubD is valid, the linear system of equations can be represented by an NxN matrix where N = this-&gt;<a class="el" href="class_o_n___sub_d.html#ae18dfbfc1090b4d0f6755e73e034bdfa">VertexCount()</a>. Returns: True if the linear system could be calculated. </p>

</div>
</div>
<a id="a87a1af4bdd509207d564895b180fbee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a1af4bdd509207d564895b180fbee2">&#9670;&nbsp;</a></span>GetSurfaceWireframe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetSurfaceWireframe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maximum_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a>&#160;</td>
          <td class="paramname"><em>chain_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ON__UINT_PTR&#160;</td>
          <td class="paramname"><em>curve_callback_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *, unsigned int, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> &amp;)&#160;</td>
          <td class="paramname"><em>curve_callback_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a collection of NURBS curves that lie on the SubD limit surface edges. Parameters: edge_tag - [in] If edge_tag is not <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a>, then only edges with a matching tag will be converted to curves. minimum_face_count - [in] maximum_face_count - [in] Only edges with edge-&gt;<a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> &gt;= minimum_face_count and edge-&gt;<a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> &lt;= maximum_face_count will be converted into curves. Pass 0, <a class="el" href="class_o_n___sub_d_edge.html#a2c4a15dc103922ae27e00f45df854d15ab14a1da83370eeb51e6fec74230b4a74">ON_SubDEdge::MaximumFaceCount</a> if you want all possible face counts. chain_type - [in] Controls which edges joined into a single curves. <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubD::ChainType::Unset</a> will create one curve per edge. curve_callback_context - [in] curve_callback_function - [in] Each curve is returned by calling curve_callback_function(curve_callback_context,edge_chain_count,edge_chain,nurbs_curve). The function curve_callback_function() must copy any information it wants to reference later. It returns true to continue, false to terminate <a class="el" href="class_o_n___sub_d.html#a87a1af4bdd509207d564895b180fbee2">GetSurfaceWireframe()</a>. edge_chain[] reports which edges are represented byt nurbs_curve Returns: Number of curves generated. <br  />
 </p>

</div>
</div>
<a id="a32170768f1d7c1c3b181b462aa1aee11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32170768f1d7c1c3b181b462aa1aee11">&#9670;&nbsp;</a></span>GetSurfaceWireframe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetSurfaceWireframe </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maximum_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a>&#160;</td>
          <td class="paramname"><em>chain_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___nurbs_curve.html">ON_NurbsCurve</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nurbs_curves</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a collection of NURBS curves that lie on the SubD limit surface edges. Parameters: edge_tag - [in] If edge_tag is not <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a>, then only edges with a matching tag will be converted to curves. minimum_face_count - [in] maximum_face_count - [in] Only edges with edge-&gt;<a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> &gt;= minimum_face_count and edge-&gt;<a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> &lt;= maximum_face_count will be converted into curves. Pass 0, <a class="el" href="class_o_n___sub_d_edge.html#a2c4a15dc103922ae27e00f45df854d15ab14a1da83370eeb51e6fec74230b4a74">ON_SubDEdge::MaximumFaceCount</a> if you want all possible face counts. chain_type - [in] Controls which edges joined into a single curves. <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubD::ChainType::Unset</a> will create one curve per edge. curves - [out] The wireframe curves are appended to curves[]. The caller is responsible for deleting them. Returns: Number of curves appended to nurbs_curves. <br  />
 </p>

</div>
</div>
<a id="a0158d58e11c6a527ae1a4368445b92aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0158d58e11c6a527ae1a4368445b92aa">&#9670;&nbsp;</a></span>GetSymmetrySet() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::GetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>cptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMotifFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_symmetry_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the component's symmetry set. Parameters: component - [in] bMotifFirst - [in] If true, component_symmetry_set[0] will be the primary motif component. Otherwise, component_symmetry_set[0] will point to cptr.ComponentBase(). component_symmetry_set - [out] The symmetry set containing the component. The motif component has 1 = <a class="el" href="class_o_n___sub_d_component_ptr.html#a96a15b9a48cf439a0643aea83a4da039">ON_SubDComponentPtr.ComponentDirection()</a>. The other components have 0 = <a class="el" href="class_o_n___sub_d_component_ptr.html#a96a15b9a48cf439a0643aea83a4da039">ON_SubDComponentPtr.ComponentDirection()</a>. Returns: Number of vertices in the symmetry set. </p>

</div>
</div>
<a id="abe89d793bf2e2a331838cc71c18f376a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe89d793bf2e2a331838cc71c18f376a">&#9670;&nbsp;</a></span>GetSymmetrySet() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::GetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPrimaryMotifFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_symmetry_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the edge's symmetry set. Parameters: edge - [in] edge_symmetry_set - [out] The symmetry set containing the edge. bPrimaryMotifFirst - [in] If true, edge_symmetry_set[0] will be the primary motif edge. Otherwise, edge_symmetry_set[0] will be edge. Returns: Number of vertices in the symmetry set. </p>

</div>
</div>
<a id="a5014810971696f50a6fb0389f8af8ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5014810971696f50a6fb0389f8af8ccd">&#9670;&nbsp;</a></span>GetSymmetrySet() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::GetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPrimaryMotifFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_symmetry_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the face's symmetry set. Parameters: face - [in] face_symmetry_set - [out] The symmetry set containing the face. bPrimaryMotifFirst - [in] If true, face_symmetry_set[0] will be the primary motif face. Otherwise, face_symmetry_set[0] will be face. Returns: Number of vertices in the symmetry set. </p>

</div>
</div>
<a id="aa2288016aa93b7c93fed028f0a3f02d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2288016aa93b7c93fed028f0a3f02d4">&#9670;&nbsp;</a></span>GetSymmetrySet() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::GetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPrimaryMotifFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_symmetry_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the vertex's symmetry set. Parameters: vertex - [in] bPrimary MotifFirst - [in] If true, vertex_symmetry_set[0] will be the primary motif vertex. Otherwise, vertex_symmetry_set[0] will be vertex. vertex_symmetry_set - [out] The symmetry set containing the vertex. Returns: Number of vertices in the symmetry set. </p>

</div>
</div>
<a id="adbafa5f485a0f53097fde2d0eee0808b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbafa5f485a0f53097fde2d0eee0808b">&#9670;&nbsp;</a></span>GetTightBoundingBox()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GetTightBoundingBox </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___bounding_box.html">ON_BoundingBox</a> &amp;&#160;</td>
          <td class="paramname"><em>tight_bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bGrowBox</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___xform.html">ON_Xform</a> *&#160;</td>
          <td class="paramname"><em>xform</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> GetTightBoundingBox override <br  />
 </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#ab59968e400d15d016517b7b4f2e32ea4">ON_Geometry</a>.</p>

</div>
</div>
<a id="a6839c860d6e56a40f786362eff24648b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6839c860d6e56a40f786362eff24648b">&#9670;&nbsp;</a></span>GetWireframeEdgeChains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GetWireframeEdgeChains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minimum_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maximum_face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8">ON_SubD::ChainType</a>&#160;</td>
          <td class="paramname"><em>chain_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ON__UINT_PTR&#160;</td>
          <td class="paramname"><em>edge_chain_callback_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(ON__UINT_PTR, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *, unsigned int)&#160;</td>
          <td class="paramname"><em>edge_chain_callback_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a collection of NURBS curves that lie on the SubD limit surface edges. Parameters: edge_tag - [in] If edge_tag is not <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a>, then only edges with a matching tag will be converted to curves. minimum_face_count - [in] maximum_face_count - [in] Only edges with edge-&gt;<a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> &gt;= minimum_face_count and edge-&gt;<a class="el" href="class_o_n___sub_d.html#afd0b2ca2e120a29e35d1a7cb2ae3a349">FaceCount()</a> &lt;= maximum_face_count will be converted into curves. Pass 0, <a class="el" href="class_o_n___sub_d_edge.html#a2c4a15dc103922ae27e00f45df854d15ab14a1da83370eeb51e6fec74230b4a74">ON_SubDEdge::MaximumFaceCount</a> if you want all possible face counts. chain_type - [in] Controls which edges joined into a single curves. <a class="el" href="class_o_n___sub_d.html#a3e50466f1c3768aa762510fcd0fe69e8ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubD::ChainType::Unset</a> will create one curve per edge. edge_chain_callback_context - [in] edge_chain_callback_function - [in] Each edge chain is returned by calling edge_chain_callback_function(edge_chain_callback_context,edge_chain,edge_chain_count). The function edge_chain_callback_function() must copy any information it wants to reference later. It returns true to continue, false to terminate <a class="el" href="class_o_n___sub_d.html#a6839c860d6e56a40f786362eff24648b">GetWireframeEdgeChains()</a>. edge_chain[] reports which edges are represented byt nurbs_curve Returns: Number of curves generated. <br  />
 </p>

</div>
</div>
<a id="a67407752057b33b2e0d35f8a31a3547f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67407752057b33b2e0d35f8a31a3547f">&#9670;&nbsp;</a></span>GlobalSubdivide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GlobalSubdivide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a664b296cb38c698ab7fb784888ef84da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664b296cb38c698ab7fb784888ef84da">&#9670;&nbsp;</a></span>GlobalSubdivide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GlobalSubdivide </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Apply the Catmull-Clark subdivision algorithm and save the results in this <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. Parameters: level_index - [in] Level where subdivision starts count - [in] &gt; 0 Number of times to subdivide. Returns: Number of subdivision steps that succeeded. (= count when everything works, &lt; count when input is not valid) </p>

</div>
</div>
<a id="ab0cfd801289cf7d9406cebb22b500292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0cfd801289cf7d9406cebb22b500292">&#9670;&nbsp;</a></span>GroupConnectedRegions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::GroupConnectedRegions </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bManifoldRegions</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Assign group ids to sets vertices, edges, and faces in the connected regions. Parameters: bManifoldRegions - [in] If true, groups will stop at nonmanifold vertices and nonmanifold edges. Returns: Number of connected regions. The assigned group ids will run from 1 to the returned value. If bManifoldRegions is true and a nonmanifold component is on the boundary between two or more connected regions, then that component will have m_group_id = 0. </p>

</div>
</div>
<a id="abd7af2b3015684e980b679351270f1af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd7af2b3015684e980b679351270f1af">&#9670;&nbsp;</a></span>GrowEdgeFaceArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GrowEdgeFaceArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7171e34db9b9b2a4c1fe33d1e2177b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7171e34db9b9b2a4c1fe33d1e2177b95">&#9670;&nbsp;</a></span>GrowFaceEdgeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GrowFaceEdgeArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b275f0c7f614ecc05ce75abe81b7cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b275f0c7f614ecc05ce75abe81b7cdb">&#9670;&nbsp;</a></span>GrowVertexEdgeArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GrowVertexEdgeArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77cf1da1212f4faa9a79ad952ead98b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cf1da1212f4faa9a79ad952ead98b2">&#9670;&nbsp;</a></span>GrowVertexFaceArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::GrowVertexFaceArray </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>capacity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe1cab25ef65f3cfd1dc3931b94bd2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe1cab25ef65f3cfd1dc3931b94bd2d6">&#9670;&nbsp;</a></span>HasBrepForm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::HasBrepForm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#a84b28eb33d34c71913b9cd16f8ecab50">ON_Geometry</a>.</p>

</div>
</div>
<a id="aa3d7d5d6157c1a398dc03a7c0ff2e2bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d7d5d6157c1a398dc03a7c0ff2e2bf">&#9670;&nbsp;</a></span>HasPerFaceColors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::HasPerFaceColors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if one or more faces on the active level have per face color overrides. Remarks: Per face colors are a mutable property on <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> and are set with <a class="el" href="class_o_n___sub_d_face.html#a8683c5052083fd5bad83a980373e2432">ON_SubDFace.SetPerFaceColor()</a>. </p>

</div>
</div>
<a id="a7c3735b695cdea2113e5a56c57cbc1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3735b695cdea2113e5a56c57cbc1de">&#9670;&nbsp;</a></span>HasPerFaceColorsFromPackId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::HasPerFaceColorsFromPackId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if per face colors were set by <a class="el" href="class_o_n___sub_d.html#a056119983695a5a9ed2ee5dbaa2c323f">SetPerFaceColorsFromPackId()</a>. </p>

</div>
</div>
<a id="a99a32dba8965bff1085ec4cd20748a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99a32dba8965bff1085ec4cd20748a1f">&#9670;&nbsp;</a></span>HasPerFaceColorsFromSymmetryMotif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::HasPerFaceColorsFromSymmetryMotif </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if per face colors were set by <a class="el" href="class_o_n___sub_d.html#ab7a441089953c2633fc5f8845e96987f">SetPerFaceColorsFromSymmetryMotif()</a>. </p>

</div>
</div>
<a id="a2029809d54f653dc4f20917cbf647e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2029809d54f653dc4f20917cbf647e10">&#9670;&nbsp;</a></span>HasPerFaceMaterialChannelIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::HasPerFaceMaterialChannelIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if one or more faces on the active level have per face material channel index overrides. Remarks: Per face material channel indices are a mutable property on <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> and are set with <a class="el" href="class_o_n___sub_d_face.html#a7f9b3a39f87d794bfc492c49faf8fba0">ON_SubDFace.SetMaterialChannelIndex()</a>. </p>

</div>
</div>
<a id="a87af1313e286fd032fdd848f78d0f277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87af1313e286fd032fdd848f78d0f277">&#9670;&nbsp;</a></span>InSubD() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> ON_SubD::InSubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> *&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: If b is in this SubD, a <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> to b is returned. Otherwise <a class="el" href="class_o_n___sub_d_component_ptr.html#ae0309416fca150bc9e9b1569b9e4d493" title="// nullptr, type = unset, mark = 0">ON_SubDComponentPtr::Null</a> is returned. Remarks: This function is the slowest of the <a class="el" href="class_o_n___sub_d.html#a7268c24583c67db2a0e6a2774623b5f1">InSubD()</a> overrides. When b is an unknown component type, this function can be used to safely determine what type of component (vertex/edge/face). </p>

</div>
</div>
<a id="a5af0e791060516cc03ddcd0b35feda61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af0e791060516cc03ddcd0b35feda61">&#9670;&nbsp;</a></span>InSubD() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InSubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2949e6e0091b3fcaf6112b1f9eacb2fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2949e6e0091b3fcaf6112b1f9eacb2fa">&#9670;&nbsp;</a></span>InSubD() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InSubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7268c24583c67db2a0e6a2774623b5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7268c24583c67db2a0e6a2774623b5f1">&#9670;&nbsp;</a></span>InSubD() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InSubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Membership query </p>

</div>
</div>
<a id="a477fa8d88b1e498804e21b28660802f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477fa8d88b1e498804e21b28660802f2">&#9670;&nbsp;</a></span>InSubD() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InSubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>cptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: <a class="el" href="class_o_n___sub_d_component_ptr.html#a421eef62952e9be0de744341607a2c8dac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDComponentPtr::Type::Unset</a> if b is not in this SubD. Otherwise the type of the component is returned. </p>

</div>
</div>
<a id="abbc2467c56d4a63f7a66e13d464d2429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbc2467c56d4a63f7a66e13d464d2429">&#9670;&nbsp;</a></span>InterpolateControlNet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InterpolateControlNet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Modifies the SubD so that the SubD vertex limit points are equal to input control net locations. </p>

</div>
</div>
<a id="a9dd87c83ca89fac4813142012d539632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dd87c83ca89fac4813142012d539632">&#9670;&nbsp;</a></span>InterpolateSurfacePoints() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InterpolateSurfacePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Modifies the SubD so that the SubD vertex limit surface points are equal to vertex_surface_points[] Parameters: vertices - [in] free vertices surface_points - [in] surface_points[i] is the desired location for vertices[i].SurfacePoint(). </p>

</div>
</div>
<a id="aaf54f93f972f0af4d2e2ba55ce68ec3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf54f93f972f0af4d2e2ba55ce68ec3d">&#9670;&nbsp;</a></span>InterpolateSurfacePoints() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InterpolateSurfacePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_points</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Modifies the SubD so that the SubD vertex limit surface points are equal to surface_points[] Parameters: surface_points - [in] point for limit surface to interpolate. surface_points[i] is the location for the i-th vertex returned by ON_SubVertexIterator vit(*this). </p>

</div>
</div>
<a id="abd73c4faa8f393ccdc6db9e91734b0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd73c4faa8f393ccdc6db9e91734b0ea">&#9670;&nbsp;</a></span>InterpolateSurfacePoints() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InterpolateSurfacePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc9f54aaa612879ef8b9be6817416176"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc9f54aaa612879ef8b9be6817416176">&#9670;&nbsp;</a></span>InterpolateSurfacePoints() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InterpolateSurfacePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4e5669bfe06d9d6f8730d0de66df6006"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e5669bfe06d9d6f8730d0de66df6006">&#9670;&nbsp;</a></span>InterpolateSurfacePoints() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::InterpolateSurfacePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_vertex_ptr.html">ON_SubDVertexPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surface_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b9d90c17fbb3de7f59a53032fa3fd70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9d90c17fbb3de7f59a53032fa3fd70">&#9670;&nbsp;</a></span>IsBuiltInFacePackingId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::IsBuiltInFacePackingId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16e25bc37b56d05082218d73d495b81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16e25bc37b56d05082218d73d495b81b">&#9670;&nbsp;</a></span>IsDeformable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::IsDeformable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#af156cd098b9e68fab5f32e76b1e274e2">ON_Geometry</a>.</p>

</div>
</div>
<a id="aec85eda36162cbd6721dbc264ee9abf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec85eda36162cbd6721dbc264ee9abf2">&#9670;&nbsp;</a></span>IsEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::IsEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4af368b018163a2ee43d4b66ec8c285f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af368b018163a2ee43d4b66ec8c285f">&#9670;&nbsp;</a></span>IsManifold() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::IsManifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae8fd6f54038169c308ca42adabb6a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8fd6f54038169c308ca42adabb6a36">&#9670;&nbsp;</a></span>IsManifold() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::IsManifold </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>bIsOriented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>bHasBoundary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Test subd to see if the active level is an oriented manifold. Parameters: bIsOriented - [out] True if every edge that has two faces is oriented. Note that non-manifold edges are ignored. bHasBoundary - [in] True if there is at least one edge with a single face. Returns: True if the subd is a manifold (has at lease one face and every edge has 1 or 2 faces). False if the subd is not a manifold (has no faces or at least one edge with 0 or 3 or more faces) See Also: ON_SubDp::IsSolid </p>

</div>
</div>
<a id="a8f32618fb0bdf828df56d44ec9442d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f32618fb0bdf828df56d44ec9442d49">&#9670;&nbsp;</a></span>IsMorphable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::IsMorphable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#adb46c6b46022d8ea0e7a25c19911d6e3">ON_Geometry</a>.</p>

</div>
</div>
<a id="a182ffba1da22483bd6c6555fc8668fd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a182ffba1da22483bd6c6555fc8668fd4">&#9670;&nbsp;</a></span>IsNotEmpty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::IsNotEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61d16735d4923fe253ad33d23eccc2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d16735d4923fe253ad33d23eccc2eb">&#9670;&nbsp;</a></span>IsOriented()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::IsOriented </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if all facets are consistently oriented </p>

</div>
</div>
<a id="a56b5ba53e60b15c972d829afca431625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56b5ba53e60b15c972d829afca431625">&#9670;&nbsp;</a></span>IsSolid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::IsSolid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Test subd to see if the active level is a solid. <br  />
 A "solid" is a closed oriented manifold. Returns: true subd is a solid fals subd is not a solid See Also: ON_SubDp::SolidOrientation ON_SubDp::IsManifold </p>

</div>
</div>
<a id="a92475c9058b052ae0b53e6c5bee80b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92475c9058b052ae0b53e6c5bee80b4d">&#9670;&nbsp;</a></span>IsSubDFriendlyCurve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::IsSubDFriendlyCurve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___curve.html">ON_Curve</a> *&#160;</td>
          <td class="paramname"><em>curve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: curve - [in] curve to test. Returns: True if the curve is a cubic, nonrational, uniform NURBS curve that is either periodic or has natural end contitions. Othewise, false is returned. Remarks: A "natural" spline has zero 2nd derivatives (and hence zero curvature) at the start and end. A "periodic" spline has unclampled periodic knots and periodic control points. </p>

</div>
</div>
<a id="a7e72349efa7555baab2680ec83293dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e72349efa7555baab2680ec83293dd1">&#9670;&nbsp;</a></span>IsSubDFriendlySurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::IsSubDFriendlySurface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___surface.html">ON_Surface</a> *&#160;</td>
          <td class="paramname"><em>surface</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: curve - [in] curve to test. Returns: True if the curve is a nonrational, uniform, natural or periodic, cubic NURBS curve. Othewise, 0 is returned. Remarks: A "natural" spline has zero 2nd derivatives (and hence zero curvature) at the start and end. A "periodic" spline has unclampled periodic knots and periodic control points. </p>

</div>
</div>
<a id="a6da31bca23860a93830d3de23d5ffb1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da31bca23860a93830d3de23d5ffb1a">&#9670;&nbsp;</a></span>IsValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::IsValid </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___text_log.html">ON_TextLog</a> *&#160;</td>
          <td class="paramname"><em>text_log</em> = <code>nullptr</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#adf87e5ba0d9939dfabbb9f421b9d2b3b">ON_Geometry</a>.</p>

</div>
</div>
<a id="a3e8eb9196c3cc9f5fca17e1af2be9735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8eb9196c3cc9f5fca17e1af2be9735">&#9670;&nbsp;</a></span>IsValidSectorEdgeCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::IsValidSectorEdgeCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns: true if sector_edge_count is valid for the vertex type </p>

</div>
</div>
<a id="a18591efe5b4e4c54f2055aaac6feae88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18591efe5b4e4c54f2055aaac6feae88">&#9670;&nbsp;</a></span>IsValidSectorFaceCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::IsValidSectorFaceCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sector_face_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a35e16d64efdc8d7bb8a99830b6938706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e16d64efdc8d7bb8a99830b6938706">&#9670;&nbsp;</a></span>LastEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::LastEdge </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a96900ef2fd03179fe5dc9e125caf1536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96900ef2fd03179fe5dc9e125caf1536">&#9670;&nbsp;</a></span>LastFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::LastFace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7405dfa4aad4131c083c57d1ffc8604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7405dfa4aad4131c083c57d1ffc8604">&#9670;&nbsp;</a></span>LastVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::LastVertex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a4d589a902cc1c69148aaa20ff14615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4d589a902cc1c69148aaa20ff14615">&#9670;&nbsp;</a></span>LevelCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::LevelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: The number of explicitly computed levels that are currently available. A value of 0 indicates this SubD is empty. </p>

</div>
</div>
<a id="a6621df72011303a610b7d7086a276bed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6621df72011303a610b7d7086a276bed">&#9670;&nbsp;</a></span>LocalSubdivide() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::LocalSubdivide </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *&#160;</td>
          <td class="paramname"><em>face_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>face_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Apply the Catmull-Clark subdivision algorithm to the faces in face_list[]. Parameters: face_list - [in] faces to subdivide face_count - [in] number of components. Returns: true if successful. </p>

</div>
</div>
<a id="ae08819459daad0696e30c583027e09fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08819459daad0696e30c583027e09fc">&#9670;&nbsp;</a></span>LocalSubdivide() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::LocalSubdivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17f94d449e2c94096ef39644749b3b6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f94d449e2c94096ef39644749b3b6f">&#9670;&nbsp;</a></span>LocalSubdivide() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::LocalSubdivide </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5330d078b194a5a017aa8391e1ec910c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5330d078b194a5a017aa8391e1ec910c">&#9670;&nbsp;</a></span>MakeDeformable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::MakeDeformable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#ac3d5cb708edca66a4a6c1992299329a3">ON_Geometry</a>.</p>

</div>
</div>
<a id="ac6e8eabe1646331effbe9deb5f407169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6e8eabe1646331effbe9deb5f407169">&#9670;&nbsp;</a></span>MakeReflectSymmetric()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::MakeReflectSymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a>&#160;</td>
          <td class="paramname"><em>symmetry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Apply reflection symmetry </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000078">Deprecated:</a></b></dt><dd>Call ON_SubD::MakeSymmetric(symmetry); </dd></dl>

</div>
</div>
<a id="a31b1750bfa1feaac0e336fd41ddbecf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b1750bfa1feaac0e336fd41ddbecf7">&#9670;&nbsp;</a></span>MakeSymmetric() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::MakeSymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a>&#160;</td>
          <td class="paramname"><em>symmetry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Make this subd symmetric. Parameters: symmetry - [in] desired symmetry. Returns: True if succesful </p>

</div>
</div>
<a id="acd6ff9bb07fa310535965a53e14e5b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6ff9bb07fa310535965a53e14e5b6b">&#9670;&nbsp;</a></span>MakeSymmetric() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::MakeSymmetric </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a>&#160;</td>
          <td class="paramname"><em>symmetry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoredParameter1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoredParameter2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000077">Deprecated:</a></b></dt><dd>Obsolete - call <a class="el" href="class_o_n___sub_d.html#a31b1750bfa1feaac0e336fd41ddbecf7">ON_SubD::MakeSymmetric()</a> </dd></dl>

</div>
</div>
<a id="ae9e86225585cf815749bac641b495017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e86225585cf815749bac641b495017">&#9670;&nbsp;</a></span>MarkAggregateComponentStatusAsNotCurrent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::MarkAggregateComponentStatusAsNotCurrent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a609192fbafecbe4be3136d8cb4dce882">ON_Object</a>.</p>

</div>
</div>
<a id="a4f218011417be626ef20caeb5a088638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f218011417be626ef20caeb5a088638">&#9670;&nbsp;</a></span>MarkConnectedRegion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::MarkConnectedRegion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>seed_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bManifoldRegions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Mark all vertices, edges, and faces in the connected region containing seed_component by setting <a class="el" href="class_o_n___sub_d_component_base.html#ab4563bd61b50a8841f9837547a7b7fbe">ON_SubDComponentBase.Mark()</a> to true. Parameters: seed_component - [in] bManifoldRegions - [in] If true, marking will stop at nonmanifold vertices and nonmanifold edges. Returns: Number of marked components. </p>

</div>
</div>
<a id="a18f6c295baa65a55482367015853f66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18f6c295baa65a55482367015853f66b">&#9670;&nbsp;</a></span>MemoryRelocate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::MemoryRelocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#ae0674ccb79b6333e4b3c8e95ee10dd73">ON_Object</a>.</p>

</div>
</div>
<a id="a12df8e08da5056212f8ed7ae0ca48969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12df8e08da5056212f8ed7ae0ca48969">&#9670;&nbsp;</a></span>Merge() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> *&#160;</td>
          <td class="paramname"><em>vertex_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertex_pairs_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>prefered_merged_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeAllCoincidentVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkMergedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkAddedComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge a copy of subd into this. Parameters:</p>
<p>Parameters: subd - [in] SubD to append to this.</p>
<p>vertex_pairs_count - [in] vertex_pairs - [in] Pairs of vertices to to merge. The first pair component (vertex_pairs[i][0]) must be a vertex in this and the second pair component (vertex_pairs[i][1]) must be the corresponding vertex in subd. <br  />
 Vertices in subd that are not identified in vertex_pairs[] will be added to this as new vertices. When possible, invalid elements in vertex_pairs[] are silently ignored, but garbage in will often result in garbage out.</p>
<p>prefered_merged_edge_tag - [in] This parameter controls what edge tag is assigned when two boundary edges are merged into a single interior edge. In this case the default is smooth but can be overridden by setting prefered_merged_edge_tag to <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>.</p>
<p>bMergeAllCoincidentVertices - [in] When in doubt, pass false. If true, all coincident vertices will be merged. If false, only conincident corner vertices and conindident crease edges with at most one face will be merged.</p>
<p>bMarkMergedComponents - [in] If true, then merged components have RuntimeMark() set to true. <br  />
</p>
<p>bMarkAddedComponents - [in] If true, then added components have RuntimeMark() set to true. <br  />
</p>
<p>Returns: Number of components (vertices, edges, and faces) added to this.</p>
<p>Remarks: Existing compenent marks on this are erased. Then bMarkMergedComponents and bMarkAddedComponents determine which components get marked. </p>

</div>
</div>
<a id="a5ff437e52c58934f9579015cce87def6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ff437e52c58934f9579015cce87def6">&#9670;&nbsp;</a></span>Merge() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> *&#160;</td>
          <td class="paramname"><em>vertex_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertex_pairs_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>prefered_merged_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeAllCoincidentVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;&#160;</td>
          <td class="paramname"><em>this_vertex_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;&#160;</td>
          <td class="paramname"><em>subd_vertex_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkMergedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkAddedComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aea433bfc1ffc61a1a98dedcf8e09dc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea433bfc1ffc61a1a98dedcf8e09dc25">&#9670;&nbsp;</a></span>Merge() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>prefered_merged_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeAllCoincidentVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkMergedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkAddedComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge a copy of subd into this.</p>
<p>Parameters: subd - [in] SubD to append to this.</p>
<p>vertex_pairs - [in] Pairs of vertices to to merge. The first pair component (vertex_pairs[i][0]) must be a vertex in this and the second pair component (vertex_pairs[i][1]) must be the corresponding vertex in subd. <br  />
 Vertices in subd that are not identified in vertex_pairs[] will be added to this as new vertices. When possible, invalid elements in vertex_pairs[] are silently ignored, but garbage in will often result in garbage out.</p>
<p>prefered_merged_edge_tag - [in] This parameter controls what edge tag is assigned when two boundary edges are merged into a single interior edge. In this case the default is smooth but can be overridden by setting prefered_merged_edge_tag to <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325acf4718bda2cadba2e9d1f6b535a51e3a">ON_SubDEdgeTag::Crease</a>.</p>
<p>bMergeAllCoincidentVertices - [in] When in doubt, pass false. If true, all coincident vertices will be merged. If false, only conincident corner vertices and conindident crease edges with at most one face will be merged.</p>
<p>bMarkMergedComponents - [in] If true, then merged components have RuntimeMark() set to true. <br  />
</p>
<p>bMarkAddedComponents - [in] If true, then added components have RuntimeMark() set to true. <br  />
</p>
<p>Returns: Number of components (vertices, edges, and faces) added to this.</p>
<p>Remarks: Existing compenent marks on this are erased. Then bMarkMergedComponents and bMarkAddedComponents determine which components get marked. </p>

</div>
</div>
<a id="a555e5eb5cbbbeeda6140cd62edf01ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a555e5eb5cbbbeeda6140cd62edf01ea1">&#9670;&nbsp;</a></span>Merge() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::Merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>prefered_merged_edge_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeAllCoincidentVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;&#160;</td>
          <td class="paramname"><em>this_vertex_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_test.html">ON_SubDComponentTest</a> &amp;&#160;</td>
          <td class="paramname"><em>subd_vertex_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkMergedComponents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkAddedComponents</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f91e70d0308c804cfaf172f4d0c0b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f91e70d0308c804cfaf172f4d0c0b67">&#9670;&nbsp;</a></span>MergeColinearEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::MergeColinearEdges </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeBoundaryEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeInteriorCreaseEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeInteriorSmoothEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>maximum_aspect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sin_angle_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Editing tools </p>

</div>
</div>
<a id="aea3bf5a73e0b1be46758302662b55472"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea3bf5a73e0b1be46758302662b55472">&#9670;&nbsp;</a></span>MergeConsecutiveEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubD::MergeConsecutiveEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>eptr0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>eptr1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge consecutive edges into a single edge. eptr0 - [in] first edge (will not be deleted) eptr1 - [in] second edge (will be deleted if edges can be merged) Returns: Merged edge (eptr0) or <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> if edges could not be merged </p>

</div>
</div>
<a id="afc49e44b87428a1cbbaa0140f147d20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc49e44b87428a1cbbaa0140f147d20c">&#9670;&nbsp;</a></span>MergeFaces() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::MergeFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge the edge's faces into a single face. Parameters: edge - [in] An edge with two attached faces. Returns: A pointer to the merged face or nullptr if the input was not valid. </p>

</div>
</div>
<a id="a0412e0107132bcad5a3def31ed368f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0412e0107132bcad5a3def31ed368f01">&#9670;&nbsp;</a></span>MergeFaces() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::MergeFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge the faces attached to a vertex into a single face. Parameters: vertex - [in] An vertex with no nonmanifold edges and that has zero or two boundary edges. <br  />
 Returns: A pointer to the merged face or nullptr if the input was not valid. </p>

</div>
</div>
<a id="a5bdb6c2c8b62798a6bdec93fb331131f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdb6c2c8b62798a6bdec93fb331131f">&#9670;&nbsp;</a></span>MergeFaces() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::MergeFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFaceListMayBeInvalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge a set of faces into a single face. Parameters: face_list - [in] A list of faces that can be merged into a single face. bFaceListMayBeInvalid - [in] True indicates that it is possible the set of faces in face_list may not be contiguous with a single boundary component. Returns: A pointer to the merged face or nullptr if the input was not valid. </p>

</div>
</div>
<a id="af558f2d1f7371716d245e42216b9e95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af558f2d1f7371716d245e42216b9e95a">&#9670;&nbsp;</a></span>MergeFaces() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::MergeFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face_ptr.html">ON_SubDFacePtr</a> *&#160;</td>
          <td class="paramname"><em>face_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFaceListMayBeInvalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge a set of faces into a single face. Parameters: face_list - [in] A list of faces that can be merged into a single face. size_t face_count - [in] bFaceListMayBeInvalid - [in] True indicates that it is possible the set of faces in face_list may not be contiguous with a single boundary component. Returns: A pointer to the merged face or nullptr if the input was not valid. </p>

</div>
</div>
<a id="aaf773013478b1e3148aa1e9adbc3b47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf773013478b1e3148aa1e9adbc3b47b">&#9670;&nbsp;</a></span>MergeFaces() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::MergeFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *&#160;</td>
          <td class="paramname"><em>face_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>face_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFaceListMayBeInvalid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Merge a set of faces into a single face. Parameters: face_list - [in] A list of faces that can be merged into a single face. bFaceListMayBeInvalid - [in] True indicates that it is possible the set of faces in face_list may not be contiguous with a single boundary component. Returns: A pointer to the merged face or nullptr if the input was not valid. </p>

</div>
</div>
<a id="a693b3076c4b3b5421a3c913c2476a71c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a693b3076c4b3b5421a3c913c2476a71c">&#9670;&nbsp;</a></span>MergeFaceSets() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::MergeFaceSets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: The collection of faces in face_list[] is partitioned into subsets that can be merged into a single face. Parameters: face_list - [in] A list of faces. Returns: Number of merged faces, all of which have m_status.RuntimeMark() set to true. </p>

</div>
</div>
<a id="a27b184fe314be54759be677c9c505f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b184fe314be54759be677c9c505f9c">&#9670;&nbsp;</a></span>MergeFaceSets() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::MergeFaceSets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeSharedEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: The collection of components in faces in cptr_list[] is used to generate subsets or faces that can be merged into a single face. Parameters: ci_list - [in] A list of components. bMergeSharedEdges - [in] When in doubt, pass true. If true, contiguous edges on the boundary of a merged face will be merged into a single edge when possible. Returns: Number of merged faces, all of which have m_status.RuntimeMark() set to true. Remarks: If an edge in cptr_list[] is part of a boundary of a face in cptr_list[], then that edge is ignored. If an vertex in cptr_list[] is attached to a face in cptr_list[] or attached to a face that is attached to an edge in cptr_list[], then that vertex is ignored. </p>

</div>
</div>
<a id="a287fa6c2659a164a5f30b784f43fdd9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287fa6c2659a164a5f30b784f43fdd9a">&#9670;&nbsp;</a></span>MergeFaceSets() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::MergeFaceSets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeSharedEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: The collection of components in faces in cptr_list[] is used to generate subsets or faces that can be merged into a single face. Parameters: cptr_list - [in] A list of components. bMergeSharedEdges - [in] When in doubt, pass true. If true, contiguous edges on the boundary of a merged face will be merged into a single edge when possible. Returns: Number of merged faces, all of which have m_status.RuntimeMark() set to true. Remarks: If an edge in cptr_list[] is part of a boundary of a face in cptr_list[], then that edge is ignored. If an vertex in cptr_list[] is attached to a face in cptr_list[] or attached to a face that is attached to an edge in cptr_list[], then that vertex is ignored. </p>

</div>
</div>
<a id="a0eb66f90496c22c4b737ce84a4a221fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb66f90496c22c4b737ce84a4a221fb">&#9670;&nbsp;</a></span>MergeFaceSets() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::MergeFaceSets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cptr_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMergeSharedEdges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: The collection of components in faces in cptr_list[] is used to generate subsets or faces that can be merged into a single face. Parameters: cptr_list - [in] A list of components. cptr_count - [in] number of components bMergeSharedEdges - [in] When in doubt, pass true. If true, contiguous edges on the boundary of a merged face will be merged into a single edge when possible. Returns: Number of merged faces, all of which have m_status.RuntimeMark() set to true. Remarks: If an edge in cptr_list[] is part of a boundary of a face in cptr_list[], then that edge is ignored. If an vertex in cptr_list[] is attached to a face in cptr_list[] or attached to a face that is attached to an edge in cptr_list[], then that vertex is ignored. </p>

</div>
</div>
<a id="a7da703ec2e031e021473330deee94285"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7da703ec2e031e021473330deee94285">&#9670;&nbsp;</a></span>MeshFragmentCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::MeshFragmentCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: The number of limit surface mesh fragments (<a class="el" href="class_o_n___sub_d_mesh_fragment.html">ON_SubDMeshFragment</a>) that <a class="el" href="class_o_n___sub_d.html#a0e6ebb34429c0c98d75c37e0dce9019e">GetMeshFragments()</a> will produce. </p>

</div>
</div>
<a id="a7644c65cb6234acb0d79723de8f30db0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7644c65cb6234acb0d79723de8f30db0">&#9670;&nbsp;</a></span>Morph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::Morph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___space_morph.html">ON_SpaceMorph</a> &amp;&#160;</td>
          <td class="paramname"><em>morph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

</div>
</div>
<a id="a34fe2a7a2f837731fefcb1be7f988a4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fe2a7a2f837731fefcb1be7f988a4a">&#9670;&nbsp;</a></span>NurbsKnotType() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6e">ON_SubD::SubDFriendlyKnotType</a> ON_SubD::NurbsKnotType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *&#160;</td>
          <td class="paramname"><em>knots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: order - [in] NURBS knot vector order. cv_count - [in] Number of NURBS knot vector control points. knots - [in] NURBS knot vector. This is an array of (cv_count+2) knot values. Returns: SubD friendly knot vector type. Remarks: If order is not 4, cv_count is not valid, or knot is nullptr, then <a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6eab3b0d3e7139cadb1d3336c1465eb1703">ON_SubD::SubDFriendlyKnotType::Unfriendly</a> is returned. </p>

</div>
</div>
<a id="afaf8c05b048eac0ea6cd68cf541dba6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf8c05b048eac0ea6cd68cf541dba6a">&#9670;&nbsp;</a></span>NurbsKnotType() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html#acf1f951df917b01dcf8e01af028c2e6e">ON_SubD::SubDFriendlyKnotType</a> ON_SubD::NurbsKnotType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cv_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> double *&#160;</td>
          <td class="paramname"><em>knots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>triple_knots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a830ccb2334339677aff5a9749a6460d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a830ccb2334339677aff5a9749a6460d5">&#9670;&nbsp;</a></span>ObjectType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n.html#a328d22b5ad7bf9d4e9ba1123355d3cf9">ON::object_type</a> ON_SubD::ObjectType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#afa19aee4a411a8fda53aff00bd02d86e">ON_Object</a>.</p>

</div>
</div>
<a id="aeb5bbba924fd7eeb9f1114e9e1d4e35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb5bbba924fd7eeb9f1114e9e1d4e35f">&#9670;&nbsp;</a></span>ObsoleteTextureDomainTypeFromTextureCoordinateType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char ON_SubD::ObsoleteTextureDomainTypeFromTextureCoordinateType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a>&#160;</td>
          <td class="paramname"><em>texture_coordinate_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af996b7ead8af69329ed467be8c5d1e3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af996b7ead8af69329ed467be8c5d1e3c">&#9670;&nbsp;</a></span>Offset() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::Offset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOffsetSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bBothSides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMakeSolid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPreserveSymmetry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: offset_distance - [in] A valid nonzero value . bOffsetSurface - [in] If true, the offset is caluclated by interpolating offet surface points. Otherwise the offset is calculated by offsetting the control net. Using interpolation is slower and typiclly produces less pleasing appearance. Using the control net typically means the surface offset distance is not exactly offset_distance. bBothSides - [in] If true, the input subd is offset both directions. bMakeSolid - [in] If true, the result is a solid made by adding quads connecting corresponding boundary edges the input subd and the offset or both sides of the offset. bPreserveSymmetry - [in] If both bPreserveSymmetry and this-&gt;<a class="el" href="class_o_n___sub_d.html#afda5bb6a04c93f681cf672ca9208abc4">ContentIsSymmetric()</a> are true, then the returned sub will attempt to preserve the symmetry. destination_subd - [in] If not nullptr, the result will be created in this subd. If this and destination_subd are the same, the subd is offset in place. If nullptr is passed, the returned <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> is on the heap and the caller is resposible for managing it. Returns: If successful, the offset is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="a5e3fb2bd4ddb6b5658a77ec42b2f3709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3fb2bd4ddb6b5658a77ec42b2f3709">&#9670;&nbsp;</a></span>Offset() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::Offset </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>offset_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOffsetSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bBothSides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMakeSolid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: offset_distance - [in] A valid nonzero value . bOffsetSurface - [in] If true, the offset is caluclated by interpolating offet surface points. Otherwise the offset is calculated by offsetting the control net. Using interpolation is slower and typiclly produces less pleasing appearance. Using the control net typically means the surface offset distance is not exactly offset_distance. bBothSides - [in] If true, the input subd is offset both directions. bMakeSolid - [in] If true, the result is a solid made by adding quads connecting corresponding boundary edges the input subd and the offset or both sides of the offset. destination_subd - [in] If not nullptr, the result will be created in this subd. If this and destination_subd are the same, the subd is offset in place. If nullptr is passed, the returned <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> is on the heap and the caller is resposible for managing it. Returns: If successful, the offset is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="ad6012d7d4b7f9ab046d1d36c9788dd3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6012d7d4b7f9ab046d1d36c9788dd3a">&#9670;&nbsp;</a></span>Offset() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::Offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td>
          <td class="paramname"><em>offset_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOffsetSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bBothSides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMakeSolid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPreserveSymmetry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: offset_direction - [in] non zero vector bOffsetSurface - [in] If true, the offset is caluclated by interpolating offet surface points. Otherwise the offset is calculated by offsetting the control net. Using interpolation is slower and typiclly produces less pleasing appearance. Using the control net typically means the surface offset distance is not exactly offset_distance. bBothSides - [in] If true, the input subd is offset both directions. bMakeSolid - [in] If true, the result is a solid made by adding quads connecting corresponding boundary edges the input subd and the offset or both sides of the offset. bPreserveSymmetry - [in] If both bPreserveSymmetry and this-&gt;<a class="el" href="class_o_n___sub_d.html#afda5bb6a04c93f681cf672ca9208abc4">ContentIsSymmetric()</a> are true, then the returned sub will attempt to preserve the symmetry. destination_subd - [in] If not nullptr, the result will be created in this subd. If this and destination_subd are the same, the subd is offset in place. If nullptr is passed, the returned <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> is on the heap and the caller is resposible for managing it. Returns: If successful, the offset is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="a65cccbc915594a18ebd50968d5cac095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cccbc915594a18ebd50968d5cac095">&#9670;&nbsp;</a></span>Offset() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::Offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td>
          <td class="paramname"><em>offset_direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bOffsetSurface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bBothSides</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMakeSolid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: offset_direction - [in] non zero vector bOffsetSurface - [in] If true, the offset is caluclated by interpolating offet surface points. Otherwise the offset is calculated by offsetting the control net. Using interpolation is slower and typiclly produces less pleasing appearance. Using the control net typically means the surface offset distance is not exactly offset_distance. bBothSides - [in] If true, the input subd is offset both directions. bMakeSolid - [in] If true, the result is a solid made by adding quads connecting corresponding boundary edges the input subd and the offset or both sides of the offset. destination_subd - [in] If not nullptr, the result will be created in this subd. If this and destination_subd are the same, the subd is offset in place. If nullptr is passed, the returned <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> is on the heap and the caller is resposible for managing it. Returns: If successful, the offset is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="a228fd567f8aa46db376fef2d32512b19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228fd567f8aa46db376fef2d32512b19">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a>&amp; ON_SubD::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Creates an independent copy of src. </p>

</div>
</div>
<a id="a68093b5d13b3b7510bfac5a822d5a907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68093b5d13b3b7510bfac5a822d5a907">&#9670;&nbsp;</a></span>Orient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::Orient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to orient all facet to match the first facet. </p>

</div>
</div>
<a id="a7ae35f701fbf4f43bb90827458abb6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae35f701fbf4f43bb90827458abb6ae">&#9670;&nbsp;</a></span>PackFaces() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::PackFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Calls this-&gt;PackFaces(ON_SubD::DefaultPackFacesId). Returns: Number of face packs. </p>

</div>
</div>
<a id="ad68b3874bb2387fc0a1c6f135f6427f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68b3874bb2387fc0a1c6f135f6427f1">&#9670;&nbsp;</a></span>PackFaces() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::PackFaces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>face_packing_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Applies one of the built in face packings. Quad faces are divided into rectangular grids and every face in the rectangular grid is assigned the same PackId. In addition, every face is assigned a distinct PackRect which is a sub-rectangle in (0,1)x(0,1). If quad faces are adjacent and have the same PackId, then their PactRects are also adjacent. Parameters: face_packing_id - [in] An id for one of the built-in face packings. Code that wants to use the built-in face packing that is currently the best option for general use, will specify <a class="el" href="class_o_n___sub_d.html#ab50603eacdbc50beb23a88590df6e55c" title="ADD NEW PackFaces ids above this comment and below FastAndSimplePackFacesId.">ON_SubD::DefaultFacePackingId</a> or call <a class="el" href="class_o_n___sub_d.html#a7ae35f701fbf4f43bb90827458abb6ae">PackFaces()</a>. Returns: Number of face packs. </p>

</div>
</div>
<a id="a2217f352d21c27d180e7cb6d36b3e072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2217f352d21c27d180e7cb6d36b3e072">&#9670;&nbsp;</a></span>ProjectVerticesToPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ProjectVerticesToPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a>&#160;</td>
          <td class="paramname"><em>plane_equation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Projects vertices's control points that are near a plane to the plane. Parameters: plane_equation - [in] distance_tolerance - [in] If the distance from a vertex's control net point is &lt;= distance_tolerance, that control net point is projected to the plane. Returns: number of vertices whose control points where projected. </p>

</div>
</div>
<a id="ac0c535f015caf4aa27dfa95f3d768deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0c535f015caf4aa27dfa95f3d768deb">&#9670;&nbsp;</a></span>ProxyBrep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___brep.html">ON_Brep</a>* ON_SubD::ProxyBrep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td>
          <td class="paramname"><em>destination_brep</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>SubD proxy brep interface. </p>
<p>Returns: GetSurfaceBrep( ON_SubDToBrepParameters::Default, destination_brep ); </p>

</div>
</div>
<a id="a5a3d7944a9466b3bd8fa829a6ac9385f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3d7944a9466b3bd8fa829a6ac9385f">&#9670;&nbsp;</a></span>ProxyBrepEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_edge.html">ON_BrepEdge</a>* ON_SubD::ProxyBrepEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td>
          <td class="paramname"><em>proxy_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>subd_edge_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_edge.html">ON_BrepEdge</a> *&#160;</td>
          <td class="paramname"><em>prev_proxy_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: proxy_brep - [in] Brep created on this-&gt;<a class="el" href="class_o_n___sub_d.html#ac0c535f015caf4aa27dfa95f3d768deb" title="SubD proxy brep interface.">ProxyBrep()</a> subd_edge_id - [in] Returns: A proxy_brep edge corresponding to some part of the subd edge. </p>

</div>
</div>
<a id="a8aea6ae0c9228d9f70b4504c8d4d5f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aea6ae0c9228d9f70b4504c8d4d5f48">&#9670;&nbsp;</a></span>ProxyBrepFace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_face.html">ON_BrepFace</a>* ON_SubD::ProxyBrepFace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td>
          <td class="paramname"><em>proxy_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>subd_face_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_face.html">ON_BrepFace</a> *&#160;</td>
          <td class="paramname"><em>prev_proxy_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: proxy_brep - [in] Brep created on this-&gt;<a class="el" href="class_o_n___sub_d.html#ac0c535f015caf4aa27dfa95f3d768deb" title="SubD proxy brep interface.">ProxyBrep()</a> subd_face_id - [in] Returns: A proxy_brep face corresponding to some part of the subd face. </p>

</div>
</div>
<a id="a389f7c6400638375f128cc9ef5b29c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389f7c6400638375f128cc9ef5b29c69">&#9670;&nbsp;</a></span>ProxyBrepVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___brep_vertex.html">ON_BrepVertex</a>* ON_SubD::ProxyBrepVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___brep.html">ON_Brep</a> *&#160;</td>
          <td class="paramname"><em>proxy_brep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>subd_vertex_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: proxy_brep - [in] Brep created on this-&gt;<a class="el" href="class_o_n___sub_d.html#ac0c535f015caf4aa27dfa95f3d768deb" title="SubD proxy brep interface.">ProxyBrep()</a> subd_vertex_id - [in] <br  />
 Returns: The proxy_brep vertex corresponding to the subd vertex. </p>

</div>
</div>
<a id="a985d76907f6ab912d5b4c66858b7e490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a985d76907f6ab912d5b4c66858b7e490">&#9670;&nbsp;</a></span>Read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::Read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a09ac9742ead91dd8f9cdd579bcbfed10">ON_Object</a>.</p>

</div>
</div>
<a id="ab5cbe1ab19c940c6cbf800eb6f100c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cbe1ab19c940c6cbf800eb6f100c75">&#9670;&nbsp;</a></span>RemoveAllCreases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::RemoveAllCreases </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Remove all interior creases. Returns: Number of edges converted from crease to smooth. </p>

</div>
</div>
<a id="a34f08f40c4bcb8e0f85dfb1a5c9c9596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f08f40c4bcb8e0f85dfb1a5c9c9596">&#9670;&nbsp;</a></span>RemoveEdgeVertexConnection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::RemoveEdgeVertexConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to remove a connection beteen an edge and vertex Parameters: e - [in] An edge with zero attached faces. v - [in] A vertex attached to the e. Returns: If successful, true is returned. Otherwise false is returned. </p>

</div>
</div>
<a id="a84ec24a00a769bfd485ab61d947b404c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ec24a00a769bfd485ab61d947b404c">&#9670;&nbsp;</a></span>RemoveEdgeVertexConnection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::RemoveEdgeVertexConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>evi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to remove a connection beteen an edge and edge-&gt;vertex[evi] Parameters: e - [in] An edge with zero attached faces. evi - [in] 0 or 1 specifying which vertex to remove. Returns: If successful, a pointer to the removed vertex is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="a4e47ece8a0299bd973c87149632ead0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e47ece8a0299bd973c87149632ead0a">&#9670;&nbsp;</a></span>RemoveFaceConnections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::RemoveFaceConnections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to remove all edge and vertex connnections from a face Parameters: face - [in] Remarks: This tool is used during editing of a SubD and the connections are removed even if the result is an invalid face or edge. It is up to the expert user to make enough changes to create a valid SubD. </p>

</div>
</div>
<a id="a6a4553f75547dfd9db03ca0a6487b91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4553f75547dfd9db03ca0a6487b91e">&#9670;&nbsp;</a></span>RemoveFaceEdgeConnection() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::RemoveFaceEdgeConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to insert an edge in the face's edge array. Parameters: face - [in] edge - [in] edge to remove Returns: true if successful. Remarks: This tool is used during construction or editing of a SubD and the connection is removed even if the result is an invalid face or edge. It is up to the expert user to make enough changes to create a valid SubD. </p>

</div>
</div>
<a id="a2bf865446d02d96263f6580cc717e63e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf865446d02d96263f6580cc717e63e">&#9670;&nbsp;</a></span>RemoveFaceEdgeConnection() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::RemoveFaceEdgeConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to remove the connection between and edge and face. Parameters: face - [in] i - [in] index where the edge should be removed. 0 &lt;= i &lt; face-&gt;<a class="el" href="class_o_n___sub_d.html#ae5da40c3ae92bcbc1c0c9aac31a3d1dc">EdgeCount()</a> removed_edge - [out] removed edge Remarks: This tool is used during construction or editing of a SubD and the connection is removed even if the result is an invalid face or edge. It is up to the expert user to make enough changes to create a valid SubD. </p>

</div>
</div>
<a id="a33c5d0dd4e933a8fbc06c97ac1a54fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c5d0dd4e933a8fbc06c97ac1a54fb5">&#9670;&nbsp;</a></span>RemoveFaceEdgeConnection() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::RemoveFaceEdgeConnection </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &amp;&#160;</td>
          <td class="paramname"><em>removed_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to remove the connection between and edge and face. Parameters: face - [in] i - [in] index where the edge should be removed. removed_edge - [out] removed edge Remarks: This tool is used during construction or editing of a SubD and the connection is removed even if the result is an invalid face or edge. It is up to the expert user to make enough changes to create a valid SubD. </p>

</div>
</div>
<a id="a71741d50e05aa5bd6571d0ca2e6e15d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71741d50e05aa5bd6571d0ca2e6e15d0">&#9670;&nbsp;</a></span>RemoveZeroLengthEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::RemoveZeroLengthEdges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Remove all zero length edges. When an edge is removed, the edge vertex with the smallest id survives. Returns: Number of edges that were removed. Remarks: If a faces end up with &lt; 3 edges, they are removed as well. </p>

</div>
</div>
<a id="a5070b9f89eb3330080e5fc41283dd555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5070b9f89eb3330080e5fc41283dd555">&#9670;&nbsp;</a></span>RenderContentSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a> ON_SubD::RenderContentSerialNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: The render content serial number changes whenever a change the might effect rendered appearance changes. This includes both geometry changes and changes that affect rendered appeance including changes to per face colors, per face materials, texture coordinates, and texture mappings. </p>

</div>
</div>
<a id="a5a8f2c5a3f9106bd1c177dabf08ba8fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a8f2c5a3f9106bd1c177dabf08ba8fb">&#9670;&nbsp;</a></span>ReplaceFaceWithTrianglation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ReplaceFaceWithTrianglation </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a>&#160;</td>
          <td class="paramname"><em>triangluation_plane_normal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Replace a face by trangulating its boundary into with (face-&gt;<a class="el" href="class_o_n___sub_d.html#ae5da40c3ae92bcbc1c0c9aac31a3d1dc">EdgeCount()</a>-2) triangles. No new vertices are added. Parameters: face - [in] This face is replaced with a trianglulation of its boundary and becomes the first triangle in the triangulation. triangluation_plane_normal - [in] If valid and nonzero, this vector is used as the normal of the plane for calculating the boundary triangulation. Othewise, the plane normal is calculated from the boundary vertices. When in doubt, pass <a class="el" href="class_o_n__3d_vector.html#a2441a460d8808a3f5027284dd2325acb" title="(0.0,0.0,0.0)">ON_3dVector::ZeroVector</a>. bMarkFaces - [in] If true, face and new triangles are marked. Existing marks are not modified. Returns: Number of triangles. </p>

</div>
</div>
<a id="a44559922bedb93779be41a603a063e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44559922bedb93779be41a603a063e04">&#9670;&nbsp;</a></span>ReplaceFaceWithTriangleFan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::ReplaceFaceWithTriangleFan </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>fan_center_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bMarkFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Replace a face with a triangle fan by adding a single new vertex at fan_center_point and adding tringle made from the face's edes to the center point. Parameters: face - [in] This face is replaced with a triangle fan and becomes the first triangle in the fan. fan_center_point - [in] If valid, this point is used as the fan's center. Otherwise the centriod of the face's vertices is used s the fan's center. When in doubt, pass <a class="el" href="class_o_n__3d_point.html#aa68906e3e7650b01ce88c527f6088d7d" title="(ON_UNSET_VALUE,ON_UNSET_VALUE,ON_UNSET_VALUE)">ON_3dPoint::UnsetPoint</a>. bMarkFaces - [in] If true, face and new triangles are marked. Existing marks are not modified. Returns: If successfull, the new vertex at the center of the triangle fan. Otherwise, nullptr is returned. </p>

</div>
</div>
<a id="a5c5f9c3d9ac7f0a153d2d79e169e6751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c5f9c3d9ac7f0a153d2d79e169e6751">&#9670;&nbsp;</a></span>ReturnEdgeForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::ReturnEdgeForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: e - [in] An edge in this subd with no vertices or faces. </p>

</div>
</div>
<a id="aa4e34dbc57870f067bfd2821721cb41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e34dbc57870f067bfd2821721cb41e">&#9670;&nbsp;</a></span>ReturnFaceForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::ReturnFaceForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: f - [in] A face with zero edges </p>

</div>
</div>
<a id="a0b4d342996a170bf84108f0a8ceddbcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4d342996a170bf84108f0a8ceddbcd">&#9670;&nbsp;</a></span>ReturnVertexForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::ReturnVertexForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: v - [in] A vertex with zero edge and zero faces. </p>

</div>
</div>
<a id="a192d2d9347cef690f7b3e9e469170eb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a192d2d9347cef690f7b3e9e469170eb6">&#9670;&nbsp;</a></span>ReverseOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::ReverseOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>reverses the orientation of all facets </p>

</div>
</div>
<a id="a849e7dfb0c615f0fdd6ddbf0fa0ffe92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a849e7dfb0c615f0fdd6ddbf0fa0ffe92">&#9670;&nbsp;</a></span>RuntimeSerialNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga3c46136e2570983319c47553f753932e">ON__UINT64</a> ON_SubD::RuntimeSerialNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: A runtime serial number identifying this subd. Remarks: <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> is a shared pointer to an implementation. As such, there can be multiple <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> instances that reference the same implementation. The runtime serial number uniquely identifies a particular instance of an implementation. The empty subd has runtime serial number = 0. </p>

</div>
</div>
<a id="a1a85d24bb1b78802d96989f4bcc61c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a85d24bb1b78802d96989f4bcc61c09">&#9670;&nbsp;</a></span>SeparateInteriorEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> ON_SubD::SeparateInteriorEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>interior_edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>separator0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>separator1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) an interior edge into two conincident boundary edges. Parameters: edge - [in] Interior edge to separate. separator0 - [in] If interior_edge.RelativeVertex(0) is an interior vertex, then a separator0 may be included to specify how the vertex faces should be divided into two sectors. If interior_edge.RelativeVertex(0) is a boundary vertex, separator0 is ignored. If separator0 is not included, an automatic choice is made. separator1 - [in] If interior_edge.RelativeVertex(1) is an interior vertex, then a separator1 may be included to specify how the vertex faces should be divided into two sectors. If interior_edge.RelativeVertex(1) is a boundary vertex, separator1 is ignored. If separator0 is not included, an automatic choice is made. Returns: If successful, the separated edges are returned as a pair with the original edge in pair.First().EdgePtr() and the new edge in pair.Second().EdgePtr(). Otherwise, <a class="el" href="class_o_n___sub_d_component_ptr_pair.html#a9cc9b83e198ce3aa94046459e599a4b2">ON_SubDComponentPtrPair::Null</a> is returned. </p>

</div>
</div>
<a id="afee878f3a3d8fa6d15cbc3f2692f7e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee878f3a3d8fa6d15cbc3f2692f7e83">&#9670;&nbsp;</a></span>SeparateInteriorEdgeChains() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SeparateInteriorEdgeChains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>separated_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) interior edges. Parameters: edge_chains - [in] edge chains that will be separated into conincident boundary edges. separated_edges - [out] If not null, the pairs of separated edges are returned here. separated_edges[].First().EdgePtr() will be an original edge. separated_edges[].Second().EdgePtr() will be a new edge edge. Returns: Number of separated edges. </p>

</div>
</div>
<a id="a5495c8231e79f9a19816b59fe341a81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5495c8231e79f9a19816b59fe341a81b">&#9670;&nbsp;</a></span>SeparateInteriorEdgeChains() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SeparateInteriorEdgeChains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>separated_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) interior edges. Parameters: edge_chains - [in] edge chains that will be separated into conincident boundary edges. separated_edges - [out] If not null, the pairs of separated edges are returned here. separated_edges[].First().EdgePtr() will be an original edge. separated_edges[].Second().EdgePtr() will be a new edge edge. Returns: Number of separated edges. </p>

</div>
</div>
<a id="a65883fe1e11f9d751a8b98174af48d60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65883fe1e11f9d751a8b98174af48d60">&#9670;&nbsp;</a></span>SeparateInteriorEdgeChains() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SeparateInteriorEdgeChains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>separated_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) interior edges. Parameters: edge_chains - [in] edge chains that will be separated into conincident boundary edges. separated_edges - [out] If not null, the pairs of separated edges are returned here. separated_edges[].First().EdgePtr() will be an original edge. separated_edges[].Second().EdgePtr() will be a new edge edge. Returns: Number of separated edges. </p>

</div>
</div>
<a id="a5ec8f95a8bb6228fb10ac4bd5009601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ec8f95a8bb6228fb10ac4bd5009601a">&#9670;&nbsp;</a></span>SeparateInteriorEdgeChains() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SeparateInteriorEdgeChains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_chains</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>separated_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) interior edges. Parameters: edge_chains - [in] edge chains that will be separated into conincident boundary edges. separated_edges - [out] If not null, the pairs of separated edges are returned here. separated_edges[].First().EdgePtr() will be an original edge. separated_edges[].Second().EdgePtr() will be a new edge edge. Returns: Number of separated edges. </p>

</div>
</div>
<a id="afe8378aa17125d9931e260f14e25cef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8378aa17125d9931e260f14e25cef8">&#9670;&nbsp;</a></span>SeparateInteriorEdges() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SeparateInteriorEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>separated_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) interior edges. Parameters: edges - [in] edges that will be sorted into edge chains that will be separated into conincident boundary edges. separated_edges - [out] If not null, the pairs of separated edges are returned here. separated_edges[].First().EdgePtr() will be an original edge. separated_edges[].Second().EdgePtr() will be a new edge edge. Returns: Number of separated edges. </p>

</div>
</div>
<a id="ab65ee1a90dec85791474b312d10fafb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65ee1a90dec85791474b312d10fafb6">&#9670;&nbsp;</a></span>SeparateInteriorEdges() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SeparateInteriorEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>separated_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) interior edges. Parameters: edges - [in] edges that will be sorted into edge chains that will be separated into conincident boundary edges. separated_edges - [out] If not null, the pairs of separated edges are returned here. separated_edges[].First().EdgePtr() will be an original edge. separated_edges[].Second().EdgePtr() will be a new edge edge. Returns: Number of separated edges. </p>

</div>
</div>
<a id="a2a751afda122f7ca28061a6ae9aa04c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a751afda122f7ca28061a6ae9aa04c6">&#9670;&nbsp;</a></span>SeparateInteriorEdges() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SeparateInteriorEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>separated_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) interior edges. Parameters: edges - [in] edges that will be sorted into edge chains that will be separated into conincident boundary edges. separated_edges - [out] If not null, the pairs of separated edges are returned here. separated_edges[].First().EdgePtr() will be an original edge. separated_edges[].Second().EdgePtr() will be a new edge edge. Returns: Number of separated edges. </p>

</div>
</div>
<a id="a5d9c8a047ca9563641430f69b1a0860c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9c8a047ca9563641430f69b1a0860c">&#9670;&nbsp;</a></span>SeparateInteriorEdges() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SeparateInteriorEdges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr_pair.html">ON_SubDComponentPtrPair</a> &gt; *&#160;</td>
          <td class="paramname"><em>separated_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) interior edges. Parameters: edges - [in] edges that will be sorted into edge chains that will be separated into conincident boundary edges. separated_edges - [out] If not null, the pairs of separated edges are returned here. separated_edges[].First().EdgePtr() will be an original edge. separated_edges[].Second().EdgePtr() will be a new edge edge. Returns: Number of separated edges. </p>

</div>
</div>
<a id="a8939f2aa50b61de9b8e978c40ed419fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8939f2aa50b61de9b8e978c40ed419fa">&#9670;&nbsp;</a></span>SeparateVertex() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>*&gt; ON_SubD::SeparateVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bApplyCreaseBias</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) a vertex into the default number of sectors. Parameters: vertex - [in] If the vertex is a nonmanifold vertex with multiple manifold sectors, it is separated into manifold sectors. bApplyCreaseBias - [in] If the vertex has a single sector and the topology and creases cleary create two sectors, then the separation will be performed along the creases. Returns: If separation occured, then an array of the separated vertices is returned with the original vertex is the first element in the array. Otherwise an empty array is returned. </p>

</div>
</div>
<a id="af4e2fc4a3b87663caa7cb2f609b48277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e2fc4a3b87663caa7cb2f609b48277">&#9670;&nbsp;</a></span>SeparateVertex() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt;<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>*&gt; ON_SubD::SeparateVertex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>separator0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>separator1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Separate (unweld) a vertex into two vertices. Parameters: vertex - [in] If the vertex is a nonmanifold vertex with multiple manifold sectors, it is separated into manifold sectors. If vertex is an interior vertex with 3 or more edges and optional_separator0 and optional_separator1 point to two of these edges, then the vertex is separated into 2 sectors along thos edges. If vertex is a boundary vertex with 4 or more edges and optional_separator0 or optional_separator1 point to an interior edge, then the vertex is separated into 2 sectors along that edge. Othewise the vertex is separated into single face sectors. separator0 - [in] separator1 - [in] Returns: If separation occured, then an array of the separated vertices is returned with the original vertex is the first element in the array. Otherwise an empty array is returned. </p>

</div>
</div>
<a id="a68f32cd4c67a3dde22722a3496cc1dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f32cd4c67a3dde22722a3496cc1dbd">&#9670;&nbsp;</a></span>SetAutomaticMeshToSubD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ON_SubD::SetAutomaticMeshToSubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#aef51f2ea460e4edd104e4216bc197f5b">ON_SubD::AutomaticMeshToSubDContext</a>&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bAutomaticallyCreateSubD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: context - [in] Situation where an <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> can automatically be converted into a subd. bAutomaticallyCreateSubD - [in] true if SubDs are automatically created when an <a class="el" href="class_o_n___mesh.html">ON_Mesh</a> is found in the specified context. false otherwise. </p>

</div>
</div>
<a id="a0afeb4a01c3e6508a1d679891f697142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0afeb4a01c3e6508a1d679891f697142">&#9670;&nbsp;</a></span>SetComponentMarkBitsFromSymmetryMotif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SetComponentMarkBitsFromSymmetryMotif </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Sets ON_SubDComponent MarkBits() to 0: component is not in a symmetry set motif n&gt;=1: The component is the the n-th element in the symmetry set with n=1 indicating the component in the primary motif. </p>

</div>
</div>
<a id="ac16eda814d8042574b046c41a5ec81f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16eda814d8042574b046c41a5ec81f5">&#9670;&nbsp;</a></span>SetComponentMarks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetComponentMarks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bClearBeforeSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>marked_component_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae20ebb4f459cc7081f69602646b30736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae20ebb4f459cc7081f69602646b30736">&#9670;&nbsp;</a></span>SetComponentStates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetComponentStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>component_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>states_to_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#ab728c0576fd5913bc1575b74997bddb5">ON_Object</a>.</p>

</div>
</div>
<a id="a7b75cd50d16e683c39d002a881a32a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b75cd50d16e683c39d002a881a32a96">&#9670;&nbsp;</a></span>SetComponentStates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetComponentStates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>component_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>states_to_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set states on an individual component. Parameters: component_ptr - [in] The states will be set on this component. states_to_set - [in] If a state is set in the states_to_set parameter, the same state will be set on the component. <br  />
 Returns: 0: no state settings changed on the component. 1: some state setting changed on the component. </p>

</div>
</div>
<a id="a72b8d1d5f3061cdc03a7bacf96935ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72b8d1d5f3061cdc03a7bacf96935ac7">&#9670;&nbsp;</a></span>SetComponentStatus() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetComponentStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>component_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>status_to_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a589f1fdc28f6259d1bd22bdedc9c4c76">ON_Object</a>.</p>

</div>
</div>
<a id="ac7eaa42f4b7920ec7e5fddcbe79b691e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7eaa42f4b7920ec7e5fddcbe79b691e">&#9670;&nbsp;</a></span>SetComponentStatus() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetComponentStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>status_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_base.html">ON_SubDComponentBase</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>status_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4551eaa7d35206b253de8f2cd2b2488c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4551eaa7d35206b253de8f2cd2b2488c">&#9670;&nbsp;</a></span>SetComponentStatus() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetComponentStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>component_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___component_status.html">ON_ComponentStatus</a>&#160;</td>
          <td class="paramname"><em>status_to_copy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Copy status settings to an individual component. Parameters: component_ptr - [in] The states will be copied to this component. status_to_copy - [in] Returns: 1: some state settings changed on the component. 1: some state setting changed on the component. </p>

</div>
</div>
<a id="a0b0131cc30d66feb9db6174f39c59c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b0131cc30d66feb9db6174f39c59c76">&#9670;&nbsp;</a></span>SetContentIsSymmetricForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SetContentIsSymmetricForExperts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bContentIsSymmetric</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If this SubD has the symmetry specified by this-&gt;<a class="el" href="class_o_n___sub_d.html#a5cc74c233cbff4a0c62f07710128c2e3">Symmetry()</a>, then call SetContentIsSymmetricForExperts(true). If this SubD does not have the symmetry specified by this-&gt;<a class="el" href="class_o_n___sub_d.html#a5cc74c233cbff4a0c62f07710128c2e3">Symmetry()</a>, then call SetContentIsSymmetricForExperts(false). Remarks: This is used internally by SubD modification code and you should probably pretend it does not exist. </p>

</div>
</div>
<a id="aceeb7387be3d5a0e942432b3cf5bbe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceeb7387be3d5a0e942432b3cf5bbe00">&#9670;&nbsp;</a></span>SetEdgeTags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetEdgeTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: number of tags that were changed. </p>

</div>
</div>
<a id="ac02264cb0f949a437e9c62cee449cd57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac02264cb0f949a437e9c62cee449cd57">&#9670;&nbsp;</a></span>SetEdgeTags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetEdgeTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cptr_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga09d9a731b3db1b876e97b6b43246c325">ON_SubDEdgeTag</a>&#160;</td>
          <td class="paramname"><em>edge_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: number of tags that were changed. </p>

</div>
</div>
<a id="a09239b446068c4d7e7412456d0928b5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09239b446068c4d7e7412456d0928b5f">&#9670;&nbsp;</a></span>SetFaceBoundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::SetFaceBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb86effb61c2c03db5f8c48e90d0a88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb86effb61c2c03db5f8c48e90d0a88e">&#9670;&nbsp;</a></span>SetFaceBoundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::SetFaceBoundary </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> *&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Expert user tool to set a face's boundary. Parameters: face - [in] Face that is in the subd with no edges. edges - [in] Array of edge_count pointers that form a loop. Caller is responsible for insuring edges and vertices appear only one time in the loop. edge_count - [in] Number of edges in the boundary. <br  />
 Returns: True if successful (all edge-face and vertex-face connections are set). False otherwise. Remarks: This tool is used during construction or editing of a SubD and the connection is added even if the result is an invalid face or edge. It is up to the expert user to make enough changes to create a valid SubD. </p>

</div>
</div>
<a id="a4ed37d3786c33275da7d806937470131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ed37d3786c33275da7d806937470131">&#9670;&nbsp;</a></span>SetFacePackingIdForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::SetFacePackingIdForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a>&#160;</td>
          <td class="paramname"><em>custom_packing_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: When a custom algorithm that is not built into <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> is used to pack the faces, this function must be called with an id that uniquely identifies the custom algorithm. The present SubD geometry will be used to set the value of <a class="el" href="class_o_n___sub_d.html#ae32373a2c26ae53a008f9f717919d9a7">FacePackingTopologyHash()</a>. Returns: True if faces are properly packed and custom_packing_id is not nil and unique. Otherwise the packing is reset to the default and false is returned. </p>

</div>
</div>
<a id="a20368cab20031945ad346dbdd297f4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20368cab20031945ad346dbdd297f4c4">&#9670;&nbsp;</a></span>SetFragmentColorsFromCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::SetFragmentColorsFromCallback </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLazySet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a>&#160;</td>
          <td class="paramname"><em>fragment_colors_settings_hash</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a>&#160;</td>
          <td class="paramname"><em>fragment_colors_mapping_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ON__UINT_PTR&#160;</td>
          <td class="paramname"><em>callback_context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___color.html">ON_Color</a>(*)(ON__UINT_PTR callback_context, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> &amp;mapping_tag, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;subd, <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> cptr, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;P, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_vector.html">ON_3dVector</a> &amp;N, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a> &amp;T, <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___surface_curvature.html">ON_SurfaceCurvature</a> &amp;K)&#160;</td>
          <td class="paramname"><em>color_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Use a callback to set the vertex colros in m_C[]. Parameters: bLazySet - [in] If bLazySet is true and fragment_colors_settings_hash and the current <a class="el" href="class_o_n___sub_d.html#ad7149920a9bed945f7e368b0e5cb21ee">FragmentColorsSettingsHash()</a> are equal, then nothing is changed. fragment_colors_settings_hash - [in] A that uniquely identifies the method and parameters being used to set the fragment vertex colors. In general this hash should depend on the value of this-&gt;<a class="el" href="class_o_n___sub_d.html#ae07d885e05ed47e9ed99ef3428814c07">GeometryContentSerialNumber()</a>, color_callback, and all values in the callback_context that determine vertex colors. Under no circumstances should this hash depend on this-&gt;<a class="el" href="class_o_n___sub_d.html#a5070b9f89eb3330080e5fc41283dd555">RenderContentSerialNumber()</a>. fragment_colors_mapping_tag - [in] If not applicable, pass <a class="el" href="class_o_n___mapping_tag.html#af868c2a84617ba0953f7fd4936e32050">ON_MappingTag::Unset</a>. A mapping tag indentifying what is setting the fragment colors. This is the only property that persists in SubD copies and saves in 3dm archives. Typically: m_mapping_id is an id you make up that identifies what is setting the colors (thickness, curvature, ...). m_mapping_type will be <a class="el" href="class_o_n___texture_mapping.html#a43ceae28c14840152691a1400b3a5140a10941e008b61769133ecf2fda021acdf" title="some kind of false color mapping used to set per vertex colors.">ON_TextureMapping::TYPE::false_colors</a>. m_mapping_crc is a field from the 1990s that the SHA1 hash handles better now and setting m_mapping_crc = ON_CRC32(0, sizeof(fragment_colors_settings_hash), &amp;fragment_colors_settings_hash) works well. works well. Typically, m_mapping_type = TYPE::false_colors. callback_context - [in] first parameter passed to color_callback() color_callback - [i] A callback function used to set the fragment vertex colors. </p>

</div>
</div>
<a id="a0cdb74d61f29ee06c737812b031c15ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdb74d61f29ee06c737812b031c15ad">&#9670;&nbsp;</a></span>SetFragmentColorsMappingTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SetFragmentColorsMappingTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set the fragment colors mapping tag. Remarks: Calling this-&gt;<a class="el" href="class_o_n___sub_d.html#a0cdb74d61f29ee06c737812b031c15ad">SetFragmentColorsMappingTag()</a> does not change existing cached fragment vertex colors. At an approprite time, call this-&gt;<a class="el" href="class_o_n___sub_d.html#a20368cab20031945ad346dbdd297f4c4">SetFragmentColorsFromCallback()</a> to update fragment vertex colors on any cached fragments.</p>
<p>SubD fragment vertex tag and colors are a mutable property. They can be changed by rendering applications as needed. </p>

</div>
</div>
<a id="ab196a6ea0bc70f34b7831463f9bd6972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab196a6ea0bc70f34b7831463f9bd6972">&#9670;&nbsp;</a></span>SetFragmentTextureCoordinates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::SetFragmentTextureCoordinates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLazy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If needed, set the frament texture coordinates. Parameters: mapping - [in] If <a class="el" href="class_o_n___sub_d.html#ad4fa8b5c8c6ee1ee64cf4c5a17fec5a7">ON_SubD::TextureMappingRequired()</a> is true, then you must pass a mapping with a tag that matches ON_SubDTextureMappingTag(). Otherwise, mapping is ignored and you may pass <a class="el" href="class_o_n___texture_mapping.html#aa08936d66f7269afa6ce15414fd55ddd" title="nil id">ON_TextureMapping::Unset</a>. bLazy - [in] If true and the m_T[] values were set using the same mapping parameters, then no calculation is performed. Returns: True if successful. Remarks: SubD texture domains and coordinates are a mutable property. They can be changed by rendering applications as needed. Call SetTextureCoordinatesFromFaceDomains() to restore them to the default values. </p>

</div>
</div>
<a id="a056119983695a5a9ed2ee5dbaa2c323f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056119983695a5a9ed2ee5dbaa2c323f">&#9670;&nbsp;</a></span>SetPerFaceColorsFromPackId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SetPerFaceColorsFromPackId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If a face has a nonzero PackId(), then its per face color is set to <a class="el" href="class_o_n___color.html#adff0477c192800ead531f3aa10fa0f7f">ON_Color::RandomColor</a>(f-&gt;PackId()). Otherwise, its per face color is cleared. </p>

</div>
</div>
<a id="ab7a441089953c2633fc5f8845e96987f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7a441089953c2633fc5f8845e96987f">&#9670;&nbsp;</a></span>SetPerFaceColorsFromSymmetryMotif()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SetPerFaceColorsFromSymmetryMotif </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If a SubD is symmetric and a face belongs to a symmetry set, then per face color is set according to the motif the face belongs to. Otherwise, its per face color is cleared. </p>

</div>
</div>
<a id="aa33c10824d856a4afd24f4847e414930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33c10824d856a4afd24f4847e414930">&#9670;&nbsp;</a></span>SetSubDAppearance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SetSubDAppearance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>subd_appearance</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set the SubD appearance (surface or control net). Parameters: subd_appearance - [in] <a class="el" href="group__open_n_u_r_b_s.html#gga0a25951e3c8f7324e2747162822b819aaaa0d528ba11ea1485d466dfe1ea40819">ON_SubDComponentLocation::Surface</a> or <a class="el" href="group__open_n_u_r_b_s.html#gga0a25951e3c8f7324e2747162822b819aa7cb4aa7a91fc1cc1d459f6a5894e3057">ON_SubDComponentLocation::ControlNet</a>. Remarks: This makes no changes to the information that defines the SubD. It does not require regeneration of the ON_SubDMeshFragments. Application display will need to be updated. </p>

</div>
</div>
<a id="a45857e8f068edbd334dbf62aa2f73f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45857e8f068edbd334dbf62aa2f73f79">&#9670;&nbsp;</a></span>SetSymmetryForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SetSymmetryForExperts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a> &amp;&#160;</td>
          <td class="paramname"><em>symmetry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>SetContentSerialNumber</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Sets the symmetry properties. Does not modify the subd geometry. Parameters: symmetry - [in] desired symmetry SetContentSerialNumber - [in] IF true, the current content serial number will be set on symmetry information saved on the subd. Returns: True if succesful </p>

</div>
</div>
<a id="a88258912dd469b7612f564fb0b67ada5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88258912dd469b7612f564fb0b67ada5">&#9670;&nbsp;</a></span>SetSymmetrySet() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_symmetry_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>primary_motif_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Create a edge symmetry set. Parameters: edge_symmetry_set - [in] Ordered symmetry set for this edge (no dupicates). (symmetry(edge_symmetry_set[i]) = edge_symmetry_set[i][(i+1)count]). primary_motif_index - [in] primary_motif_index &lt; edge_symmetry_set.UnsignedCount() specifies the primary motif edge in the set. Returns: If input is not valid or any edge in edge_symmetry_set[] is in an existing symmetry set, then 0 is returned and no changes are made. Otherwise the number of vertices in the edge_symmetry_set.UnsignedCount() is returned. </p>

</div>
</div>
<a id="a3bca082af1af5659761e4192342a3adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bca082af1af5659761e4192342a3adf">&#9670;&nbsp;</a></span>SetSymmetrySet() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_symmetry_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>primary_motif_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Create a face symmetry set. Parameters: face_symmetry_set - [in] Ordered symmetry set for this face (no dupicates). (symmetry(face_symmetry_set[i]) = face_symmetry_set[i][(i+1)count]). primary_motif_index - [in] primary_motif_index &lt; face_symmetry_set.UnsignedCount() specifies the primary motif face in the set. Returns: If input is not valid or any face in face_symmetry_set[] is in an existing symmetry set, then 0 is returned and no changes are made. Otherwise the number of vertices in the face_symmetry_set.UnsignedCount() is returned. </p>

</div>
</div>
<a id="a20ad47654816bb4ac09b9c0b43f6dbaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ad47654816bb4ac09b9c0b43f6dbaa">&#9670;&nbsp;</a></span>SetSymmetrySet() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertex_symmetry_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>primary_motif_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Create a vertex symmetry set. Parameters: vertex_symmetry_set - [in] Ordered symmetry set for this vertex (no dupicates). (symmetry(vertex_symmetry_set[i]) = vertex_symmetry_set[i][(i+1)count]). primary_motif_index - [in] primary_motif_index &lt; vertex_symmetry_set.UnsignedCount() specifies the primary motif vertex in the set. Returns: If input is not valid or any vertex in vertex_symmetry_set[] is in an existing symmetry set, then 0 is returned and no changes are made. Otherwise the number of vertices in the vertex_symmetry_set.UnsignedCount() is returned. </p>

</div>
</div>
<a id="a81b155c7050b24fc8019468b68444bae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b155c7050b24fc8019468b68444bae">&#9670;&nbsp;</a></span>SetSymmetrySet() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>component_symmetry_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>primary_motif_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Create a component symmetry set. Parameters: component_symmetry_set - [in] Ordered symmetry set for this component (no dupicates). (symmetry(component_symmetry_set[i]) = component_symmetry_set[i][(i+1)count]). primary_motif_index - [in] primary_motif_index &lt; component_symmetry_set.UnsignedCount() specifies the primary motif component in the set. Returns: If input is not valid or any component in component_symmetry_set[] is in an existing symmetry set, then 0 is returned and no changes are made. Otherwise the number of vertices in the component_symmetry_set.UnsignedCount() is returned. </p>

</div>
</div>
<a id="a54e70212443fcef88ca86206bf80489d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e70212443fcef88ca86206bf80489d">&#9670;&nbsp;</a></span>SetSymmetrySet() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_symmetry_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_symmetry_set_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>primary_motif_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a156b0a6f71b63c88448f2bcf81085c5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a156b0a6f71b63c88448f2bcf81085c5f">&#9670;&nbsp;</a></span>SetSymmetrySet() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *&#160;</td>
          <td class="paramname"><em>edge_symmetry_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_symmetry_set_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>primary_motif_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af17107366fa06924ed5aa2af0cf28ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17107366fa06924ed5aa2af0cf28ed5">&#9670;&nbsp;</a></span>SetSymmetrySet() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *&#160;</td>
          <td class="paramname"><em>face_symmetry_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>face_symmetry_set_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>primary_motif_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a241b8f62e8d139c59728fdd91ff4597c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241b8f62e8d139c59728fdd91ff4597c">&#9670;&nbsp;</a></span>SetSymmetrySet() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *<a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> *&#160;</td>
          <td class="paramname"><em>vertex_symmetry_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>vertex_symmetry_set_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>primary_motif_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98c06831a6172f6251c5d87888ac5baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c06831a6172f6251c5d87888ac5baf">&#9670;&nbsp;</a></span>SetSymmetrySetNextForExperts() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySetNextForExperts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bComponentIsPrimaryMotif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>next_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool is for expert users with a complete and detailed understanding of creating valid symmetry sets and who carefully and thoroughly test every line of code. If that is not the case, use <a class="el" href="class_o_n___sub_d.html#a20ad47654816bb4ac09b9c0b43f6dbaa">SetSymmetrySet()</a> to create symmetry sets. Parameters: component - [in] The component to unconditionally modify. bComponentIsPrimaryMotif - [in] True if component is the primary motif in the set. There is exactly one primary motif in each symmetry set. next_component - [in] The next component in the symmetry set. If the symmetry set is a singleton (the symmetry fixes component), then next_component = component. Returns: True if input was valid and component symmetry set information was set as specified. False if input was not valid (see description above) and the component symmetry set information was removed. Remarks: A symmetry set is an ordered loop of components with a single one identificed as the primary motif component in the set. If N is the period of the symmetry, then the number of components in a symmetry set is a divisor of N (including 1 for a fixed component). Distinct symmetry sets never intersect and they partition the entire SubD into disjoint subsets. </p>

</div>
</div>
<a id="a2edfe7f2647dff8f87a4e30a5d0c3dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2edfe7f2647dff8f87a4e30a5d0c3dea">&#9670;&nbsp;</a></span>SetSymmetrySetNextForExperts() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySetNextForExperts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bEdgeIsPrimaryMotif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>next_edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool is for expert users with a complete and detailed understanding of creating valid symmetry sets and who carefully and thoroughly test every line of code. If that is not the case, use <a class="el" href="class_o_n___sub_d.html#a20ad47654816bb4ac09b9c0b43f6dbaa">SetSymmetrySet()</a> to create symmetry sets. Parameters: edge - [in] The edge to unconditionally modify. bEdgeIsPrimaryMotif - [in] True if edge is the primary motif in the set. There is exactly one primary motif in each symmetry set. next_edge - [in] The next edge in the symmetry set. If the symmetry set is a singleton (the symmetry fixes edge), then next_edge = edge. Returns: True if input was valid and edge symmetry set information was set as specified. False if input was not valid (see description above) and the edge symmetry set information was removed. Remarks: A symmetry set is an ordered loop of components with a single one identificed as the primary motif component in the set. If N is the period of the symmetry, then the number of components in a symmetry set is a divisor of N (including 1 for a fixed component). Distinct symmetry sets never intersect and they partition the entire SubD into disjoint subsets. </p>

</div>
</div>
<a id="a218dd4b2a690034c286b5dce052e26aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a218dd4b2a690034c286b5dce052e26aa">&#9670;&nbsp;</a></span>SetSymmetrySetNextForExperts() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySetNextForExperts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bFaceIsPrimaryMotif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>next_face</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool is for expert users with a complete and detailed understanding of creating valid symmetry sets and who carefully and thoroughly test every line of code. If that is not the case, use <a class="el" href="class_o_n___sub_d.html#a20ad47654816bb4ac09b9c0b43f6dbaa">SetSymmetrySet()</a> to create symmetry sets. Parameters: face - [in] The face to unconditionally modify. bFaceIsPrimaryMotif - [in] True if face is the primary motif in the set. There is exactly one primary motif in each symmetry set. next_face - [in] The next face in the symmetry set. If the symmetry set is a singleton (the symmetry fixes face), then next_face = face. Returns: True if input was valid and face symmetry set information was set as specified. False if input was not valid (see description above) and the face symmetry set information was removed. Remarks: A symmetry set is an ordered loop of components with a single one identificed as the primary motif component in the set. If N is the period of the symmetry, then the number of components in a symmetry set is a divisor of N (including 1 for a fixed component). Distinct symmetry sets never intersect and they partition the entire SubD into disjoint subsets. </p>

</div>
</div>
<a id="a98053281138446a2ce64015699402803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98053281138446a2ce64015699402803">&#9670;&nbsp;</a></span>SetSymmetrySetNextForExperts() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySetNextForExperts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVertexIsPrimaryMotif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>next_vertex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool is for expert users with a complete and detailed understanding of creating valid symmetry sets and who carefully and thoroughly test every line of code. If that is not the case, use <a class="el" href="class_o_n___sub_d.html#a20ad47654816bb4ac09b9c0b43f6dbaa">SetSymmetrySet()</a> to create symmetry sets. Parameters: vertex - [in] The vertex to unconditionally modify. bVertexIsPrimaryMotif - [in] True if vertex is the primary motif in the set. There is exactly one primary motif in each symmetry set. next_vertex - [in] The next vertex in the symmetry set. If the symmetry set is a singleton (the symmetry fixes vertex), then next_vertex = vertex. Returns: True if input was valid and vertex symmetry set information was set as specified. False if input was not valid (see description above) and the vertex symmetry set information was removed. Remarks: A symmetry set is an ordered loop of components with a single one identificed as the primary motif component in the set. If N is the period of the symmetry, then the number of components in a symmetry set is a divisor of N (including 1 for a fixed component). Distinct symmetry sets never intersect and they partition the entire SubD into disjoint subsets. </p>

</div>
</div>
<a id="a59a640b6a0de2f939b408a04e4f6ea7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a640b6a0de2f939b408a04e4f6ea7f">&#9670;&nbsp;</a></span>SetSymmetrySetsForExperts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::SetSymmetrySetsForExperts </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUseCleanupTolerance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Sets the symmetry sets. Does not modify the subd geometry or the Symmetry property. The subd must statisfiy these conditions:</p><ol type="1">
<li>The Symmetry property must be correctly set.</li>
<li>This subd must be symmetric</li>
<li>The subd components that generate the motif must be first in the vertex, edge, and face iterators. Parameters: bUseCleanupTolerance - [in] true to use symmetry.CleanupTolrance() false to use ON_Symmetry::Zerotolerance. Returns: True if succesful </li>
</ol>

</div>
</div>
<a id="ac8977da9839a8417cc2d377677c30c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8977da9839a8417cc2d377677c30c38">&#9670;&nbsp;</a></span>SetTextureCoordinateType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SetTextureCoordinateType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a>&#160;</td>
          <td class="paramname"><em>texture_coordinate_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set the texture coordinate type. Parameters: texture_coordinate_type - [in] Type of texture coordinates. If <a class="el" href="group__open_n_u_r_b_s.html#gga6c7104f591f9fbf8f6ab27894df3e33fac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDTextureCoordinateType::Unset</a> or ON_SubDTextureCoordinateType::Custom, is passed, the type setting is changed but no changes are made to texture coordinates. Remarks: Call SetTextureCoordinates() to restore them to the default values.</p>
<p>If texture_coordinate_type is <a class="el" href="group__open_n_u_r_b_s.html#gga6c7104f591f9fbf8f6ab27894df3e33fa89f9b9ddf04ecff851cdf05c1617c636">ON_SubDTextureCoordinateType::FromMapping</a>, then the mapping this-&gt;TextureCoordinateMapping() is used. You may call this-&gt;SetTextureCoordinateMapping() to set the mapping.</p>
<p>Calling this-&gt;<a class="el" href="class_o_n___sub_d.html#ac8977da9839a8417cc2d377677c30c38">SetTextureCoordinateType()</a> does not change existing cached texture coordinates. At an approprite time, call <a class="el" href="class_o_n___sub_d.html#ab196a6ea0bc70f34b7831463f9bd6972">SetFragmentTextureCoordinates()</a> to update texture coordinates on any cached fragments.</p>
<p>SubD texture coordinate type and fragment texture coordinates are a mutable property. They can be changed by rendering applications as needed. </p>

</div>
</div>
<a id="a61d66807128a3b50a72d05d67c300845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d66807128a3b50a72d05d67c300845">&#9670;&nbsp;</a></span>SetTextureMappingTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SetTextureMappingTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Set the texture mapping tag. Remarks: The texture mapping tag should be applied only when this-&gt;<a class="el" href="class_o_n___sub_d.html#a55efd114115ec1d2029b1a223c00d220">TextureCoordinateType()</a> is <a class="el" href="group__open_n_u_r_b_s.html#gga6c7104f591f9fbf8f6ab27894df3e33fa89f9b9ddf04ecff851cdf05c1617c636">ON_SubDTextureCoordinateType::FromMapping</a>.</p>
<p>Calling this-&gt;<a class="el" href="class_o_n___sub_d.html#a61d66807128a3b50a72d05d67c300845">SetTextureMappingTag()</a> does not change existing cached texture coordinates. At an approprite time, call this-&gt;<a class="el" href="class_o_n___sub_d.html#ab196a6ea0bc70f34b7831463f9bd6972">SetFragmentTextureCoordinates()</a> to update texture coordinates on any cached fragments.</p>
<p>SubD texture domains and coordinates are a mutable property. They can be changed by rendering applications as needed. </p>

</div>
</div>
<a id="a0bbd256072e9d3f8f061f230b7dbda8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bbd256072e9d3f8f061f230b7dbda8a">&#9670;&nbsp;</a></span>SetVertexTags() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetVertexTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: ci_list - [in] Array of ci_count <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> values that identify the vertices. Elements that do not identifiy a SubD vertex are ignored. ci_count - [in] Number of elements in the ci_list[] array. vertex_tag - [in] Desired tag. If a vertex has the desired tag or cannot accept the desired tag, then that vertex is skipped. If vertex_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a>, then every edge touching that vertex is converted to a crease. Returns: number of vertex tags that were changed. </p>

</div>
</div>
<a id="a762df4837a7d0183fa5c71db11a5d565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762df4837a7d0183fa5c71db11a5d565">&#9670;&nbsp;</a></span>SetVertexTags() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SetVertexTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cptr_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: ci_list - [in] Array of ci_count <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> values that identify the vertices. Elements that do not identifiy a SubD vertex are ignored. ci_count - [in] Number of elements in the ci_list[] array. vertex_tag - [in] Desired tag. If a vertex has the desired tag or cannot accept the desired tag, then that vertex is skipped. If vertex_tag is <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375a45671f70ac97ff86643523f29eb4d3b9">ON_SubDVertexTag::Corner</a>, then every edge touching that vertex is converted to a crease. Returns: number of vertex tags that were changed. </p>

</div>
</div>
<a id="ad64b79873608711a9c28a6470e3c1caa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64b79873608711a9c28a6470e3c1caa">&#9670;&nbsp;</a></span>ShareContentsFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ShareContentsFrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>subd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: The subdivision information referenced by src_subd will be shared with this Remarks: <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> base class information, like <a class="el" href="class_o_n___user_data.html">ON_UserData</a>, is not copied or shared. </p>

</div>
</div>
<a id="a5f148e3e9c83b03471ffbd8c37dd878c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f148e3e9c83b03471ffbd8c37dd878c">&#9670;&nbsp;</a></span>ShareDimple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ShareDimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class ON_SubDMeshImpl &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad284313958594074867433d84f9f6a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad284313958594074867433d84f9f6a60">&#9670;&nbsp;</a></span>ShareDimple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::ShareDimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63166832c7481143c3ce7ae22f123f88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63166832c7481143c3ce7ae22f123f88">&#9670;&nbsp;</a></span>SizeOf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SizeOf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a0299df21bfed90d7b5bfb24cdcf5e6c1">ON_Object</a>.</p>

</div>
</div>
<a id="a923ad1077006530331100a971eccfebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a923ad1077006530331100a971eccfebc">&#9670;&nbsp;</a></span>SizeOfActiveElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_SubD::SizeOfActiveElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This is a debugging too used to study how efficiently SubDs are using memory. Returns: Total operating system heap (in bytes) of memory in this SubD's ON_FixedSizePools that is currently used by active elements, including active mesh fragments. Remarks: <a class="el" href="class_o_n___sub_d.html#abc185f66a3babe71306acba723ddc8ef">SizeOfAllElements()</a> = <a class="el" href="class_o_n___sub_d.html#a923ad1077006530331100a971eccfebc">SizeOfActiveElements()</a> + <a class="el" href="class_o_n___sub_d.html#aebdb447f713f20a880f0e96b8d90b2f4">SizeOfUnusedElements()</a>. </p>

</div>
</div>
<a id="a9fbb68941c62f35082b5fd172e12d122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fbb68941c62f35082b5fd172e12d122">&#9670;&nbsp;</a></span>SizeOfActiveMeshFragments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_SubD::SizeOfActiveMeshFragments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Tool for debugging mesh fragments memory use. Returns: Operating system heap memory (in bytes) that are used by active mesh fragments. Remarks: <a class="el" href="class_o_n___sub_d.html#a0a46cd73a40f53f0f4bc5d34feac346b">SizeOfAllMeshFragments()</a> = <a class="el" href="class_o_n___sub_d.html#a9fbb68941c62f35082b5fd172e12d122">SizeOfActiveMeshFragments()</a> + <a class="el" href="class_o_n___sub_d.html#aaa180112bfc9c40e962b7709ef41fa50">SizeOfUnusedMeshFragments()</a>. </p>

</div>
</div>
<a id="abc185f66a3babe71306acba723ddc8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc185f66a3babe71306acba723ddc8ef">&#9670;&nbsp;</a></span>SizeOfAllElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_SubD::SizeOfAllElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This is a debugging too used to study how efficiently SubDs are using memory. Returns: Total operating system heap (in bytes) used by this SubD's ON_FixedSizePools, inlcude the mesh fragments pool. Remarks: <a class="el" href="class_o_n___sub_d.html#abc185f66a3babe71306acba723ddc8ef">SizeOfAllElements()</a> = <a class="el" href="class_o_n___sub_d.html#a923ad1077006530331100a971eccfebc">SizeOfActiveElements()</a> + <a class="el" href="class_o_n___sub_d.html#aebdb447f713f20a880f0e96b8d90b2f4">SizeOfUnusedElements()</a>. </p>

</div>
</div>
<a id="a0a46cd73a40f53f0f4bc5d34feac346b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a46cd73a40f53f0f4bc5d34feac346b">&#9670;&nbsp;</a></span>SizeOfAllMeshFragments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_SubD::SizeOfAllMeshFragments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Tool for debugging mesh fragments memory use. Returns: Total operating system heap memory (in bytes) used by the mesh fragments pool. Remarks: <a class="el" href="class_o_n___sub_d.html#a0a46cd73a40f53f0f4bc5d34feac346b">SizeOfAllMeshFragments()</a> = <a class="el" href="class_o_n___sub_d.html#a9fbb68941c62f35082b5fd172e12d122">SizeOfActiveMeshFragments()</a> + <a class="el" href="class_o_n___sub_d.html#aaa180112bfc9c40e962b7709ef41fa50">SizeOfUnusedMeshFragments()</a>. </p>

</div>
</div>
<a id="aebdb447f713f20a880f0e96b8d90b2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebdb447f713f20a880f0e96b8d90b2f4">&#9670;&nbsp;</a></span>SizeOfUnusedElements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_SubD::SizeOfUnusedElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This is a debugging too used to study how efficiently SubDs are using memory. Returns: Total operating system heap (in bytes) of memory in this SubD's ON_FixedSizePools that is reserved but not currently used, including unused mesh fragments. Remarks: <a class="el" href="class_o_n___sub_d.html#abc185f66a3babe71306acba723ddc8ef">SizeOfAllElements()</a> = <a class="el" href="class_o_n___sub_d.html#a923ad1077006530331100a971eccfebc">SizeOfActiveElements()</a> + <a class="el" href="class_o_n___sub_d.html#aebdb447f713f20a880f0e96b8d90b2f4">SizeOfUnusedElements()</a>. </p>

</div>
</div>
<a id="aaa180112bfc9c40e962b7709ef41fa50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa180112bfc9c40e962b7709ef41fa50">&#9670;&nbsp;</a></span>SizeOfUnusedMeshFragments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t ON_SubD::SizeOfUnusedMeshFragments </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Tool for debugging mesh fragments memory use. Returns: Operating system heap memory (in bytes) that has been reserved for mesh fragments but is not currently used by active mesh fragments. Remarks: <a class="el" href="class_o_n___sub_d.html#a0a46cd73a40f53f0f4bc5d34feac346b">SizeOfAllMeshFragments()</a> = <a class="el" href="class_o_n___sub_d.html#a9fbb68941c62f35082b5fd172e12d122">SizeOfActiveMeshFragments()</a> + <a class="el" href="class_o_n___sub_d.html#aaa180112bfc9c40e962b7709ef41fa50">SizeOfUnusedMeshFragments()</a>. </p>

</div>
</div>
<a id="a574b138eedad001cece9648b81f7d5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a574b138eedad001cece9648b81f7d5b3">&#9670;&nbsp;</a></span>SnapPointsToPlane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SnapPointsToPlane </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___plane_equation.html">ON_PlaneEquation</a>&#160;</td>
          <td class="paramname"><em>plane_equation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>distance_tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000079">Deprecated:</a></b></dt><dd>Obsolete - use ProjectVerticesToPlane </dd></dl>

</div>
</div>
<a id="ab5df6a826b93bb3c8d61861429fa56aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5df6a826b93bb3c8d61861429fa56aa">&#9670;&nbsp;</a></span>SolidOrientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* int ON_SubD::SolidOrientation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Topology Queries Description: Determine solid orientation of the active level. Returns: +2 subd is a solid but orientation cannot be computed +1 subd is a solid with outward facing normals -1 subd is a solid with inward facing normals 0 subd is not a solid See Also: <a class="el" href="class_o_n___sub_d.html#a56b5ba53e60b15c972d829afca431625">ON_SubD::IsSolid</a> </p>

</div>
</div>
<a id="a4a6fcb55c62a363333b4ac1fd05654b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6fcb55c62a363333b4ac1fd05654b7">&#9670;&nbsp;</a></span>SplitEdge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::SplitEdge </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>vertex_location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Divide an edge into two contiguous edges. The input edge is modifed to terminate at the new vertex. The new edge begins at the new vertex and ends at the orginal edge's m_vertex[1]. edge - [in] edge to split. vertex_location - [in] location of the new vertex vertex. If vertex_location == ON_ON_3dPoint::UnsetPoint, then the edge's midpoint is used. Returns: A pointer to the new edge or nullptr if the input is not valid. Remarks: After all editing operations are completed, you must call this-&gt;UpdateEdgeSectorCoefficients(true) before evaluation. </p>

</div>
</div>
<a id="a476a0ec674b8b841ba6e1ba13cc55895"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476a0ec674b8b841ba6e1ba13cc55895">&#9670;&nbsp;</a></span>SplitEdge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubD::SplitEdge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a>&#160;</td>
          <td class="paramname"><em>eptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n__3d_point.html">ON_3dPoint</a>&#160;</td>
          <td class="paramname"><em>vertex_location</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>new_edge_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Divide an edge into two contiguous edges. edge - [in] edge to split. vertex_location - [in] location of the new vertex vertex. If vertex_location == ON_ON_3dPoint::UnsetPoint, then the edge's midpoint is used. new_edge_end - [in] This paratmer is 0 or 1 and dtermines where the new edge is inserted. Below v0 = input eptr.RelativeVertex(0), v1 = new vertex, v2 = input eptr.RelativeVertex(1), and new_eptr = returned edge pointer. If edge_end is 0, new_eptr is first: v0 = new_eptr.RelativeVertex(0), v1 = new_eptr.RelativeVertex(1)=eptr.RelativeVertex(0), v2 = eptr.RelativeVertex(1). If edge_end is 1, new_eptr is last: v0 = eptr.RelativeVertex(0), v1 = eptr.RelativeVertex(1)=new_eptr.RelativeVertex(0), v2 = new_eptr.RelativeVertex(1). Returns: A pointer to the new edge or <a class="el" href="class_o_n___sub_d_edge_ptr.html#aa7df434a8cf517a79e3b9adfe2fc61e3">ON_SubDEdgePtr::Null</a> if the input is not valid. Remarks: After all editing operations are completed, you must clear the evaluation cache and call this-&gt;UpdateEdgeSectorCoefficients(true). </p>

</div>
</div>
<a id="a5ffbe51504da52e965543f17ed14dc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffbe51504da52e965543f17ed14dc58">&#9670;&nbsp;</a></span>SplitFace() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::SplitFace </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Divide a face into two faces by inserting an edge connecting the specified vertices. Parameters: face - [in] A face with at least four edges. v0 - [in] v1 - [in] Face vertices of the inserted edge's ends. Returns: A pointer to the inserted edge. The inserted edge runs from v0 to v1. ON_SubDEdge.Face(0) is the original face and ON_SubDEdge::Face(1) is the added face. The first edge of the input face remains the first edge of face. <br  />
 The inserted edge is the first edge of the added face. </p>

</div>
</div>
<a id="a0a88070ccf56241173759bb782b71759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a88070ccf56241173759bb782b71759">&#9670;&nbsp;</a></span>SplitFace() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubD::SplitFace </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>new_face_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Divide a face into two faces by inserting an edge connecting the specified vertices. Parameters: face - [in] A face with at least four edges. v0 - [in] v1 - [in] Face vertices of the inserted edge's ends. new_face_side - [in] 0: The new face will be on the left side of the inserted edge. 0: The new face will be on the right side of the inserted edge. Returns: The edge and edgeptr are both being af both oriented The inserted edge and returned edge ptr runs from face-&gt;Vertex(fvi0) to face-&gt;Vertex(fvi1). the new face is SplitFace(...).RelativeFace(new_face_side) and the original face is SplitFace(...).RelativeFace(new_face_side). </p>

</div>
</div>
<a id="aa25aad61bc081919f353e6f1b53f06b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25aad61bc081919f353e6f1b53f06b3">&#9670;&nbsp;</a></span>SplitFace() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::SplitFace </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fvi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fvi1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Divide a face into two faces by inserting an edge connecting the specified vertices. Parameters: face - [in] A face with at least four edges. fvi0 - [in] fvi1 - [in] Face vertex indices of the inserted edge's ends. Returns: A pointer to the inserted edge. The inserted edge runs from face-&gt;Vertex(fvi0) to face-&gt;Vertex(fvi1). ON_SubDEdge.Face(0) is the original face and ON_SubDEdge::Face(1) is the added face. The first edge of both faces is the inserted edge. </p>

</div>
</div>
<a id="a1d2379bcc366ba6c2b0fd1297a12c687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2379bcc366ba6c2b0fd1297a12c687">&#9670;&nbsp;</a></span>SplitFace() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge_ptr.html">ON_SubDEdgePtr</a> ON_SubD::SplitFace </td>
          <td>(</td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fvi0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>fvi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>new_face_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Divide a face into two faces by inserting an edge connecting the specified vertices. Parameters: face - [in] A face with at least four edges. fvi0 - [in] fvi1 - [in] Face vertex indices of the inserted edge's ends. new_face_side - [in] 0: The new face will be on the left side of the inserted edge. 0: The new face will be on the right side of the inserted edge. Returns: The edge and edgeptr are both being af both oriented The inserted edge and returned edge ptr runs from face-&gt;Vertex(fvi0) to face-&gt;Vertex(fvi1). the new face is SplitFace(...).RelativeFace(new_face_side) and the original face is SplitFace(...).RelativeFace(new_face_side). </p>

</div>
</div>
<a id="a21038cd5c25155c24005e311b9c055e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21038cd5c25155c24005e311b9c055e6">&#9670;&nbsp;</a></span>SubDAppearance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> ON_SubD::SubDAppearance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the SubD appearance (surface or control net); Returns: <a class="el" href="group__open_n_u_r_b_s.html#gga0a25951e3c8f7324e2747162822b819aaaa0d528ba11ea1485d466dfe1ea40819">ON_SubDComponentLocation::Surface</a> or <a class="el" href="group__open_n_u_r_b_s.html#gga0a25951e3c8f7324e2747162822b819aa7cb4aa7a91fc1cc1d459f6a5894e3057">ON_SubDComponentLocation::ControlNet</a>. </p>

</div>
</div>
<a id="aeb2ba99a61176cc622096c2ea4f3b969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb2ba99a61176cc622096c2ea4f3b969">&#9670;&nbsp;</a></span>SubDControlNetMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_mesh.html">ON_SubDMesh</a> ON_SubD::SubDControlNetMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the cached control net mesh for this subD. Returns: A mesh of the SubD control net. Remarks: The mesh is a reference counted mesh managed by this <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. </p>

</div>
</div>
<a id="a753cbf6fa759787e06c54e4c76f6a702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753cbf6fa759787e06c54e4c76f6a702">&#9670;&nbsp;</a></span>SubDHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_hash.html">ON_SubDHash</a> ON_SubD::SubDHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga7901fb222b1b25e32978f0b34ba7234a">ON_SubDHashType</a>&#160;</td>
          <td class="paramname"><em>hash_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bForceUpdate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get a hash that uniquely identifies the topology or geometry of this SubD. Parameters: hash_type - [in] To see what is included in the various hashes, read the documentation for the ON_SubDHashType enum. bForceUpdate - [in] When in doubt pass false. The SubD hashes are mutable and cached. When code properly manages <a class="el" href="class_o_n___sub_d.html#ae07d885e05ed47e9ed99ef3428814c07">GeometryContentSerialNumber()</a>, then SubDHash(hash_type,false) will always return the correct answer. This is the expected behavior. If code directly modifies SubD components and fails to call <a class="el" href="class_o_n___sub_d.html#ae31e75e9f0cbdd8c55e725a30e36de20">ChangeGeometryContentSerialNumberForExperts()</a>, then it is possible a stale hash will be returned. Setting bForceUpdate = true forces the SHA1 values to be recalculated from scratch. For extremely large SubDs, this recalculation can be time consuming. </p>

</div>
</div>
<a id="a93935562ff8f61c0c180f2485a2419a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93935562ff8f61c0c180f2485a2419a7">&#9670;&nbsp;</a></span>SubDimple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class ON_SubDimple* ON_SubD::SubDimple </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Pretend this function and ON_SubDimple do not exist. Returns: Something that you are pretending does not exist. Remarks: It is intentional that the definition of ON_SubDimple class is not available in the opennurbs library interface (not in a header file). The size and design of ON_SubDimple will change constantly. If you choose to hack and whack so you can dereference an ON_SubDimple* pointer, then your code will crash unpredictably. </p>

</div>
</div>
<a id="a8b0826c8dfef46b4794eadd8f67309c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0826c8dfef46b4794eadd8f67309c7">&#9670;&nbsp;</a></span>SubDimpleUseCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::SubDimpleUseCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a685e0d610153a2da25ebc2cdceeb0506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a685e0d610153a2da25ebc2cdceeb0506">&#9670;&nbsp;</a></span>SubdivideSector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::SubdivideSector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>center_vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>component_ring</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_ring_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="class_o_n___sub_d___fixed_size_heap.html">ON_SubD_FixedSizeHeap</a> &amp;&#160;</td>
          <td class="paramname"><em>fsh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a82a114c218825fa31a4adbb22e4f5a21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a114c218825fa31a4adbb22e4f5a21">&#9670;&nbsp;</a></span>SubDModifiedNofification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SubDModifiedNofification </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: When finished editing a SubD, call this function to delete all cached evaluation values and update all vertex tag, edge tags, edge sector coefficients. Remarks: This function is the most reliable (and heavy handed) way to update SubD component information. Expert users can choose to be more selective when certain about exactly what needs to be modified. </p>

</div>
</div>
<a id="a05378b66322188c768f1c60754afc4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05378b66322188c768f1c60754afc4da">&#9670;&nbsp;</a></span>SubDSurfaceMesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_mesh.html">ON_SubDMesh</a> ON_SubD::SubDSurfaceMesh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Get the cached surface mesh for this subD. Returns: A mesh of the SubD surface. Remarks: The mesh is a reference counted mesh managed by this <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>. </p>

</div>
</div>
<a id="ab3592b175f1d85167fb47bead2cb94cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3592b175f1d85167fb47bead2cb94cb">&#9670;&nbsp;</a></span>SurfacePointRadiusFromControlPointRadius()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double ON_SubD::SurfacePointRadiusFromControlPointRadius </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>point_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>control_point_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: point_count - [in] &gt;= 3 Number of control points in a regular planar SubD ngon with creased edges. control_point_radius - [in] Distance from an ngon control point to the ngon center. Returns: Distance from an ngon surface point to the ngon center. See Also: <a class="el" href="class_o_n___sub_d.html#ab3592b175f1d85167fb47bead2cb94cb">ON_SubD::SurfacePointRadiusFromControlPointRadius()</a> </p>

</div>
</div>
<a id="a8abe50d4a88701c0df1cd6df7bbb3a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abe50d4a88701c0df1cd6df7bbb3a28">&#9670;&nbsp;</a></span>SwapContents()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void ON_SubD::SwapContents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab38031c83f98cd09c9df32ca4adb2cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38031c83f98cd09c9df32ca4adb2cce">&#9670;&nbsp;</a></span>SwapCoordinates()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::SwapCoordinates </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#a737d7b1433104a39298629931e899cd4">ON_Geometry</a>.</p>

</div>
</div>
<a id="a196e5c15a52a3a7bf909e1effc8593c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a196e5c15a52a3a7bf909e1effc8593c6">&#9670;&nbsp;</a></span>SwapDimple() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SwapDimple </td>
          <td>(</td>
          <td class="paramtype">class ON_SubDMeshImpl &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a162c2720914800b1aeead7fca9860df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162c2720914800b1aeead7fca9860df5">&#9670;&nbsp;</a></span>SwapDimple() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ON_SubD::SwapDimple </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cc74c233cbff4a0c62f07710128c2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc74c233cbff4a0c62f07710128c2e3">&#9670;&nbsp;</a></span>Symmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___symmetry.html">ON_Symmetry</a>&amp; ON_SubD::Symmetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SubD symmetry interface Returns: Current symmetry propeties. </p>

</div>
</div>
<a id="a738471d2bb7144aed7efde9308562c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738471d2bb7144aed7efde9308562c6a">&#9670;&nbsp;</a></span>SymmetrySetCount() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::SymmetrySetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge - [in] Returns: Number of elements in the edges's symmetry set. 0 indicates the edge is not in a symmetry set. 1 indicates the set is a sington (the edge is fixed by the symmetry - it might be reversed). </p>

</div>
</div>
<a id="afb14dd64195fc5954c3e9bbff3bb0e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb14dd64195fc5954c3e9bbff3bb0e8f">&#9670;&nbsp;</a></span>SymmetrySetCount() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::SymmetrySetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: face - [in] Returns: Number of elements in the face's symmetry set. 0 indicates the component is not in a symmetry set. 1 indicates the set is a sington (the face is fixed by the symmetry - it might be rotated). </p>

</div>
</div>
<a id="af372b82afc16deb824322ca6b4641d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af372b82afc16deb824322ca6b4641d42">&#9670;&nbsp;</a></span>SymmetrySetCount() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::SymmetrySetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: vertex - [in] Returns: Number of elements in the component's symmetry set. 0 indicates the component is not in a symmetry set. 1 indicates the set is a sington (the verrtex is fixed by the symmetry). </p>

</div>
</div>
<a id="ad56972f83e690de4ba2da1300f6cb6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56972f83e690de4ba2da1300f6cb6cf">&#9670;&nbsp;</a></span>SymmetrySetCount() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> unsigned ON_SubD::SymmetrySetCount </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>cptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: cptr - [in] Returns: Number of elements in the component's symmetry set. 0 indicates the component is not in a symmetry set. 1 indicates the set is a sington (the component is fixed by the symmetry). </p>

</div>
</div>
<a id="a053c18962230daf6e175356c617541a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053c18962230daf6e175356c617541a4">&#9670;&nbsp;</a></span>SymmetrySetNext() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::SymmetrySetNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge - [in] Returns: The next edge in the symmetry set. Remarks: A symmetry set is an ordered loop of components with a single one identificed as the primary motif component in the set. If N is the period of the symmetry, then the number of components in a symmetry set is a divisor of N (including 1 for a fixed component). Distinct symmetry sets never intersect and they partition the entire SubD into disjoint subsets. </p>

</div>
</div>
<a id="ac1448fe65c2ac8bd6e23d5e494594e99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1448fe65c2ac8bd6e23d5e494594e99">&#9670;&nbsp;</a></span>SymmetrySetNext() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::SymmetrySetNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: face - [in] Returns: The next face in the symmetry set. Remarks: A symmetry set is an ordered loop of components with a single one identificed as the primary motif component in the set. If N is the period of the symmetry, then the number of components in a symmetry set is a divisor of N (including 1 for a fixed component). Distinct symmetry sets never intersect and they partition the entire SubD into disjoint subsets. </p>

</div>
</div>
<a id="ad7b3833dd8afe21acd482e2f6eca18b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b3833dd8afe21acd482e2f6eca18b2">&#9670;&nbsp;</a></span>SymmetrySetNext() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::SymmetrySetNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: vertex - [in] Returns: The next vertex in the symmetry set. Remarks: A symmetry set is an ordered loop of components with a single one identificed as the primary motif component in the set. If N is the period of the symmetry, then the number of components in a symmetry set is a divisor of N (including 1 for a fixed component). Distinct symmetry sets never intersect and they partition the entire SubD into disjoint subsets. </p>

</div>
</div>
<a id="a92e412fe149acd8b8215597f5c5cb982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e412fe149acd8b8215597f5c5cb982">&#9670;&nbsp;</a></span>SymmetrySetNext() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> ON_SubD::SymmetrySetNext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>cptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: component - [in] Returns: The next component in the symmetry set. If 1 == <a class="el" href="class_o_n___sub_d.html#ad7b3833dd8afe21acd482e2f6eca18b2">SymmetrySetNext()</a>.ComponentDirection(), the returned component is the set's primary motif. Remarks: A symmetry set is an ordered loop of components with a single one identificed as the primary motif component in the set. If N is the period of the symmetry, then the number of components in a symmetry set is a divisor of N (including 1 for a fixed component). Distinct symmetry sets never intersect and they partition the entire SubD into disjoint subsets. </p>

</div>
</div>
<a id="af9bf5156a8bf20197bb48137415faa4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bf5156a8bf20197bb48137415faa4a">&#9670;&nbsp;</a></span>SymmetrySetPrimaryMotif() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a>* ON_SubD::SymmetrySetPrimaryMotif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_edge.html">ON_SubDEdge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge - [in] Returns: If the edge is in a symmetry set, the primary motif edge is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="afba047f5fa44bb1c91f459e39ce79fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba047f5fa44bb1c91f459e39ce79fb1">&#9670;&nbsp;</a></span>SymmetrySetPrimaryMotif() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a>* ON_SubD::SymmetrySetPrimaryMotif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_face.html">ON_SubDFace</a> *&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: edge - [in] Returns: If the face is in a symmetry set, the primary motif face is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="a3b5e07a681341dd66cff32e86a4737c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b5e07a681341dd66cff32e86a4737c1">&#9670;&nbsp;</a></span>SymmetrySetPrimaryMotif() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::SymmetrySetPrimaryMotif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a> *&#160;</td>
          <td class="paramname"><em>vertex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: vertex - [in] Returns: If the vertex is in a symmetry set, the primary motif vertex is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="a6f6642a5962f54c3b33048fea033b785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6642a5962f54c3b33048fea033b785">&#9670;&nbsp;</a></span>SymmetrySetPrimaryMotif() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> ON_SubD::SymmetrySetPrimaryMotif </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a>&#160;</td>
          <td class="paramname"><em>cptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: cptr - [in] Returns: If the component is in a symmetry set, the motif component is returned. Otherwise nullptr is returned. </p>

</div>
</div>
<a id="a55efd114115ec1d2029b1a223c00d220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55efd114115ec1d2029b1a223c00d220">&#9670;&nbsp;</a></span>TextureCoordinateType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a> ON_SubD::TextureCoordinateType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e8505b580a27ddf53b222b7ede1024a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8505b580a27ddf53b222b7ede1024a">&#9670;&nbsp;</a></span>TextureCoordinateTypeFromObsoleteTextureDomainType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a> ON_SubD::TextureCoordinateTypeFromObsoleteTextureDomainType </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>obsolete_texture_domain_type_as_unsigned</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4709733867708cd9adf94504a19183df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4709733867708cd9adf94504a19183df">&#9670;&nbsp;</a></span>TextureCoordinateTypeFromUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a> ON_SubD::TextureCoordinateTypeFromUnsigned </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>texture_coordinate_type_as_unsigned</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f4a9535477f648edd823acbb06bea7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4a9535477f648edd823acbb06bea7a">&#9670;&nbsp;</a></span>TextureCoordinateTypeToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__w_string.html">ON_wString</a> ON_SubD::TextureCoordinateTypeToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a>&#160;</td>
          <td class="paramname"><em>texture_domain_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a86a2bb58158274846a0cb947f5e1ad71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86a2bb58158274846a0cb947f5e1ad71">&#9670;&nbsp;</a></span>TextureDomainGridSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__2udex.html">ON_2udex</a> ON_SubD::TextureDomainGridSize </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>minimum_rectangle_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>image_width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>image_height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: minimum_rectangle_count - [in] &gt;= 1 minimum number of rectangles in texture domain image_width - [in] image_height = [in] If a texture image size is known, pass it here. Otherwise pass 0.0 for both parameters. Returns: Suggested way to partition a texture coodinate domain into rectangles. <a class="el" href="class_o_n__2udex.html#a60e321ba0f18dab8db348c4c584bd9f7" title="do not initialize i, j for performance reasons">ON_2udex.i</a> = "x" count <a class="el" href="class_o_n__2udex.html#a033c8282e62810853c304484c1bd9e4e">ON_2udex.j</a> = "y" count For example (3,2) would mean divide the 2d texture domain into 3 segments across and 2 segments vertically. </p>

</div>
</div>
<a id="ad4fa8b5c8c6ee1ee64cf4c5a17fec5a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4fa8b5c8c6ee1ee64cf4c5a17fec5a7">&#9670;&nbsp;</a></span>TextureMappingRequired()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::TextureMappingRequired </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: True if setting texture coordinates requires a set <a class="el" href="class_o_n___texture_mapping.html">ON_TextureMapping</a> mapping. Remarks: An explict texture mapping is required when <a class="el" href="class_o_n___sub_d.html#a55efd114115ec1d2029b1a223c00d220">TextureCoordinateType()</a> is <a class="el" href="group__open_n_u_r_b_s.html#gga6c7104f591f9fbf8f6ab27894df3e33fa89f9b9ddf04ecff851cdf05c1617c636">ON_SubDTextureCoordinateType::FromMapping</a> and <a class="el" href="class_o_n___sub_d.html#a117e6bd61b7ce2b713582273af2923d4">TextureMappingTag()</a> is set and not <a class="el" href="class_o_n___mapping_tag.html#afa5ada24588107d4db868c28fc034a30">ON_MappingTag::SurfaceParameterMapping</a> or an equivalent surface parameter mapping. </p>

</div>
</div>
<a id="a117e6bd61b7ce2b713582273af2923d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117e6bd61b7ce2b713582273af2923d4">&#9670;&nbsp;</a></span>TextureMappingTag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> ON_SubD::TextureMappingTag </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bIgnoreTextureCoordinateType</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: bIgnoreTextureCoordinateType - [in] If true, the current texture mapping tag is returned. If false, the current texture mapping tag is returned only when <a class="el" href="group__open_n_u_r_b_s.html#gga6c7104f591f9fbf8f6ab27894df3e33fa89f9b9ddf04ecff851cdf05c1617c636">ON_SubDTextureCoordinateType::FromMapping</a> = <a class="el" href="class_o_n___sub_d.html#a55efd114115ec1d2029b1a223c00d220">TextureCoordinateType()</a>. Returns: The current texture mapping tag. Remarks: The texture mapping tag should be applied only when this-&gt;<a class="el" href="class_o_n___sub_d.html#a55efd114115ec1d2029b1a223c00d220">TextureCoordinateType()</a> is <a class="el" href="group__open_n_u_r_b_s.html#gga6c7104f591f9fbf8f6ab27894df3e33fa89f9b9ddf04ecff851cdf05c1617c636">ON_SubDTextureCoordinateType::FromMapping</a>. SubD texture domains and coordinates are a mutable property. They can be changed by rendering applications as needed. </p>

</div>
</div>
<a id="a5862639f6aca7351b02b9d45b9eda205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5862639f6aca7351b02b9d45b9eda205">&#9670;&nbsp;</a></span>TexturePointsAreSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::TexturePointsAreSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: Number of faces with <a class="el" href="class_o_n___sub_d_face.html#a6133a0010055a3b72c2fd35dfc31ae2b">ON_SubDFace.TexturePointsAreSet()</a> = true. </p>

</div>
</div>
<a id="a8ae0311d57d652d267e14c2029b42f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae0311d57d652d267e14c2029b42f17">&#9670;&nbsp;</a></span>TextureSettingsHash() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubD::TextureSettingsHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns: <a class="el" href="class_o_n___sub_d.html#a5cbe52b259de629d208d6310bab45014">ON_SubD::TextureSettingsHash</a>(this-&gt;<a class="el" href="class_o_n___sub_d.html#a55efd114115ec1d2029b1a223c00d220">TextureCoordinateType()</a>,this-&gt;<a class="el" href="class_o_n___sub_d.html#a117e6bd61b7ce2b713582273af2923d4">TextureMappingTag()</a>); Remarks: Comparing with this-&gt;<a class="el" href="class_o_n___sub_d.html#a7df5adfe19107926126f077722831b50">FragmentTextureCoordinatesTextureSettingsHash()</a> can tell you if the current fragment texture coordinates were calculated using the same settings. </p>

</div>
</div>
<a id="a5cbe52b259de629d208d6310bab45014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cbe52b259de629d208d6310bab45014">&#9670;&nbsp;</a></span>TextureSettingsHash() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubD::TextureSettingsHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a>&#160;</td>
          <td class="paramname"><em>texture_coordinate_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___mapping_tag.html">ON_MappingTag</a> &amp;&#160;</td>
          <td class="paramname"><em>texture_mapping_tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: texture_coordinate_type - [in] texture_mapping_tag - [in] If texture_coordinate_type is ON_SubDTextureCoordinateType::Custom, then then texture_mapping_tag information is included in the hash. Otherwise, texture_mapping_tag is ignored. Returns: A hash that uniquely identifies the information in <a class="el" href="class_o_n___sub_d.html#a55efd114115ec1d2029b1a223c00d220">TextureCoordinateType()</a> and <a class="el" href="class_o_n___sub_d.html#a117e6bd61b7ce2b713582273af2923d4">TextureMappingTag()</a> that applies to the current subd. </p>

</div>
</div>
<a id="ae0a06c7826df2f6138eb6dde6cbd6a10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0a06c7826df2f6138eb6dde6cbd6a10">&#9670;&nbsp;</a></span>ToggleSubDAppearanceValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> ON_SubD::ToggleSubDAppearanceValue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>subd_appearance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Description: Get the SubD appearance (surface or control net); Returns: <a class="el" href="group__open_n_u_r_b_s.html#gga0a25951e3c8f7324e2747162822b819aaaa0d528ba11ea1485d466dfe1ea40819">ON_SubDComponentLocation::Surface</a> or <a class="el" href="group__open_n_u_r_b_s.html#gga0a25951e3c8f7324e2747162822b819aa7cb4aa7a91fc1cc1d459f6a5894e3057">ON_SubDComponentLocation::ControlNet</a>. </p>

</div>
</div>
<a id="a2710380a0b8a0fc81c752a7c99b1bbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2710380a0b8a0fc81c752a7c99b1bbf1">&#9670;&nbsp;</a></span>TopologyHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubD::TopologyHash </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: If two SubDs have identical values of <a class="el" href="class_o_n___sub_d.html#a2710380a0b8a0fc81c752a7c99b1bbf1">TopologyHash()</a>, then they have identical labeled control net topology. The labels are the vertex, edge, and face ids. Returns: this-&gt;SubDHash(ON_SubDHashType::Topology,false).<a class="el" href="class_o_n___sub_d.html#a753cbf6fa759787e06c54e4c76f6a702">SubDHash()</a>. Remarks: Two SubDs can have the same topology hash but different geometry hashes. </p>

</div>
</div>
<a id="a9814679b28aa6b8b427d4ec4b7bba86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9814679b28aa6b8b427d4ec4b7bba86c">&#9670;&nbsp;</a></span>ToSubD()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>* ON_SubD::ToSubD </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___geometry.html">ON_Geometry</a> *&#160;</td>
          <td class="paramname"><em>geometry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_from_mesh_parameters.html">ON_SubDFromMeshParameters</a> *&#160;</td>
          <td class="paramname"><em>from_mesh_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_from_surface_parameters.html">ON_SubDFromSurfaceParameters</a> *&#160;</td>
          <td class="paramname"><em>from_surface_parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html">ON_SubD</a> *&#160;</td>
          <td class="paramname"><em>destination_subd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bbf2e7a459c34f6ebaf254218d0e905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bbf2e7a459c34f6ebaf254218d0e905">&#9670;&nbsp;</a></span>Transform()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::Transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___geometry.html#add710872e89bc29e1ed1321b3e70b1b1">ON_Geometry</a>.</p>

</div>
</div>
<a id="a95d741e9c910175d62a81b345118dff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d741e9c910175d62a81b345118dff8">&#9670;&nbsp;</a></span>TransformComponents() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::TransformComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a> *&#160;</td>
          <td class="paramname"><em>ci_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ci_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>component_location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Transforms the SubD components in ci_list[]. Parameters: xform - [in] ci_list - [in] ci_count - [in] component_location - [in] Select between applying the tranform to the control net (faster) or the surface points (slower). Returns: Number of vertex locations that changed. </p>

</div>
</div>
<a id="ad01eb36cc2d54649068129b9081680af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad01eb36cc2d54649068129b9081680af">&#9670;&nbsp;</a></span>TransformComponents() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::TransformComponents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___xform.html">ON_Xform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d_component_ptr.html">ON_SubDComponentPtr</a> *&#160;</td>
          <td class="paramname"><em>cptr_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cptr_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a>&#160;</td>
          <td class="paramname"><em>component_location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa160ed35b21d978c133049442763deec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa160ed35b21d978c133049442763deec">&#9670;&nbsp;</a></span>UnselectComponents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::UnselectComponents </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUnselectAllVertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUnselectAllEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUnselectAllFaces</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa8d5e08093907df26106d5c6b286231f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d5e08093907df26106d5c6b286231f">&#9670;&nbsp;</a></span>UpdateAllTagsAndSectorCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::UpdateAllTagsAndSectorCoefficients </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUnsetValuesOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Updates vertex tag, edge tag, and edge coefficient values on the active level.</p>
<p>After completing custom editing operations that modify the topology of the SubD control net or changing values of vertex or edge tags, the tag and sector coefficients information on nearby components in the edited areas need to be updated.</p>
<p>Parameters: bUnsetValuesOnly - [in] If true, the update is restricted to vertices tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga97b7326e722ee6c1b1ec64023ab1a375ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDVertexTag::Unset</a> and edges tagged as <a class="el" href="group__open_n_u_r_b_s.html#gga09d9a731b3db1b876e97b6b43246c325ac9f88e098f6fe4e4e112eeb05ccb9671">ON_SubDEdgeTag::Unset</a>.</p>
<p>Returns: Number of vertices and edges that were changed during the update. </p>

</div>
</div>
<a id="a4b61884e42bdff1e5b4c86b21c20289c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b61884e42bdff1e5b4c86b21c20289c">&#9670;&nbsp;</a></span>UpdateEdgeSectorCoefficients()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::UpdateEdgeSectorCoefficients </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUnsetSectorCoefficientsOnly</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool if for expert users writing advanced editing tools. After completing custom editing operations that modify the topology of the SubD control net or changing values of vertex or edge tags, the tag and sector coefficients information on nearby components in the edited areas need to be updated. Parameters: bUnsetValuesOnly - [in] If bUnsetValuesOnly is true, then only unset tags and sector coefficients will be updated. If bUnsetValuesOnly is false, then all tags and sector coefficients will be checked and updated as needed. Returns: Number of edges that had a tag value changed or sector coefficient set to <a class="el" href="class_o_n___sub_d_sector_type.html#a95adb9f9e356893850b3cb5dc7b3b5e6" title="= -8883.0;">ON_SubDSectorType::UnsetSectorCoefficient</a>. Remarks: It is easiest to call <a class="el" href="class_o_n___sub_d.html#aa8d5e08093907df26106d5c6b286231f">UpdateAllTagsAndSectorCoefficients()</a>. </p>

</div>
</div>
<a id="a6c444b72b00a88cb24cbd12969f3fdf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c444b72b00a88cb24cbd12969f3fdf4">&#9670;&nbsp;</a></span>UpdateEdgeTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::UpdateEdgeTags </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUnsetEdgeTagsOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool if for expert users writing advanced editing tools. After completing custom editing operations that modify the topology of the SubD control net or changing values of vertex or edge tags, the tag and sector coefficients information on nearby components in the edited areas need to be updated. Parameters: bUnsetValuesOnly - [in] If bUnsetValuesOnly is true, then only unset tags and sector coefficients will be updated. If bUnsetValuesOnly is false, then all tags and sector coefficients will be checked and updated as needed. Returns: Number of edges that had a tag value changed or sector coefficient set to <a class="el" href="class_o_n___sub_d_sector_type.html#a95adb9f9e356893850b3cb5dc7b3b5e6" title="= -8883.0;">ON_SubDSectorType::UnsetSectorCoefficient</a>. Remarks: It is easiest to call <a class="el" href="class_o_n___sub_d.html#aa8d5e08093907df26106d5c6b286231f">UpdateAllTagsAndSectorCoefficients()</a>. </p>

</div>
</div>
<a id="a6abc8cfa298276013a6a7b80bd911dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abc8cfa298276013a6a7b80bd911dd6">&#9670;&nbsp;</a></span>UpdateSurfaceMeshCache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::UpdateSurfaceMeshCache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLazyUpdate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Updates limit surface information returned by <a class="el" href="class_o_n___sub_d_vertex.html#ac3dce2de14299a2463a7cca120667414">ON_SubDVertex.GetSurfacePoint()</a>, <a class="el" href="class_o_n___sub_d_edge.html#a74fe7d824d457425a65252d2acb7df26">ON_SubDEdge.EdgeSurfaceCurve()</a>, and ON_SubDFace.SurfaceMeshFragments(). The density of the mesh cache is ON_SubDDisplayParameters::AutomaticDisplayDensityFromSubD(*this). Parameters: bLazyUpdate - [in] If false, all information is updated. If true, only missing information is updated. If a relatively small subset of a SubD has been modified and care was taken to mark cached subdivision information as stale, then passing true can substantually improve performance. Returns: Number of elements that were updated. </p>

</div>
</div>
<a id="a18de23ca2b73a3eb4dc8f1c91ce31a50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18de23ca2b73a3eb4dc8f1c91ce31a50">&#9670;&nbsp;</a></span>UpdateSurfaceMeshCache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::UpdateSurfaceMeshCache </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bLazyUpdate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSetUnchangedFaceColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___color.html">ON_Color</a>&#160;</td>
          <td class="paramname"><em>unchanged_face_color</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSetUpdatedFaceColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_o_n___color.html">ON_Color</a>&#160;</td>
          <td class="paramname"><em>updated_face_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Updates limit surface information returned by <a class="el" href="class_o_n___sub_d_vertex.html#ac3dce2de14299a2463a7cca120667414">ON_SubDVertex.GetSurfacePoint()</a>, <a class="el" href="class_o_n___sub_d_edge.html#a74fe7d824d457425a65252d2acb7df26">ON_SubDEdge.EdgeSurfaceCurve()</a>, and ON_SubDFace.SurfaceMeshFragments(). The density of the mesh cache is ON_SubDDisplayParameters::AutomaticDisplayDensityFromSubD(*this). Parameters: bLazyUpdate - [in] If false, all information is updated. If true, only missing information is updated. If a relatively small subset of a SubD has been modified and care was taken to mark cached subdivision information as stale, then passing true can substantually improve performance. bSetUnchangedFaceColor - [in] unchanged_face_color - [in] If bSetUnchangedFaceColor is true, then unchanged_face_color is set as the per face color for faces whose mesh fragments are not recalculated. This is typically used in debugging. bSetUpdatedFaceColor - [in] updated_face_color - [in] If bSetUpdatedFaceColor is true, then updated_face_color is set as the per face color for faces whose mesh fragments are recalculated. This is typically used in debugging. Returns: Number of elements that were updated. </p>

</div>
</div>
<a id="a40bc90f50d55be57189005f5272eca38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40bc90f50d55be57189005f5272eca38">&#9670;&nbsp;</a></span>UpdateSymmetry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__open_n_u_r_b_s.html#ga86eee0ec4181c58610cf6af6a1f07a2a">ON_WIP_SDK</a> bool ON_SubD::UpdateSymmetry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___simple_array.html">ON_SimpleArray</a>&lt; unsigned int &gt; &amp;&#160;</td>
          <td class="paramname"><em>moved_vertices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bPermitTopologyChange</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Update existing symmetry on this SubD. Parameters: moved_vertices - [in] ids of vertices that have been moved bPermitTopologyChange - [in] True if the subd control net topology can change. <br  />
 Returns: True if succesful </p>

</div>
</div>
<a id="a57eea53ca915c794ed427e274779c69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57eea53ca915c794ed427e274779c69e">&#9670;&nbsp;</a></span>UpdateVertexTags()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::UpdateVertexTags </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bUnsetVertexTagsOnly</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: This tool if for expert users writing advanced editing tools. After completing custom editing operations that modify the topology of the SubD control net or changing values of vertex or edge tags, the tag and sector coefficients information on nearby components in the edited areas need to be updated. Parameters: bUnsetTagsOnly - [in] If bUnsetTagsOnly is true, then only unset tags and ill be updated. If bUnsetTagsOnly is false, then all tags and will be checked and updated as needed. Returns: Number of vertices that changed during the update. Remarks: It is easiest to call <a class="el" href="class_o_n___sub_d.html#aa8d5e08093907df26106d5c6b286231f">UpdateAllTagsAndSectorCoefficients()</a>. </p>

</div>
</div>
<a id="a9674c00c94246dac4344b81603591445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9674c00c94246dac4344b81603591445">&#9670;&nbsp;</a></span>VertexArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_vertex_array.html">ON_SubDVertexArray</a> ON_SubD::VertexArray </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Description: Avoid using this class. It is more efficient to use an <a class="el" href="class_o_n___sub_d_vertex_iterator.html">ON_SubDVertexIterator</a> returned by <a class="el" href="class_o_n___sub_d.html#a2a6d675b296f4b80f7bce6becb5a9ece">VertexIterator()</a>. </p>

</div>
</div>
<a id="ae18dfbfc1090b4d0f6755e73e034bdfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18dfbfc1090b4d0f6755e73e034bdfa">&#9670;&nbsp;</a></span>VertexCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::VertexCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Vertex access Returns: Number of vertices in the active level. </p>

</div>
</div>
<a id="a43ff849a7ae2edb61a78ff6c2be74cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ff849a7ae2edb61a78ff6c2be74cb2">&#9670;&nbsp;</a></span>VertexFacetTypeFromUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html#a669d9987c2605ae8d914ca28a1b6a07e">ON_SubD::VertexFacetType</a> ON_SubD::VertexFacetTypeFromUnsigned </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vertex_facet_type_as_unsigned</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4905b6f57be48ec6a7cf6ae62894b0b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4905b6f57be48ec6a7cf6ae62894b0b4">&#9670;&nbsp;</a></span>VertexFromComponentIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::VertexFromComponentIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___c_o_m_p_o_n_e_n_t___i_n_d_e_x.html">ON_COMPONENT_INDEX</a>&#160;</td>
          <td class="paramname"><em>component_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22c6558733168d3d191a9324255ddced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c6558733168d3d191a9324255ddced">&#9670;&nbsp;</a></span>VertexFromId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> class <a class="el" href="class_o_n___sub_d_vertex.html">ON_SubDVertex</a>* ON_SubD::VertexFromId </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vertex_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: vertex_id - [in] Returns: If vertex_id identifies a valid vertex in this <a class="el" href="class_o_n___sub_d.html">ON_SubD</a>, then a pointer to that vertex is returned. Otherwise, nullptr is returned. </p>

</div>
</div>
<a id="aa33462de01a8e4c7d861ee476a61e84e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa33462de01a8e4c7d861ee476a61e84e">&#9670;&nbsp;</a></span>VertexHash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___s_h_a1___hash.html">ON_SHA1_Hash</a> ON_SubD::VertexHash </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga7901fb222b1b25e32978f0b34ba7234a">ON_SubDHashType</a>&#160;</td>
          <td class="paramname"><em>hash_type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parameters: hash_type - [in] All hashes include vertex id. Geometry hashes include vertex tag, vertex control point, and vertex displacement. Returns: A SHA1 hash of the SubD's vertices. </p>

</div>
</div>
<a id="a2a6d675b296f4b80f7bce6becb5a9ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6d675b296f4b80f7bce6becb5a9ece">&#9670;&nbsp;</a></span>VertexIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">class <a class="el" href="class_o_n___sub_d_vertex_iterator.html">ON_SubDVertexIterator</a> ON_SubD::VertexIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Example: <a class="el" href="class_o_n___sub_d_vertex_iterator.html">ON_SubDVertexIterator</a> vit = subd.VertexIterator(); for ( const ON_SubDVertex* v = vit.FirstVertex(); nullptr != v; v = vit.NextVertex()) { ... } </p>

</div>
</div>
<a id="a042140d0f88f2bd8296c9204ac1d2c5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a042140d0f88f2bd8296c9204ac1d2c5d">&#9670;&nbsp;</a></span>VertexTagFromUnsigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a> ON_SubD::VertexTagFromUnsigned </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vertex_tag_as_unsigned</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a3a3ecd63cb32092d68750e72ec9d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a3a3ecd63cb32092d68750e72ec9d9d">&#9670;&nbsp;</a></span>VertexTagIsSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool ON_SubD::VertexTagIsSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parameters: vertex_tag - [in] Returns: True if vertex_tag is Smooth, Crease, Corner, or Dart. False otherwise. </p>

</div>
</div>
<a id="a0a333c6e6a3241e8f7c5e70e0f43f641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a333c6e6a3241e8f7c5e70e0f43f641">&#9670;&nbsp;</a></span>VertexTagToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n__w_string.html">ON_wString</a> ON_SubD::VertexTagToString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__open_n_u_r_b_s.html#ga97b7326e722ee6c1b1ec64023ab1a375">ON_SubDVertexTag</a>&#160;</td>
          <td class="paramname"><em>vertex_tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bVertose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Paramters: vertex_tag - [in] bVerbose - [in] If verbose, the tag name is preceded with "ON_SubDVertexTag::". Returns: vertex_tag as a string. </p>

</div>
</div>
<a id="aa490f39b642d80aef693838cbffdc899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa490f39b642d80aef693838cbffdc899">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ON_SubD::Write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_o_n___binary_archive.html">ON_BinaryArchive</a> &amp;&#160;</td>
          <td class="paramname"><em>archive</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>virtual </p>

<p>Reimplemented from <a class="el" href="class_o_n___object.html#a16eb9ab6bf0d0a614655cf9cd055871a">ON_Object</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a431e8061728e7cfcb0c903e5aaf71c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a431e8061728e7cfcb0c903e5aaf71c71">&#9670;&nbsp;</a></span>ON_SubDRef</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="class_o_n___sub_d_ref.html">ON_SubDRef</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7779274fc4314207f5c8d71accb180dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7779274fc4314207f5c8d71accb180dd">&#9670;&nbsp;</a></span>const</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* * ON_RTreeRef ControlNetComponentTree bool ON_SubD::const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab50603eacdbc50beb23a88590df6e55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab50603eacdbc50beb23a88590df6e55c">&#9670;&nbsp;</a></span>DefaultFacePackingId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> ON_SubD::DefaultFacePackingId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ADD NEW PackFaces ids above this comment and below FastAndSimplePackFacesId. </p>
<p><a class="el" href="class_o_n___sub_d.html#ab50603eacdbc50beb23a88590df6e55c" title="ADD NEW PackFaces ids above this comment and below FastAndSimplePackFacesId.">ON_SubD::DefaultFacePackingId</a> ideitifies the default face packing. Code that wants to use the built-in face packing that is currently the best option for general use, will specify <a class="el" href="class_o_n___sub_d.html#ab50603eacdbc50beb23a88590df6e55c" title="ADD NEW PackFaces ids above this comment and below FastAndSimplePackFacesId.">ON_SubD::DefaultFacePackingId</a>.</p>
<p>Currently this id is <a class="el" href="class_o_n___sub_d.html#acd29ac82d1fa8c05858cfb0e20d84880" title="The fast and simple face packing uses topology, vertex tags, and edge tags to group quads into rectan...">ON_SubD::FastAndSimpleFacePackingId</a>. In the future it may be changed to another id. Code that wants to always apply the same face packing will explicitly specify one of the built-in face pack ids defined above.</p>

</div>
</div>
<a id="ae697f8dd0197a793faefd5dd71c626dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae697f8dd0197a793faefd5dd71c626dc">&#9670;&nbsp;</a></span>DefaultSubDAppearance</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga0a25951e3c8f7324e2747162822b819a">ON_SubDComponentLocation</a> ON_SubD::DefaultSubDAppearance</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>= <a class="el" href="group__open_n_u_r_b_s.html#gga0a25951e3c8f7324e2747162822b819aaaa0d528ba11ea1485d466dfe1ea40819">ON_SubDComponentLocation::Surface</a> </p>

</div>
</div>
<a id="ab94a79d9f4138a75a94a04aa1632a134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94a79d9f4138a75a94a04aa1632a134">&#9670;&nbsp;</a></span>DefaultTextureCoordinateType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#ga6c7104f591f9fbf8f6ab27894df3e33f">ON_SubDTextureCoordinateType</a> ON_SubD::DefaultTextureCoordinateType</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>= <a class="el" href="group__open_n_u_r_b_s.html#gga6c7104f591f9fbf8f6ab27894df3e33faa1977c3f68d4d3bbfe14d0e51a575482">ON_SubDTextureCoordinateType::Packed</a> </p>

</div>
</div>
<a id="aadc6b3bd637b36f409114a91ef9c2a51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadc6b3bd637b36f409114a91ef9c2a51">&#9670;&nbsp;</a></span>Empty</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> ON_SubD::Empty</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a778015a5a25baa18fef1c821f325a1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a778015a5a25baa18fef1c821f325a1f2">&#9670;&nbsp;</a></span>ErrorCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ON_SubD::ErrorCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="class_o_n___sub_d.html">ON_SubD</a> code increments <a class="el" href="class_o_n___sub_d.html#a778015a5a25baa18fef1c821f325a1f2">ON_SubD::ErrorCount</a> everytime something unexpected happens. This is useful for debugging. </p>

</div>
</div>
<a id="acd29ac82d1fa8c05858cfb0e20d84880"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd29ac82d1fa8c05858cfb0e20d84880">&#9670;&nbsp;</a></span>FastAndSimpleFacePackingId</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_o_n___sub_d.html#a7779274fc4314207f5c8d71accb180dd">const</a> <a class="el" href="group__open_n_u_r_b_s.html#gadb9844468b1cef57a0f269d1302792bb">ON_UUID</a> ON_SubD::FastAndSimpleFacePackingId</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The fast and simple face packing uses topology, vertex tags, and edge tags to group quads into rectangular grids. It does not perform geometric feature analysis. {C3D8DD54-F8C8-4455-BB0E-2A2F4988EC81} </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 10 2022 21:11:19 for Rhino C++ API by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
